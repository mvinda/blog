<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vinda</title>
  
  <subtitle>人生若如初见</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-28T07:17:06.314Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Vinda</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://example.com/2021/01/31/%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/01/31/%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-10-28T07:17:06.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>适配器模式把一个类的接口变换成客户端所期待的另外一种接口，从而使原本不匹配的接口能在一起工作</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>（1）系统需要使用一个现有的类，而此类的接口不符合系统的需要，就是接口不兼容<br>（2）想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作<br>（3）需要一个统一的输出接口，而输出端类型不可预知</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/medias/paper/build.png" alt="建造者模式类图"></p><p>我们可以看到<br>Target 目标角色 也就是所期待得到的接口<br>Adaptee 现在需要适配的接口<br>Adapter 适配器角色 也是核心类把源接口转成目标接口 这里不能是接口 而必须是特定的类</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>原来要适配的接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Volt220</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getVolt220</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">220</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义要适配的接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FiveVolt</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getVolt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>适配的核心接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoltAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">Volt220</span> <span class="token keyword">implements</span> <span class="token class-name">FiveVolt</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getVolt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">VoltAdapter</span> voltAdapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VoltAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        voltAdapter<span class="token punctuation">.</span><span class="token function">getVolt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Android其他使用<br>在Android上适配器也被用来适配多种数据来源 我们将view的组装交给用户 ListView只需要拿到适配器就可以显示ui，隔离变化 拥抱变化</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>1.更好的复用性<br>系统需要使用现有的类 而此类的接口不符合系统的需要，那么通过适配器可以让这些功能得到更好的复用<br>2. 更好扩展性<br>实现适配器的功能时候，可以调用自己开发的功能，从而自然地扩展系统的功能</p><p>缺点<br>过多使用适配器会让系统非常凌乱，不容易整体把控。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;适配器模式把一个类的接口变换成客户端所期待的另外一种接口，从而使原本不匹配的接口能在一起工作&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记--编写可读代码的艺术</title>
    <link href="http://example.com/2021/01/30/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>http://example.com/2021/01/30/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2021-10-26T05:20:04.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读完这本书主要是回答几个问题"><a href="#读完这本书主要是回答几个问题" class="headerlink" title="读完这本书主要是回答几个问题"></a>读完这本书主要是回答几个问题</h1><h2 id="什么是好的代码？"><a href="#什么是好的代码？" class="headerlink" title="什么是好的代码？"></a>什么是好的代码？</h2><p>好的代码就是可读性好，可读性好就是代码应当使别人理解它所需要的时间最少。</p><h2 id="什么样的命名是好的命名呢？"><a href="#什么样的命名是好的命名呢？" class="headerlink" title="什么样的命名是好的命名呢？"></a>什么样的命名是好的命名呢？</h2><p>要把信息塞进名字中，读者通过名字就可以获得很多的信息。<br>使用专业的单词，不用get  用download  fetch 等更好。<br>不要用空泛的词，比如tmp。<br>用具体的名字来更细致描述事物。<br>给变量名带上重要的细节。<br>为作用域大的名字用更长的名字。<br>有目的地使用大小写和下划线等</p><p>不会误解的名字是最好的名字，阅读的人应该能准确的理解你的意思，命名前多想一下 其他人是否有其他的理解。<br>用布尔值的时候，用is 和 has这样的词来表达。<br>小心用户对特定词的期待 他们会觉得 get 或者 size是轻量的方法。</p><h2 id="大家觉得什么样的代码是漂亮的代码"><a href="#大家觉得什么样的代码是漂亮的代码" class="headerlink" title="大家觉得什么样的代码是漂亮的代码?"></a>大家觉得什么样的代码是漂亮的代码?</h2><p>大家都愿意读有美感的代码，通过把代码用一致的，有意义的格式化 可以把代码变得更容易读，且可以读得很快。</p><h2 id="什么样的注释需要写-怎么写"><a href="#什么样的注释需要写-怎么写" class="headerlink" title="什么样的注释需要写,怎么写"></a>什么样的注释需要写,怎么写</h2><p>并不是所有地方都要写注释，能从代码本身快速判断的不要写注释。<br>想要来粉饰命名不好的注释不要写，直接改方法名或者类名。<br>你可以写代码为什么这么写的注释而不是正常的写法，一些背后的故事。</p><h2 id="如何让你的代码更容易阅读？"><a href="#如何让你的代码更容易阅读？" class="headerlink" title="如何让你的代码更容易阅读？"></a>如何让你的代码更容易阅读？</h2><p>在写比较的时候，把改变的变量写在左边，常量或者稳定的值写在右边。<br>尽量减少中间变量，可以立即处理中间结果 。<br>小心变量的作用域，作用域越小越好。<br>只写一次的变量就更好了，这些变量只设置一次就不再设置了。</p><h2 id="如何写代码问题少？"><a href="#如何写代码问题少？" class="headerlink" title="如何写代码问题少？"></a>如何写代码问题少？</h2><p>把一般的代码和项目的专有代码分开，这样大部分的代码都是一般代码 也就是库里封装好的代码，通过建立一大组库和辅助函数解决一般问题，剩下的只剩让你的程序与众不同的部分。<br> 一个简单的技巧就是一次只做一件事，如果你有很难读的代码试着把这个代码的所有任务都列出来，把这些任务封成方法，其他的简单成为函数中的逻辑段落。</p><h2 id="为什么说代码越少越好？"><a href="#为什么说代码越少越好？" class="headerlink" title="为什么说代码越少越好？"></a>为什么说代码越少越好？</h2><p>代码越少越好，因为每一行都需要测试和维护。<br>你可以在项目中消除不要的功能，也不要过度的设计。<br>重新考虑需求，解决版本最简单的问题，只要能完成工作就好。<br>有单元测试十分重要，，而且测试的可读性也很重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读完这本书主要是回答几个问题&quot;&gt;&lt;a href=&quot;#读完这本书主要是回答几个问题&quot; class=&quot;headerlink&quot; title=&quot;读完这本书主要是回答几个问题&quot;&gt;&lt;/a&gt;读完这本书主要是回答几个问题&lt;/h1&gt;&lt;h2 id=&quot;什么是好的代码？&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="日常积累" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://example.com/2021/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-21T16:00:00.000Z</published>
    <updated>2021-09-20T13:26:35.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h1><h2 id="1-为什么要学习单例？"><a href="#1-为什么要学习单例？" class="headerlink" title="1.为什么要学习单例？"></a>1.为什么要学习单例？</h2><p>单例模式应该是用得最多的设计模式之一，如果你的应用有个类很消耗资源 那么我们没有理由让他们不断创建</p><h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p>确保一个类只有一个实例，而且自行实例化，并向系统提供这个实例。</p><h2 id="3-适合场景"><a href="#3-适合场景" class="headerlink" title="3.适合场景"></a>3.适合场景</h2><p>确保一个类只有一个对象的地方，避免产生多个对象消耗过多的资源，或者说创建一个对象需要耗费大量的资源 也需要用单例模式。</p><p><img src="/medias/paper/singleInstance.png" alt="单例类图"></p><h2 id="4-实现的关键点"><a href="#4-实现的关键点" class="headerlink" title="4.实现的关键点"></a>4.实现的关键点</h2><p>*构造方法不对外开发 一般是private</p><p>*通过一个静态方法或者枚举返回单例对象</p><p>*确保单例对象有且只有一个，尤其在多线程的环境下</p><h2 id="5-多种单例的写法和优缺点"><a href="#5-多种单例的写法和优缺点" class="headerlink" title="5.多种单例的写法和优缺点"></a>5.多种单例的写法和优缺点</h2><p>5.1 饿汉方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton1</span> mSingleton1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton1</span> <span class="token function">getSingleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mSingleton1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：实现简单<br>缺点：饿汉在初始化声明的时候就已经初始化了这个对象，会造成内存的浪费，可能用户并不需要这个类，或者用不到</p><p>5.2 懒汉方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton2</span> mSingleton2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton2</span> <span class="token function">getSingleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mSingleton2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mSingleton2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mSingleton2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：在需要用的时候才初始化，减少资源浪费<br>缺点：缺点是在用的时候初始化会导致生成比较慢，在多线程的情况下会出现线程安全的问题，所以需要加锁，但是在加锁后又会有每次加锁的问题，进一步降低了性能。</p><p>5.3 DLC</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton3</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton3</span> mSingleton3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton3</span> <span class="token function">getSingleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mSingleton3 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton3</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mSingleton3 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    mSingleton3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mSingleton3<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：既能够在第一次用的时候初始化，又能够线程安全，而且能初始化后就不加锁了<br>缺点：比较复杂一点<br>注意 记得加上volatile 关键子，因为创建对象不是一个原子操作，可能会导致DCL失效，就是创建了但是没有初始化， volatile虽然会影响性能，但是跟准确性相比还是值得的</p><p>为什么会失效，就是new 一个对象的时候<br>1.先分配内存<br>2.初始化成员变量<br>3.将对象指向分配的空间<br>由于执行是乱序的，可能先执行了3 再执行2 这样在多线程的情况下会出现没有初始化的成员变量的情况出现</p><p>5.4 静态内部类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton4</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Singleton4Holder</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton4</span> mSingleton4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton4</span> <span class="token function">getSingleton4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Singleton4Holder</span><span class="token punctuation">.</span>mSingleton4<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：既能保证线程安全，又能保证兼顾性能，推荐使<br>5.4.1 静态内部类加锁原理：<br>首先要了解类加载过程中的最后一个阶段：即类的初始化，类的初始化阶本质就是执行类构造器的方法。<br>方法：这不是由程序员写的程序，而是根据代码由javac编译器生成的。它是由类里面所有的类变量的赋值动作和静态代码块组成的。JVM内部会保证一个类的方法在多线程环境下被正确的加锁同步，也就是说如果多个线程同时去进行“类的初始化”，那么只有一个线程会去执行类的方法，其他的线程都要阻塞等待，直到这个线程执行完方法。然后执行完方法后，其他线程唤醒，但是不会再进入()方法。也就是说同一个加载器下，一个类型只会初始化一次。</p><p>那么回到这个代码中，这里的静态变量的赋值操作进行编译之后实际上就是一个代码，当我们执行getInstance方法的时候，会导致Singleton4Holder类的加载，类加载的最后会执行类的初始化，但是即使在多线程情况下，这个类的初始化的代码也只会被执行一次，所以他只会有一个实例</p><p>5.5 枚举单例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span>  <span class="token class-name">Singleton5</span> <span class="token punctuation">&#123;</span>    INSTANCE<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：既能保证线程安全，又能保证兼顾性能，推荐使用</p><p>为什么能保证线程的安全？<br>因为java在编译器变成class代码的时候枚举是一个静态变量类的加载过程中在初始化的时候会保证静态变量的线程安全加载。</p><p>6.单例模式的优缺点<br>优点<br>1因为内存中只有创建一个实例，能减少内存的开销。<br>2.因为只有一个对象能减少对资源的占用，避免死锁等事情的发生。</p><p>缺点：<br>1.单例模式容易引起内存泄露，因为他的生命周期比较长，注意传递最好传递Application Contenxt<br>2.单例模式没有接口，如果有逻辑修改或者扩展，那么只能改到代码，不符合高扩展性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式之单例模式&quot;&gt;&lt;a href=&quot;#设计模式之单例模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式之单例模式&quot;&gt;&lt;/a&gt;设计模式之单例模式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么要学习单例？&quot;&gt;&lt;a href=&quot;#1-为什么要学习单例？&quot; c</summary>
      
    
    
    
    <category term="代码设计" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
