<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vinda</title>
  
  <subtitle>人生若如初见</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-20T13:26:35.264Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Vinda</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://example.com/2021/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-21T16:00:00.000Z</published>
    <updated>2021-09-20T13:26:35.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h1><h2 id="1-为什么要学习单例？"><a href="#1-为什么要学习单例？" class="headerlink" title="1.为什么要学习单例？"></a>1.为什么要学习单例？</h2><p>单例模式应该是用得最多的设计模式之一，如果你的应用有个类很消耗资源 那么我们没有理由让他们不断创建</p><h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><p>确保一个类只有一个实例，而且自行实例化，并向系统提供这个实例。</p><h2 id="3-适合场景"><a href="#3-适合场景" class="headerlink" title="3.适合场景"></a>3.适合场景</h2><p>确保一个类只有一个对象的地方，避免产生多个对象消耗过多的资源，或者说创建一个对象需要耗费大量的资源 也需要用单例模式。</p><p><img src="/medias/paper/singleInstance.png" alt="单例类图"></p><h2 id="4-实现的关键点"><a href="#4-实现的关键点" class="headerlink" title="4.实现的关键点"></a>4.实现的关键点</h2><p>*构造方法不对外开发 一般是private</p><p>*通过一个静态方法或者枚举返回单例对象</p><p>*确保单例对象有且只有一个，尤其在多线程的环境下</p><h2 id="5-多种单例的写法和优缺点"><a href="#5-多种单例的写法和优缺点" class="headerlink" title="5.多种单例的写法和优缺点"></a>5.多种单例的写法和优缺点</h2><p>5.1 饿汉方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton1</span> mSingleton1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton1</span> <span class="token function">getSingleton1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mSingleton1<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：实现简单<br>缺点：饿汉在初始化声明的时候就已经初始化了这个对象，会造成内存的浪费，可能用户并不需要这个类，或者用不到</p><p>5.2 懒汉方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton2</span> mSingleton2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton2</span> <span class="token function">getSingleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mSingleton2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mSingleton2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mSingleton2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：在需要用的时候才初始化，减少资源浪费<br>缺点：缺点是在用的时候初始化会导致生成比较慢，在多线程的情况下会出现线程安全的问题，所以需要加锁，但是在加锁后又会有每次加锁的问题，进一步降低了性能。</p><p>5.3 DLC</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton3</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton3</span> mSingleton3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton3</span> <span class="token function">getSingleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mSingleton3 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton3</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mSingleton3 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    mSingleton3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mSingleton3<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：既能够在第一次用的时候初始化，又能够线程安全，而且能初始化后就不加锁了<br>缺点：比较复杂一点<br>注意 记得加上volatile 关键子，因为创建对象不是一个原子操作，可能会导致DCL失效，就是创建了但是没有初始化， volatile虽然会影响性能，但是跟准确性相比还是值得的</p><p>为什么会失效，就是new 一个对象的时候<br>1.先分配内存<br>2.初始化成员变量<br>3.将对象指向分配的空间<br>由于执行是乱序的，可能先执行了3 再执行2 这样在多线程的情况下会出现没有初始化的成员变量的情况出现</p><p>5.4 静态内部类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton4</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Singleton4Holder</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton4</span> mSingleton4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton4</span> <span class="token function">getSingleton4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">Singleton4Holder</span><span class="token punctuation">.</span>mSingleton4<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：既能保证线程安全，又能保证兼顾性能，推荐使<br>5.4.1 静态内部类加锁原理：<br>首先要了解类加载过程中的最后一个阶段：即类的初始化，类的初始化阶本质就是执行类构造器的方法。<br>方法：这不是由程序员写的程序，而是根据代码由javac编译器生成的。它是由类里面所有的类变量的赋值动作和静态代码块组成的。JVM内部会保证一个类的方法在多线程环境下被正确的加锁同步，也就是说如果多个线程同时去进行“类的初始化”，那么只有一个线程会去执行类的方法，其他的线程都要阻塞等待，直到这个线程执行完方法。然后执行完方法后，其他线程唤醒，但是不会再进入()方法。也就是说同一个加载器下，一个类型只会初始化一次。</p><p>那么回到这个代码中，这里的静态变量的赋值操作进行编译之后实际上就是一个代码，当我们执行getInstance方法的时候，会导致Singleton4Holder类的加载，类加载的最后会执行类的初始化，但是即使在多线程情况下，这个类的初始化的代码也只会被执行一次，所以他只会有一个实例</p><p>5.5 枚举单例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span>  <span class="token class-name">Singleton5</span> <span class="token punctuation">&#123;</span>    INSTANCE<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：既能保证线程安全，又能保证兼顾性能，推荐使用</p><p>为什么能保证线程的安全？<br>因为java在编译器变成class代码的时候枚举是一个静态变量类的加载过程中在初始化的时候会保证静态变量的线程安全加载。</p><p>6.单例模式的优缺点<br>优点<br>1因为内存中只有创建一个实例，能减少内存的开销。<br>2.因为只有一个对象能减少对资源的占用，避免死锁等事情的发生。</p><p>缺点：<br>1.单例模式容易引起内存泄露，因为他的生命周期比较长，注意传递最好传递Application Contenxt<br>2.单例模式没有接口，如果有逻辑修改或者扩展，那么只能改到代码，不符合高扩展性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式之单例模式&quot;&gt;&lt;a href=&quot;#设计模式之单例模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式之单例模式&quot;&gt;&lt;/a&gt;设计模式之单例模式&lt;/h1&gt;&lt;h2 id=&quot;1-为什么要学习单例？&quot;&gt;&lt;a href=&quot;#1-为什么要学习单例？&quot; c</summary>
      
    
    
    
    <category term="代码设计" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
