<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vinda</title>
  
  <subtitle>慢就是快,快就是慢</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-03T14:27:43.053Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Vinda</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebRTC之SDP</title>
    <link href="http://example.com/2023/04/01/Webrtc%E4%B9%8BSDP/"/>
    <id>http://example.com/2023/04/01/Webrtc%E4%B9%8BSDP/</id>
    <published>2023-03-31T16:00:00.000Z</published>
    <updated>2023-04-03T14:27:43.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SDP-Session-Description-Protocol"><a href="#SDP-Session-Description-Protocol" class="headerlink" title="SDP(Session Description Protocol)"></a>SDP(Session Description Protocol)</h1><p>它是一种信息描述标准，本身不属于传输协议，但是可以被其他传输协议用来交换必要条件<br>sdp 就是webrtc用来告诉对方 自己支持哪些编解码，跟对方进行协商的<br>webrtc两端其实是无法知道对方的存在的，还是需要经过服务器进行中转，来告诉对方，我支持什么协议，对方支持什么协议</p><h2 id="SDP规范"><a href="#SDP规范" class="headerlink" title="SDP规范"></a>SDP规范</h2><p>会话层<br>会话名称与目的<br>会话的存活时间<br>媒体层<br>1、媒体格式<br>2、传输协议<br>3、传输ip和端口<br>4、媒体负载类型</p><p>Seesion Description<br>v= protocol version<br>o= owner/create and session identifier<br>s =session name<br>c = conn info - optional if included at session - level<br>a= zero or more session attribute lines</p><p>Media Description<br>m= media name and transport address<br>c = conn info<br>b = bandwidth information<br>a= zero or more session attribute lines</p><h2 id="一些重要的字段"><a href="#一些重要的字段" class="headerlink" title="一些重要的字段"></a>一些重要的字段</h2><p>version 必选<br>v=0 SDP的版本号<br>session name 必选<br>s =  会话名字  s- 表示忽略会话名字</p><p>Origin/Owner 必选</p><pre class="line-numbers language-none"><code class="language-none">o &#x3D; &lt;username&gt;&lt;sesssion id&gt;&lt;version&gt; &lt;network type&gt; &lt;address type&gt;&lt;address&gt;0&#x3D; -87878978988789 2 IN IP4 127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Connection Data 可选</p><pre class="line-numbers language-none"><code class="language-none">c&#x3D;&lt;network type&gt; &lt;address type&gt; &lt;connection address&gt;c&#x3D;IN IP4 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Media Announcements 必选</p><pre class="line-numbers language-none"><code class="language-none">m&#x3D;&lt;media&gt;  &lt;fmt&#x2F;payload type list&gt;m&#x3D;audio 1024 UDP &#x2F;TLS&#x2F;RTP&#x2F;SAVPF 111 103 104 9 0 8 106 105 13 126<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Suggested Attributes 可选</p><pre class="line-numbers language-none"><code class="language-none">a&#x3D; &lt;TYPE&gt;或 a&#x3D;&lt;TYPE&gt; :&lt;VALUE&gt;a &#x3D;framerate:&lt;帧速率&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>rtpmap 可选</p><pre class="line-numbers language-none"><code class="language-none">a&#x3D;rtpmap: &lt;fmt&#x2F;payload type&gt; &#x2F; [&#x2F;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子：a=rtpmap:103 ISAC/16000</p><pre class="line-numbers language-none"><code class="language-none">a&#x3D;fmtp: &lt;format&#x2F;payload type&gt; parameter s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子：a=fmtp:103 apt=106</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;版本号V&#x3D;0起源  网络  协议  地址0&#x3D;T 4124882389307713477 2 IN IP4 127.0.0 .1名字S&#x3D;-时间t&#x3D;0 0以上就是会话层属性 视频  a&#x3D;group: BUNDLE 0 媒体流id               a&#x3D;msid-semantic: WMS D0Qg6FLGrndzIV29USeoRLpmTS7L63AvyCp媒体信息  video 只有视频 m&#x3D;video 9 UDP&#x2F;TLS&#x2F;RTP&#x2F;SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109  124 120 123 119 114连接数据  C&#x3D;IN IP4 0.0.0.0rtcp 描述a&#x3D;rtcp:9 IN IP4 0.0.0.0安全性的描述a&#x3D;ice-ufrag:CTgt a&#x3D;ice-pwd:mGdhFvyq+YOc&#x2F;7AVe+3ySYek a&#x3D;ice-options:tricklea&#x3D;fingerprint: sha-256 68:79:32:0A:D6:85:81:AF:63:A7:AA:88:2B:3B:DE:71:18:9B:12:5F:4B:60:1B:19:1D:55:09:0E:79:31:38:ED既可以服务也可以客户端 a&#x3D;setup:actpass a&#x3D;mid: 0 a&#x3D;extmap:2 urn:ietf:params:rtp-hdrext:toffset a&#x3D;extmap:3 http:&#x2F;&#x2F;www.webrtc.org&#x2F;experiments&#x2F;rtp-hdrext&#x2F;abs-send-timea&#x3D;extmap:4 urn:3gpp:video-orientation a&#x3D;extmap: 5 http:&#x2F;&#x2F;www.ietf.org&#x2F;id&#x2F;draft-holmer-rmcat-transport-wide-cc-extensions-01 a&#x3D;extmap:6 http:&#x2F;&#x2F;www.webrtc.org&#x2F;experiments&#x2F;rtp-hdrext&#x2F;playout-delaya&#x3D;extmap:7 http:&#x2F;&#x2F;www.webrtc.org&#x2F;experiments&#x2F;rtp-hdrext&#x2F;video-content-typea&#x3D;extmap:8 http:&#x2F;&#x2F;www.webrtc.org&#x2F;experiments&#x2F;rtp-hdrext&#x2F;video-timinga&#x3D;extmap:10 http:&#x2F;&#x2F;tools.ietf.org&#x2F;html&#x2F;draft-ietf-avtext-framemarking-07a&#x3D;extmap:9 urn:ietf:params: rtp-hdrext: sdes:mid a&#x3D;sendrecva&#x3D;msid: D0Qg6FLGrndzIV29USeoRLmTS7L63AvyCp 5b3eb697-b4de-4846-8bc8-304e11971475多路复用a&#x3D;rtcp-mux 丢包相关a&#x3D;rtcp-rsizea&#x3D;rtpmap: 96 VP8&#x2F;90000 a&#x3D;rtcp-fb:96 goog-remb a&#x3D;rtcp-fb:96transport-cc a&#x3D;rtcp-fb:96 ccm fir a&#x3D;rtcp-fb:96 nacka&#x3D;rtcp-fb:96 nack plia&#x3D;rtpmap:97 rtx&#x2F;900 00a&#x3D;fmtp:97 apt&#x3D;96a&#x3D;rtpmap:98 VP9&#x2F;90000 a&#x3D;rtcp-fb:98 goog-remb a&#x3D;rtcp-fb:98 transport-cc a&#x3D;rtcp-fb:98 cm fir a&#x3D;rtcp-fb:98 nacka&#x3D;rtcp-fb:98 nack plia&#x3D;fmtp:98 profile-id&#x3D;0a&#x3D;rtpmap:99 rtx&#x2F;90000a&#x3D;fmtp:99 apt&#x3D;98a&#x3D;rtpmap: 100 H264&#x2F;90000 a&#x3D;rtcp-fb:100 goog-remb a&#x3D;rtcp-fb:100 transport-cc a&#x3D;rtcp-fb:100 cm fir a&#x3D;rtcp-fb:100 nack a&#x3D;rtcp-fb: 100 nack pli Ia&#x3D;fmtp: 100 level-asymmetry-allowed&#x3D;1;packetization-mode&#x3D;1;profile-level-id&#x3D;4200 1f a&#x3D;rtpmap:101 rtx&#x2F;90000a&#x3D;fmtp:101 apt&#x3D;100a&#x3D;rtpmap: 102 H264&#x2F;90000 a&#x3D;rtcp-fb:102 goog-remb a&#x3D;rtcp-fb:102 transport-cc a&#x3D;rtcp-fb:102 c cm fira&#x3D;rtcp-fb :102 nack<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般web 喜欢用socket io来实现 sdp的中转，socket io理论上就像一个聊天室一样，主要是中转信息一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SDP-Session-Description-Protocol&quot;&gt;&lt;a href=&quot;#SDP-Session-Description-Protocol&quot; class=&quot;headerlink&quot; title=&quot;SDP(Session Description Prot</summary>
      
    
    
    
    <category term="webrtc" scheme="http://example.com/categories/webrtc/"/>
    
    
    <category term="webrtc" scheme="http://example.com/tags/webrtc/"/>
    
  </entry>
  
  <entry>
    <title>启动优化</title>
    <link href="http://example.com/2022/01/30/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/01/30/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-07-24T06:07:53.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要做启动优化"><a href="#为什么要做启动优化" class="headerlink" title="为什么要做启动优化"></a>为什么要做启动优化</h1><h2 id="1、第一体验很重要"><a href="#1、第一体验很重要" class="headerlink" title="1、第一体验很重要"></a>1、第一体验很重要</h2><h2 id="2、八秒定律：如果打开需要8秒钟那么用户就会放弃"><a href="#2、八秒定律：如果打开需要8秒钟那么用户就会放弃" class="headerlink" title="2、八秒定律：如果打开需要8秒钟那么用户就会放弃"></a>2、八秒定律：如果打开需要8秒钟那么用户就会放弃</h2><h1 id="冷启动是衡量的标准"><a href="#冷启动是衡量的标准" class="headerlink" title="冷启动是衡量的标准"></a>冷启动是衡量的标准</h1><p>冷启动流程<br>click-&gt;ipc-process.start-&gt;ActivityThread-&gt;bindApplication-&gt;LifeCycle-&gt;ViewRootImpl</p><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><p>Application和Activity 生命周期方法是优化的方向 其他的地方其实无法干预</p><h2 id="adb命令获取启动时间"><a href="#adb命令获取启动时间" class="headerlink" title="adb命令获取启动时间"></a>adb命令获取启动时间</h2><p>adb shell am start -W packagename/首屏Activity</p><pre class="line-numbers language-none"><code class="language-none">adb shell am start -W com.example.better&#x2F;.MainActivityStarting: Intent &#123; act&#x3D;android.intent.action.MAIN cat&#x3D;[android.intent.category.LAUNCHER] cmp&#x3D;com.example.better&#x2F;.MainActivity &#125;Status: okActivity: com.example.better&#x2F;.MainActivityThisTime: 364TotalTime: 364WaitTime: 374Complete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WaitTime 表示AMS启动Activity的总耗时</p><p>TotalTime 表示所有Activity启动耗时</p><p>ThisTime 表示最后一个Activity启动耗时</p><h2 id="手动打点"><a href="#手动打点" class="headerlink" title="手动打点"></a>手动打点</h2><p>就是从开始时间到ui展示出来的时比如你从application 开始到View画出来时间</p><p>比如创建一个类来负责记录时间</p><pre class="line-numbers language-none"><code class="language-none">class LauncherTimer &#123;    private static long sTime;    public static void startRecord() &#123;        sTime &#x3D; System.currentTimeMillis();    &#125;    public static void endRecord() &#123;        long cost &#x3D; System.currentTimeMillis() - sTime;        Log.i(&quot;cost&quot;, &quot;endRecord: &quot; + cost);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，应该是View绘制出来作为结束时间,比如可以监听某个View绘制的时候作为结束时间</p><pre class="line-numbers language-none"><code class="language-none">findViewById(R.id.text).getViewTreeObserver().addOnPreDrawListener(() -&gt; &#123;           LauncherTimer.endRecord();           return true;       &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><h3 id="1、Traceview"><a href="#1、Traceview" class="headerlink" title="1、Traceview"></a>1、Traceview</h3><p>使用方式</p><pre class="line-numbers language-none"><code class="language-none">Debug.startMethodTracing(&quot;app&quot;);Debug.stopMethodTracing();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它会在应用的目录上生成一个xx.trace 文件 通过Studio打开后可以发现大概长这样</p><p><img src="/images/brace.png" alt="trace"></p><p>上面滑动部分是你需要选中的时间范围</p><p>中间部分会列出所有线程,还有每个做了什么事情，也就是方法调用栈<br>点击方法可以知道每个方法的耗时<br>total就是这个方法的耗时，<br>children 就是子方法的耗时<br>self 就是自己花费了多长时间<br>知道了这些就可以进行性能优化</p><p>多关注TopDown就可以知道哪些方法耗时了</p><p>这个工具比价适合去做开机启动优化，因为开始和结束已经埋在代码里面了。</p><h3 id="2、systemtrace"><a href="#2、systemtrace" class="headerlink" title="2、systemtrace"></a>2、systemtrace</h3><p>这个应用更适合去做一下某些操作的卡顿</p><p>使用方式</p><pre class="line-numbers language-none"><code class="language-none">TraceCompat.beginSection(&quot;better&quot;);TraceCompat.endSection();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行后执行</p><pre class="line-numbers language-none"><code class="language-none">python &#x2F;Users&#x2F;weihuada&#x2F;Downloads&#x2F;platform-tools&#x2F;systrace&#x2F;systrace.py -b 32768 -t 5 -a com.example.better -o performance.html sched gfx view wm am app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个方法是 platform-tools里面自带的方法 </p><p>这个方法在后续被google移除掉了<br><a href="https://www.jianshu.com/p/626eaebaa6a8">https://www.jianshu.com/p/626eaebaa6a8</a></p><p>执行后会输出 performance.html 到当前目录</p><p>然后通过浏览器 输入<br>chrome://tracing/<br>然后打开这个文件就可以了</p><h2 id="启动优化的核心思想是异步优化，让子线程分担主线程任务，并行减少同步事件"><a href="#启动优化的核心思想是异步优化，让子线程分担主线程任务，并行减少同步事件" class="headerlink" title="启动优化的核心思想是异步优化，让子线程分担主线程任务，并行减少同步事件"></a>启动优化的核心思想是异步优化，让子线程分担主线程任务，并行减少同步事件</h2><p>但是要注意代码的执行先后顺序<br>有些代码是不能运行在异步线程的</p><p>我们可以用CountDownLatch 这个类去处理代码的先后执行顺序的问题<br>我们可以比如开四条线程，最后100秒的主线程被分隔到4条线程中<br>每条线程最后就是25秒 用这个CountDownLatch 就是能先阻塞住<br>等到四条线程都处理完了再进行下面的操作 但是它不能解决不同线程之间的同步问题<br>为了解决线程之间的同步问题 我们可以引入线程执行器这里就不展示具体代码。 </p><h2 id="将不重要的操作放到ui展示出来之后再初始化。"><a href="#将不重要的操作放到ui展示出来之后再初始化。" class="headerlink" title="将不重要的操作放到ui展示出来之后再初始化。"></a>将不重要的操作放到ui展示出来之后再初始化。</h2><h2 id="优化总方针"><a href="#优化总方针" class="headerlink" title="优化总方针"></a>优化总方针</h2><p>异步、延迟、懒加载</p><h2 id="其他黑科技"><a href="#其他黑科技" class="headerlink" title="其他黑科技"></a>其他黑科技</h2><p>启动时抑制GC</p><p>CPU锁频</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要做启动优化&quot;&gt;&lt;a href=&quot;#为什么要做启动优化&quot; class=&quot;headerlink&quot; title=&quot;为什么要做启动优化&quot;&gt;&lt;/a&gt;为什么要做启动优化&lt;/h1&gt;&lt;h2 id=&quot;1、第一体验很重要&quot;&gt;&lt;a href=&quot;#1、第一体验很重要&quot; class</summary>
      
    
    
    
    <category term="性能优化" scheme="http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android开发" scheme="http://example.com/tags/Android%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>PlantUML</title>
    <link href="http://example.com/2022/01/02/PlantUML/"/>
    <id>http://example.com/2022/01/02/PlantUML/</id>
    <published>2022-01-01T16:00:00.000Z</published>
    <updated>2022-03-15T15:12:18.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PlantUML是一个开源项目，支持快速绘制多种图形，可以用写代码的模式来“画”UML图</p><p>优势<br>1.可以用代码方式存储你的图表，这样可以用git方式去管控修改UML图。<br>2.用代码表达程序，自动画出对应UML图，更加更加高效。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>1.Java环境<br>2.graphviz-dot （brew install graphviz）</p><p>二、工具(列举两个)</p><p>1.VSCode  PlantUML + PlantUML Previewer+Markdowm Preview Enhanced  (免费)</p><p>2.Mweb(收费)</p><p>三、懒得不想配置环境<br>直接在服务器上生成(<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a>)</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">abstract        抽象class           类entity          实例enum            枚举interface       接口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_class_1.png" alt="类图"></p><p>箭头使用方式</p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">Class01 ..&gt; Class02  :依赖Class03 --&gt; Class04  :关联Class05 &lt;|-- Class06 :继承Class07 ..|&gt; Class08 :实现Class09 --o Class10  :聚合Class11 --* Class12  :组合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_class_2.png" alt="类图"></p><p>可以在类图上加上一些方法和变量修饰</p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">class Dummy &#123;  String data  void methods()&#125;class Flight &#123;   flightNumber : Integer   departureTime : Date   void methods()&#125;interface callback&#123;    void callback()&#125;enum Source&#123;    Android,HDMI1,HDMI2&#125;abstract BaseActivity&#123;       flag :Bool&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_class_3.png"></p><p>整体使用</p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">class McuServiceApplication &#123;    - mMcuStub: IMcuDataHelper.Stub    + onCreate():void&#125;class McuHandler &#123;    + postMcuCommand(command McuCommonBase,callback IMcuDataCallback):void    + addMCuDataNotifyListener(packageName String ,callback IMcuNotifyCallback):void    + removeMcuNotifyDataListener(packageName String) void    + sendMcuDataResponseSync(command McuCommonBase) :McuCommonResponse&#125;class McuSendDataControl &#123;    - mDisposable : CompositeDisposable    - mSendSubject: Subject&lt;McuCommonBase&gt;    + starServer():void    + stopServer():void    + performSendCommandToMCU():void&#125;class McuComebackDataDispatcher &#123;    - mObservers : ArrayList&lt;IObserverWrapper&gt;    - appCallbackNotifyMap :  HashMap&lt;String, IMcuNotifyCallback&gt;    + addMCuDataNotifyListener(packageName  String, callback IMcuNotifyCallback):void    + removeMcuNotifyDataListener(key String):void    + removeSendDataListener(mcuSyncObserverWrapper IObserverWrapper):void    + dispatchMcuData(response McuCommonResponse):void&#125;class McuApiManager &#123;    - mMcuApiCallback: McuCallback   + setMcuCallBack(callback McuCallback): void   + send(type CommandType,mainId byte, subId byte,buffer byte[]): void   + startServer(): void   + native_init(): int   + native_release(): int   + native_send(cmdType byte,mainId byte,subId byte,buffer byte[]): int&#125;McuServiceApplication--&gt;McuHandlerMcuHandler --&gt;  McuSendDataControlMcuHandler --&gt; McuComebackDataDispatcherMcuSendDataControl--&gt;McuApiManagerMcuComebackDataDispatcher --&gt;McuApiManager<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_class_4.png"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">actor Requestnote over Request :角色activate McuServiceApplicationnote over McuServiceApplication :方框为事件和生命线控制焦点activate McuHandleractivate McuCommbackDataDispatcheractivate McuSendDataControlactivate McuApiManagerRequest -&gt; McuServiceApplication: 创建连接McuServiceApplication --&gt; Request:返回bindergroup 处理请求 Request -&gt; McuServiceApplication :发送mcu请求McuServiceApplication -&gt; McuHandler :对请求进行处理McuHandler -&gt; McuCommbackDataDispatcher : 将请求加入回调队列之中McuHandler -&gt; McuSendDataControl : 发送mcu请求到请求队列中McuSendDataControl -&gt;McuApiManager  :队列拿出数据发送底层McuApiManager --&gt; McuCommbackDataDispatcher :Mcu回复的数据McuCommbackDataDispatcher --&gt; McuHandler :回复数据McuHandler --&gt; Request :用户拿到数据endgroup 注册请求 [当应用注册了事件监听]Request -&gt; McuServiceApplication :发起事件的注册监听McuServiceApplication -&gt; McuHandler : 对监听请求进行处理McuHandler -&gt; McuCommbackDataDispatcher :加入事件监听队列McuApiManager --&gt; McuCommbackDataDispatcher: mcu回复数据McuCommbackDataDispatcher --&gt; Request : 回调用户的callbackend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_time_1.png"></p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">activate 市民activate 终端服务系统市民-&gt;终端服务系统 :办理老年卡终端服务系统--&gt;市民alt 65&gt;age&gt;60 市民 -&gt; 终端服务系统: 刷胜身份证办理终端服务系统-&gt;市民:返回办理蓝卡成功else age&gt;65 市民 -&gt; 终端服务系统: 刷胜身份证办理  终端服务系统-&gt;市民:返回办理蓝卡成功else age&lt;60   市民 -&gt; 终端服务系统: 刷胜身份证办理  终端服务系统-&gt;市民:返回报错界面end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时序图加上组合的使用</p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">activate 市民activate 终端服务系统市民-&gt;终端服务系统 :办理老年卡终端服务系统--&gt;市民alt 65&gt;age&gt;60 市民 -&gt; 终端服务系统: 刷胜身份证办理终端服务系统-&gt;市民:返回办理蓝卡成功else age&gt;65 市民 -&gt; 终端服务系统: 刷胜身份证办理  终端服务系统-&gt;市民:返回办理蓝卡成功else age&lt;60   市民 -&gt; 终端服务系统: 刷胜身份证办理  终端服务系统-&gt;市民:返回报错界面end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_time_2.png"></p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">activate 市民activate 终端服务系统市民-&gt;终端服务系统 :办理老年卡终端服务系统--&gt;市民opt 没有注册老人卡 市民 -&gt; 终端服务系统: 注册老人卡终端服务系统-&gt;市民:返回办理老人卡成功end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_time_3.png"></p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">activate 市民activate 终端服务系统市民-&gt;终端服务系统 :选择购买的饮料终端服务系统--&gt;市民: 返回应该投币的金额 moneyloop 投入的钱数&lt;应该投币的数量 市民 -&gt; 终端服务系统: 继续投入硬币币终端服务系统-&gt;市民:返回投币的金额end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_time_4.png"></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">start:ClickServlet.handleRequest();:new page;if (Page.onSecurityCheck) then (true)  :Page.onInit();  if (isForward?) then (no)    :Process controls;    if (continue processing?) then (no)      stop    endif    if (isPost?) then (yes)      :Page.onPost();    else (no)      :Page.onGet();    endif    :Page.onRender();  endifendifstop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.start 代表黑点开始节点<br>2.stop 代表结束节点<br>3.动作以 ‘:’开始 以’;’结束<br>4.决策用if()then else{}</p><p><img src="/images/plantuml/plantuml_active_1.png"></p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">@startuml|老师|start:出题;|#AntiqueWhite|学生|:答题;:交卷;|老师|:批改;:发布成绩;|学生|:拿到成绩;stop@enduml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_active_2.png"></p><pre class="line-numbers language-plantuml" data-language="plantuml"><code class="language-plantuml">@startumlstartrepeat :foo作为开始标注;  :读取数据;  :生成图片;backward:这是一个行为;repeat while (更多数据?)stop@enduml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/plantuml/plantuml_active_3.png"></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>PlantUml官网:<a href="https://plantuml.com/zh/">https://plantuml.com/zh/</a></p><h2 id="用在哪里合适使用"><a href="#用在哪里合适使用" class="headerlink" title="用在哪里合适使用"></a>用在哪里合适使用</h2><h3 id="1-项目的ReadMe"><a href="#1-项目的ReadMe" class="headerlink" title="1.项目的ReadMe"></a>1.项目的ReadMe</h3><p>-让接手的人能更快<br>-让自己能更了解自己的项目结构</p><h3 id="2-KB文档中推荐使用"><a href="#2-KB文档中推荐使用" class="headerlink" title="2.KB文档中推荐使用"></a>2.KB文档中推荐使用</h3><p>-编辑时候在’插入其他宏’中 找到 PlantUML Macro，将代码粘贴进去就会自动生成速度更快，排版也比较好看</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;PlantUML是一个开源项目，支持快速绘制多种图形，可以用写代码的模式来“画”UML图&lt;/p&gt;
&lt;p&gt;优势&lt;br&gt;1.可以用代码方式存储你</summary>
      
    
    
    
    <category term="日常积累" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="日常积累" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>常用算法规整</title>
    <link href="http://example.com/2021/10/04/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/10/04/%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-03T16:00:00.000Z</published>
    <updated>2022-02-04T05:37:06.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的算法总结"><a href="#常用的算法总结" class="headerlink" title="常用的算法总结"></a>常用的算法总结</h1><h2 id="数组-模块"><a href="#数组-模块" class="headerlink" title="数组 模块"></a>数组 模块</h2><p>两数之和</p><p>1 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]</p><p>示例 2：</p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p><p>示例 3：</p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;            HashMap map&#x3D; new HashMap&lt;Integer,Integer&gt;();            int[] arr&#x3D;new int[2];            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                map.put(nums[i],i);            &#125;            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                int targetNum&#x3D; target-nums[i];                if(map.get(targetNum)!&#x3D;null&amp;&amp;(int)map.get(targetNum)!&#x3D;0)&#123;                    if(i!&#x3D;(int)map.get(targetNum))&#123;                    arr[0]&#x3D;i;                    arr[1]&#x3D;(int)map.get(targetNum);                    break;                    &#125;                &#125;]            &#125;        return arr;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>盛最多水的容器<br>2 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>示例 1</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例 2：</p><p>输入：height = [1,1]<br>输出：1</p><p>示例 3：</p><p>输入：height = [4,3,2,1,4]<br>输出：16</p><p>示例 4：<br>输入：height = [1,2,1]<br>输出：2</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxArea(int[] height) &#123;        int start&#x3D;0;        int end&#x3D;height.length-1;        int maxArea&#x3D;0;        while(start&lt;end)&#123;            if(height[start]&lt;height[end])&#123;              int max&#x3D;  (end-start)*height[start];                if(maxArea&lt;max)&#123;                    maxArea&#x3D;max;                &#125;                start++;            &#125;else&#123;                int max&#x3D;  (end-start)*height[end];                if(maxArea&lt;max)&#123;                    maxArea&#x3D;max;                &#125;                 end--;            &#125;        &#125;        return maxArea;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三数之和</p><p>3 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组</p><p>示例 1：</p><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p><p>示例 2：</p><p>输入：nums = []<br>输出：[]</p><p>示例 3：</p><p>输入：nums = [0]<br>输出：[]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;           ArrayList&lt;List&lt;Integer&gt;&gt; integers &#x3D; new ArrayList&lt;&gt;();        if (nums &#x3D;&#x3D; null || nums.length &lt; 3) &#123;            return integers;        &#125;        Arrays.sort(nums);        for (int i &#x3D; 0; i &lt; nums.length - 2; i++) &#123;            if (nums[i] &gt; 0) &#123;                break;            &#125;            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; &#x2F;&#x2F;去掉重复的情况 因为前面排序了 隔壁一样就是一样重复的            int target &#x3D; -nums[i];            int left &#x3D; i + 1, right &#x3D; nums.length - 1;            while (left &lt; right) &#123;                if (nums[left] + nums[right] &#x3D;&#x3D; target) &#123;                    integers.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[left], nums[right])));                    left++;                    right--;                    while (left&lt;right&amp;&amp;nums[left]&#x3D;&#x3D;nums[left-1])&#123;                        left++;                    &#125;                    while (left&lt;right&amp;&amp;nums[right]&#x3D;&#x3D;nums[right+1])&#123;                        right--;                    &#125;                &#125; else if (nums[left] + nums[right] &lt; target) &#123;                    left++;                &#125; else &#123;                    right--;                &#125;            &#125;        &#125;        return integers;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 组合总和<br>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：</p><p>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。</p><p>示例 2：</p><p>输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><p>示例 3：</p><p>输入: candidates = [2], target = 1<br>输出: []</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;        List&lt;List&lt;Integer&gt;&gt; res;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;         res&#x3D;new ArrayList&lt;&gt;();         Arrays.sort(candidates);       ArrayList&lt;Integer&gt; path &#x3D;new ArrayList();        backTrace(candidates,target,path,0); &#x2F;&#x2F;采用回溯递归的方式         return res;    &#125;    private void backTrace(int[] candidates,int target,ArrayList&lt;Integer&gt; path, int start )&#123;            if(target&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果等于0 那么这个组合就是满足条件的 可以加入                res.add(new ArrayList(path));                return;             &#125;            for(int i&#x3D;start;i&lt;candidates.length;i++)&#123;&#x2F;&#x2F;对根树来说的                    if(candidates[i]&gt;target)&#123; &#x2F;&#x2F;如果当前都大于目标 那么就说明没有这个组合了因为 target会累加                        return;                    &#125;                    path.add(candidates[i]);&#x2F;&#x2F;将这个路径放进去                    backTrace(candidates,target-candidates[i],path,i);&#x2F;&#x2F;判断这个路径相减  然后要注意i是起始的意思  有这个start的话可以做到不考虑前面的数组,注意 因为是递归也就是从树的根部开始算起的，根节点触发的才不能用前面的树 也就是说第一轮for遍历是对根数组来说的，剩下的是底部数组                                    path.remove(path.size()-1);&#x2F;&#x2F;删除的是顶部的那个，这样才会回溯的效果 类似于最底部的删除重新尝试            &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>螺旋矩阵</p><p>4 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        int  left&#x3D;0;        int  right&#x3D;matrix[0].length-1;        int top&#x3D;0;        int bottom&#x3D;matrix.length-1;        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();        while(right&gt;left&amp;&amp;bottom&gt;top)&#123;         for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;                list.add(matrix[top][i]);        &#125;          top++;          for(int i&#x3D;top;i&lt;&#x3D;bottom;i++)&#123;            list.add(matrix[i][right]);        &#125;        right--;        for(int i&#x3D;right;i&gt;&#x3D;left;i--)&#123;            list.add(matrix[bottom][i]);        &#125;            bottom--;        for(int i&#x3D;bottom;i&gt;&#x3D;top;i--)&#123;            list.add(matrix[i][left]);        &#125;        left++;        &#125;        if(left&lt;right&amp;&amp;top&#x3D;&#x3D;bottom)&#123;            for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;                list.add(matrix[top][i]);            &#125;        &#125;        if(top&lt;bottom&amp;&amp;left&#x3D;&#x3D;right)&#123;            for(int i&#x3D;top;i&lt;&#x3D;bottom;i++)&#123;                list.add(matrix[i][left]);            &#125;        &#125;        if(left&#x3D;&#x3D;right&amp;&amp;top&#x3D;&#x3D;bottom)&#123;            list.add(matrix[top][left]);        &#125;        return list;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并区间</p><p>5 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p>示例 1：</p><p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><p>示例 2：</p><p>输入：intervals = [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[][] merge(int[][] intervals) &#123;            Arrays.sort(intervals,new Comparator&lt;int[]&gt;()&#123;                public int compare(int[] interval1,int[] interval2)&#123;                    return interval1[0]-interval2[0];                &#125;            &#125;);            ArrayList&lt;int[]&gt; list&#x3D;new ArrayList&lt;int[]&gt;();            for(int i&#x3D;0;i&lt;intervals.length;i++)&#123;                int L&#x3D;intervals[i][0];                int R&#x3D;intervals[i][1];                if(list.size()&#x3D;&#x3D;0||list.get(list.size()-1)[1]&lt;L)&#123;                    list.add(new int[]&#123;L,R&#125;);                &#125;else&#123;                                     list.get(list.size()-1)[1]&#x3D;Math.max(list.get(list.size()-1)[1],R);                   &#125;            &#125;            return list.toArray(new int[list.size()][]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最小路径和</p><p>6 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p><p>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int minPathSum(int[][] grid) &#123;        int m&#x3D;grid.length;        int n&#x3D;grid[0].length;        int[][] arr&#x3D;new int[m][n];        arr[0][0]&#x3D;grid[0][0];        for(int i&#x3D;1;i&lt;n;i++)&#123;            arr[0][i]&#x3D;arr[0][i-1]+grid[0][i];        &#125;        for(int i&#x3D;1;i&lt;m;i++)&#123;            arr[i][0]&#x3D;arr[i-1][0]+grid[i][0];        &#125;        for(int i&#x3D;1;i&lt;m;i++)&#123;            for(int j&#x3D;1;j&lt;n;j++)&#123;                arr[i][j]&#x3D;Math.min(arr[i-1][j],arr[i][j-1])+grid[i][j];            &#125;        &#125;        return arr[m-1][n-1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 子集</p><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p><p>示例 2：</p><p>输入：nums = [0]<br>输出：[[],[0]]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;       List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();        res.add(new ArrayList());        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;            int all &#x3D;res.size();             System.out.print(all);            for(int j&#x3D;0;j&lt;all;j++)&#123;                    List&lt;Integer&gt; tmp&#x3D;new ArrayList&lt;&gt;(res.get(j));                        tmp.add(nums[i]);                        res.add(tmp);            &#125;        &#125;        return res;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并两个有序数组</p><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>示例 1：</p><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p><p>示例 2：<br>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。</p><p>示例 3：</p><p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;            if(n&#x3D;&#x3D;0)&#123;                return;            &#125;           if(m&#x3D;&#x3D;0)&#123;                for(int i&#x3D;0;i&lt;n;i++)&#123;                    nums1[i]&#x3D;nums2[i];                &#125;            &#125;            for(int i&#x3D;m;i&lt;m+n;i++)&#123;                nums1[i]&#x3D;nums2[i-m];            &#125;                                Arrays.sort(nums1);        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将有序数组转换为二叉搜索树</p><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p>输入：nums = [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p><p>输入：nums = [1,3]<br>输出：[3,1]<br>解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public TreeNode sortedArrayToBST(int[] nums) &#123;            if(nums&#x3D;&#x3D;null)&#123;                return null;            &#125;          return  getMidTree(nums,0,nums.length-1);    &#125;    public TreeNode getMidTree(int[] nums,int left,int right)&#123;        if(left&gt;right)&#123;            return null;        &#125;        int mid&#x3D;left+(right-left)&#x2F;2;        System.out.print(&quot;mid:&quot;+nums[mid]);       TreeNode tree&#x3D; new TreeNode(nums[mid]);       tree.left&#x3D;getMidTree(nums,left,mid-1);       tree.right&#x3D;getMidTree(nums,mid+1,right);        return tree;    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>买卖股票的最佳时机</p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>示例 2：</p><p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxProfit(int[] prices) &#123;            int maxValue&#x3D;0;            int min&#x3D;Integer.MAX_VALUE;            for(int i&#x3D;0;i&lt;prices.length;i++)&#123;                min&#x3D;Math.min(min,prices[i]);                int tempValue&#x3D; prices[i]-min;                maxValue&#x3D;Math.max(maxValue,tempValue);                            &#125;            return maxValue;                &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>买卖股票的最佳时机 II</p><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p><p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。<br>返回 你能获得的 最大 利润 。</p><p>示例 1:</p><p>输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 </p><p>示例 2:</p><p>输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:</p><p>输入: prices = [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxProfit(int[] prices) &#123;        int maxValue&#x3D;0;        for(int i&#x3D;prices.length-1;i&gt;0;i--)&#123;            if(prices[i]&gt;prices[i-1])&#123;                maxValue+&#x3D;prices[i]-prices[i-1];            &#125;        &#125;        return maxValue;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长连续序列</p><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>示例 1：<br>输入：nums = [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><p>示例 2：</p><p>输入：nums = [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int longestConsecutive(int[] nums) &#123;            if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;                return 0;            &#125;            Arrays.sort(nums);            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                System.out.print(nums[i]);            &#125;                    int maxLength&#x3D;1;            int finalMax&#x3D;1;            for(int i&#x3D;0;i&lt;nums.length-1;i++)&#123;                if(nums[i+1] - nums[i]&#x3D;&#x3D;1)&#123;                    maxLength++;                &#125;else if(nums[i+1]-nums[i]&#x3D;&#x3D;0)&#123;                    continue;                &#125;else&#123;                    finalMax&#x3D; Math.max(maxLength,finalMax);                    maxLength&#x3D;1;                &#125;            &#125;            finalMax&#x3D; Math.max(maxLength,finalMax);            return finalMax;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只出现一次的数字</p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int singleNumber(int[] nums) &#123;        HashMap map&#x3D;new HashMap&lt;Integer,Integer&gt;();        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                if(map.get(nums[i])!&#x3D;null)&#123;                    map.put(nums[i],(int)map.get(nums[i])+1);                &#125;else&#123;                    map.put(nums[i],1);                &#125;        &#125;       Set&lt;Integer&gt; sets&#x3D; map.keySet();        for(Integer key: sets)&#123;            if((int)map.get(key)&#x3D;&#x3D;1)&#123;                return key;            &#125;        &#125;            return -1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只出现一次的数字 II</p><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><p> </p><p>示例 1：</p><p>输入：nums = [2,2,3,2]<br>输出：3<br>示例 2：</p><p>输入：nums = [0,1,0,1,0,1,99]<br>输出：99 </p><p>提示：</p><p>1 &lt;= nums.length &lt;= 3 * 104<br>-231 &lt;= nums[i] &lt;= 231 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int singleNumber(int[] nums) &#123;        &#x2F;&#x2F;搞一个集合来存储        HashMap map&#x3D;new HashMap&lt;Integer,Integer&gt;();        &#x2F;&#x2F;遍历将数据存进去 map        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;            if(map.get(nums[i])&#x3D;&#x3D;null)&#123;                map.put(nums[i],1);            &#125;else&#123;                map.put(nums[i],(int)map.get(nums[i])+1);            &#125;        &#125;&#x2F;&#x2F;      遍历map 如果存在一个值为1的话 那么就返回        Set&lt;Integer&gt; sets&#x3D;map.keySet();        for(Integer key:sets)&#123;            if((int)map.get(key)&#x3D;&#x3D;1)&#123;                return key;            &#125;        &#125;        return 0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>乘积最大子数组</p><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p> </p><p>示例 1:</p><p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p><p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxProduct(int[] nums) &#123;        if(nums&#x3D;&#x3D;null)&#123;            return 0;        &#125;        if(nums.length&#x3D;&#x3D;0)&#123;            return nums[0];        &#125;        int max&#x3D;Integer.MIN_VALUE;        int  imax&#x3D;1;        int  imin&#x3D;1;            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;            if(nums[i]&lt;0)&#123;                int tmp&#x3D;imax;                imax&#x3D;imin;                imin&#x3D;tmp;            &#125;            imax&#x3D;Math.max(imax*nums[i],nums[i]);            imin&#x3D;Math.min(imin*nums[i],nums[i]);            max&#x3D;Math.max(max,imax);        &#125;        return max;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] = nums[n] = -∞ 。</p><p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p><p> </p><p>示例 1：</p><p>输入：nums = [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br>示例 2：</p><p>输入：nums = [1,2,1,3,5,6,4]<br>输出：1 或 5<br>解释：你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int findPeakElement(int[] nums) &#123;        if(nums.length&#x3D;&#x3D;1||nums.length&#x3D;&#x3D;0)&#123;            return 0;        &#125;        if(nums.length&#x3D;&#x3D;2)&#123;            if(nums[0]&gt;nums[1])&#123;                return 0;            &#125;else&#123;                return  1;            &#125;        &#125;                        for(int i&#x3D;1;i&lt;nums.length-1;i++)&#123;                if(nums[i]&gt;nums[i-1]&amp;&amp;nums[i]&gt;nums[i+1])&#123;                    return i;                &#125;            &#125;             if(nums[nums.length-1]&gt;nums[nums.length-2])&#123;                    return nums.length-1;                &#125;        return 0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>轮转数组</p><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><p> </p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>输入：nums = [-1,-100,3,99], k = 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public void rotate(int[] nums, int k) &#123;                    &#x2F;&#x2F;求余数为了避免k大于nums            k&#x3D;k%nums.length;            &#x2F;&#x2F;这个是为了放在前面           ArrayList&lt;Integer&gt; firstList&#x3D; new ArrayList&lt;Integer&gt;();               &#x2F;&#x2F;这个是为了放在后面           ArrayList&lt;Integer&gt; secondList&#x3D; new ArrayList&lt;Integer&gt;();                &#x2F;&#x2F;这个把后面的切割下来            for(int i&#x3D;nums.length-1;i&gt;&#x3D;nums.length-k;i--)&#123;                firstList.add(nums[i]);            &#125;            &#x2F;&#x2F; 这个添加到后面            for(int i&#x3D;0;i&lt;nums.length-k;i++)&#123;                secondList.add(nums[i]);            &#125;                        for(int i&#x3D;0;i&lt;firstList.size();i++)&#123;                nums[i]&#x3D;firstList.get(firstList.size()-i-1);            &#125;            for(int i&#x3D;0;i&lt;secondList.size();i++)&#123;                nums[i+firstList.size()]&#x3D;secondList.get(i);            &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>岛屿数量</p><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p> </p><p>示例 1：</p><p>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p><p>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3 </p><p>提示：</p><p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    int  count&#x3D;0;    public int numIslands(char[][] grid) &#123;        &#x2F;&#x2F;判空        if(grid[0].length&#x3D;&#x3D;0||grid.length&#x3D;&#x3D;0)&#123;            return 0;        &#125;        &#x2F;&#x2F;拿出这个矩阵的横和列        int right&#x3D;grid[0].length;        int bottom&#x3D;grid.length;        &#x2F;&#x2F;        for(int i&#x3D;0;i&lt;bottom;i++)&#123;            for(int j&#x3D;0;j&lt;right;j++)&#123;                &#x2F;&#x2F;遍历整个矩阵 如果发现有一个是1的开启深度搜索 找到后给这个计数器加一                if(grid[i][j]&#x3D;&#x3D;&#39;1&#39;)&#123;                    dfs(grid,i,j);                    count++;                &#125;            &#125;        &#125;        return count;    &#125;    &#x2F;&#x2F;深度邮箱搜索    public void dfs(char[][] grid,int i,int j)&#123;        &#x2F;&#x2F;关键就是这个判断标准，超出不可以 为0不可以        if(i&lt;0||i&gt;grid.length-1||j&lt;0||j&gt;grid[0].length-1||grid[i][j]&#x3D;&#x3D;&#39;0&#39;)&#123;            return;        &#125;        &#x2F;&#x2F;递归调用了上下左右，这个方法结束的时候就一个岛屿        grid[i][j]&#x3D;&#39;0&#39;;        dfs(grid,i-1,j);        dfs(grid,i+1,j);        dfs(grid,i,j-1);        dfs(grid,i,j+1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最大正方形</p><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p><p> </p><p>示例 1：<br>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4</p><p>示例 2：</p><p>输入：matrix = [[“0”,”1”],[“1”,”0”]]<br>输出：1</p><p>示例 3：<br>输入：matrix = [[“0”]]<br>输出：0</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maximalSquare(char[][] matrix) &#123;        int maxSide &#x3D; 0;        if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0) &#123;            return maxSide;        &#125;        int rows &#x3D; matrix.length, columns &#x3D; matrix[0].length;        for (int i &#x3D; 0; i &lt; rows; i++) &#123;            for (int j &#x3D; 0; j &lt; columns; j++) &#123;                if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;                    &#x2F;&#x2F; 遇到一个 1 作为正方形的左上角                    maxSide &#x3D; Math.max(maxSide, 1);                    &#x2F;&#x2F; 计算可能的最大正方形边长                    int currentMaxSide &#x3D; Math.min(rows - i, columns - j);                    for (int k &#x3D; 1; k &lt; currentMaxSide; k++) &#123;                        &#x2F;&#x2F; 判断新增的一行一列是否均为 1                        boolean flag &#x3D; true;                        if (matrix[i + k][j + k] &#x3D;&#x3D; &#39;0&#39;) &#123;                            break;                        &#125;                        for (int m &#x3D; 0; m &lt; k; m++) &#123;                            if (matrix[i + k][j + m] &#x3D;&#x3D; &#39;0&#39; || matrix[i + m][j + k] &#x3D;&#x3D; &#39;0&#39;) &#123;                                flag &#x3D; false;                                break;                            &#125;                        &#125;                        if (flag) &#123;                            maxSide &#x3D; Math.max(maxSide, k + 1);                        &#125; else &#123;                            break;                        &#125;                    &#125;                &#125;            &#125;        &#125;        int maxSquare &#x3D; maxSide * maxSide;        return maxSquare;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长递增子序列</p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p> <br>示例 1：</p><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p><p>输入：nums = [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1 </p><p>提示：</p><p>1 &lt;= nums.length &lt;= 2500<br>-104 &lt;= nums[i] &lt;= 104</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int lengthOfLIS(int[] nums) &#123;           if(nums.length&lt;&#x3D;1)&#123;               return nums.length;           &#125;           int n&#x3D;nums.length;            int arr[]&#x3D;new int[n];            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                arr[i]&#x3D;1;            &#125;            int result&#x3D;1;            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                    for(int j&#x3D;0;j&lt;i;j++)&#123;                        if(nums[i]&gt;nums[j])&#123;                        arr[i]&#x3D;Math.max(arr[i],arr[j]+1);                        &#125;                    &#125;                   result&#x3D;Math.max(arr[i],result);             &#125;            return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>零钱兑换</p><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</p><p>示例 2：</p><p>输入：coins = [2], amount = 3<br>输出：-1</p><p>示例 3：</p><p>输入：coins = [1], amount = 0<br>输出：0</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int coinChange(int[] coins, int amount) &#123;        int max &#x3D; Integer.MAX_VALUE;        int[] dp &#x3D; new int[amount + 1];        &#x2F;&#x2F;初始化dp数组为最大值        for (int j &#x3D; 0; j &lt; dp.length; j++) &#123;            dp[j] &#x3D; max;        &#125;        &#x2F;&#x2F;当金额为0时需要的硬币数目为0        dp[0] &#x3D; 0;        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;            &#x2F;&#x2F;正序遍历：完全背包每个硬币可以选择多次            for (int j &#x3D; coins[i]; j &lt;&#x3D; amount; j++) &#123;                &#x2F;&#x2F;只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要                if (dp[j - coins[i]] !&#x3D; max) &#123;                    &#x2F;&#x2F;选择硬币数目最小的情况                    dp[j] &#x3D; Math.min(dp[j], dp[j - coins[i]] + 1);                &#125;            &#125;        &#125;        return dp[amount] &#x3D;&#x3D; max ? -1 : dp[amount];        &#x2F;&#x2F;这道题还不是很懂    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 </p><p>前 K 个高频元素</p><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p><p>输入: nums = [1], k = 1<br>输出: [1] </p><p>提示：</p><p>1 &lt;= nums.length &lt;= 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] topKFrequent(int[] nums, int k) &#123;        HashMap&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;Integer,Integer&gt;();        &#x2F;&#x2F;遍历将出现的次数和值放到一个map中            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                if(map.get(nums[i])&#x3D;&#x3D;null)&#123;                    map.put(nums[i],1);                &#125;else&#123;                    map.put(nums[i],(int)map.get(nums[i])+1);                &#125;            &#125;                     &#x2F;&#x2F;这个是一个关键 对一个包着map的list进行排序              List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; list&#x3D;new ArrayList&lt;&gt;(map.entrySet());            &#x2F;&#x2F; 如果b值大于a值那么就排前面                Collections.sort(list,(a,b)-&gt;&#123;                    return b.getValue()-a.getValue();                &#125;);            &#x2F;&#x2F;最后遍历 就拿前面k个值                int[] arr&#x3D;new int[k];                for(int i&#x3D;0;i&lt;k;i++)&#123;                    arr[i]&#x3D;(int)list.get(i).getKey();                &#125;        return arr;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三个数的最大乘积</p><p>给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p> </p><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：6<br>示例 2：</p><p>输入：nums = [1,2,3,4]<br>输出：24<br>示例 3：</p><p>输入：nums = [-1,-2,-3]<br>输出：-6</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maximumProduct(int[] nums) &#123;            int max&#x3D;Integer.MIN_VALUE;            if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;                return 0;            &#125;            if(nums.length&#x3D;&#x3D;1)&#123;                return nums[0];            &#125;            if(nums.length&#x3D;&#x3D;2)&#123;                return nums[1]*nums[0];            &#125;            Arrays.sort(nums);            for(int i&#x3D;0;i&lt;nums.length-2;i++)&#123;                int tempMax&#x3D;nums[i]*nums[i+1]*nums[i+2];                max&#x3D;Math.max(max,tempMax);            &#125;            int n&#x3D;nums.length;            int  sum&#x3D;  Math.max(nums[0]*nums[1]*nums[n-1],nums[n-1]*nums[n-2]*nums[n-3]);            max&#x3D;Math.max(max,sum);            return max;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二分查找</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><p>示例 2:<br>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int search(int[] nums, int target) &#123;            int left&#x3D;0;            int right&#x3D;nums.length-1;            int mid&#x3D;0;            while(left&lt;&#x3D;right)&#123;                mid&#x3D;left+(right-left)&#x2F;2;                if(nums[mid]&#x3D;&#x3D;target)&#123;                    return mid;                &#125;else if(nums[mid]&gt;target)&#123;                        right&#x3D;mid-1;                    &#125;else &#123;                    left&#x3D;mid+1;                &#125;            &#125;            return -1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二维数组中的查找</p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;        &#x2F;&#x2F;判空操作            if(matrix&#x3D;&#x3D;null)&#123;                return false;            &#125;            if(matrix.length&#x3D;&#x3D;0)&#123;                return false;            &#125;            &#x2F;&#x2F;right top 是右上角 为什么选右上角 因为右上角 往左边永远是减往下面永远是加                int right&#x3D;matrix[0].length-1;                int top&#x3D;0;                &#x2F;&#x2F;当top不大于最低 right 不小于0 那么找到就是true 找不到判断大小继续找大了就往左边挪  小了往下边加                while(right&gt;&#x3D;0&amp;&amp;top&lt;matrix.length)&#123;                    if(matrix[top][right]&#x3D;&#x3D;target)&#123;                        return true;                    &#125;else if(matrix[top][right]&gt;target)&#123;                        right--;                    &#125;else if(matrix[top][right]&lt;target)&#123;                        top++;                    &#125;                &#125;                return false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>剑指 Offer 07. 重建二叉树</p><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p> </p><p>示例 1:</p><p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]<br>示例 2:</p><p>Input: preorder = [-1], inorder = [-1]<br>Output: [-1]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int n&#x3D;preorder.length;        &#x2F;&#x2F;判空        if(n&#x3D;&#x3D;0)&#123;            return null;        &#125;        &#x2F;&#x2F;先找出 这个前序根在中序的那个位置        int rootValue&#x3D;preorder[0];        int rootIndex&#x3D;0;        TreeNode rootTree &#x3D; new TreeNode(rootValue);        for(int i&#x3D;0;i&lt;n;i++)&#123;            if(inorder[i]&#x3D;&#x3D;rootValue)&#123;                rootIndex&#x3D;i;            &#125;        &#125;         &#x2F;&#x2F;左子树就是前序        rootTree.left&#x3D;buildTree(Arrays.copyOfRange(preorder,1,1+rootIndex),Arrays.copyOfRange(inorder,0,0+rootIndex));        rootTree.right&#x3D;buildTree(Arrays.copyOfRange(preorder,1+rootIndex,n)        ,Arrays.copyOfRange(inorder,rootIndex+1,n));        return rootTree;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>旋转数组的最小数字</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  </p><p>示例 1：</p><p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p><p>输入：[2,2,2,0,1]<br>输出：0</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int minArray(int[] numbers) &#123;        Arrays.sort(numbers);        return numbers[0];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调整数组顺序使奇数位于偶数前面</p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p><p> </p><p>示例：</p><p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] exchange(int[] nums) &#123;        ArrayList firstList&#x3D;new ArrayList&lt;Integer&gt;();        ArrayList secondList&#x3D;new ArrayList&lt;Integer&gt;();        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;            if(nums[i]%2&#x3D;&#x3D;0)&#123;                secondList.add(nums[i]);            &#125;else&#123;                firstList.add(nums[i]);            &#125;        &#125;        for(int i&#x3D;0;i&lt;firstList.size();i++)&#123;            System.out.print(firstList.get(i));            nums[i]&#x3D;(int)firstList.get(i);        &#125;        for(int i&#x3D;0;i&lt;secondList.size();i++)&#123;                System.out.print(secondList.get(i));               nums[firstList.size()+i]&#x3D;(int)secondList.get(i);         &#125;        return nums;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺时针打印矩阵</p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p> </p><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7] </p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] spiralOrder(int[][] matrix) &#123;            &#x2F;&#x2F;如果为空或者集合就一个 那么返回一个            if(matrix&#x3D;&#x3D;null||matrix.length&#x3D;&#x3D;0||matrix[0].length&#x3D;&#x3D;0)&#123;                int [] arr&#x3D;new int[0];                return  arr;            &#125;            &#x2F;&#x2F;左边            int left&#x3D;0;            &#x2F;&#x2F;右边            int right&#x3D;matrix[0].length-1;            &#x2F;&#x2F;上边            int top&#x3D;0;            &#x2F;&#x2F;下边            int botton&#x3D;matrix.length-1;            &#x2F;&#x2F;存储集合的边界            ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();        &#x2F;&#x2F;如果左边小于右边 或者下边大于上边           while(left&lt;&#x3D;right&amp;&amp;botton&gt;&#x3D;top)&#123;            &#x2F;&#x2F;先从左到右加入            for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;                list.add(matrix[top][i]);            &#125;            &#x2F;&#x2F;从上到下加入            for(int i&#x3D;top+1;i&lt;&#x3D;botton;i++)&#123;                list.add(matrix[i][right]);            &#125;            &#x2F;&#x2F;从右到左加入  但是要求上下不能相等 不然会给上面重复计算            for(int i&#x3D;right-1;i&gt;&#x3D;left&amp;&amp;botton!&#x3D;top;i--)&#123;                list.add(matrix[botton][i]);            &#125;            &#x2F;&#x2F;从下到上，但是要求左和右不能相等            for(int i&#x3D;botton-1;i&gt;&#x3D;top+1&amp;&amp;left!&#x3D;right;i--)&#123;                list.add(matrix[i][left]);            &#125;            top++;            right--;            botton--;            left++;            &#125;            int [] arr&#x3D;new int[list.size()];            for(int i&#x3D;0;i&lt;list.size();i++)&#123;                arr[i]&#x3D;list.get(i);            &#125;            return arr;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组中出现次数超过一半的数字</p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p> </p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p> </p><p>示例 1:</p><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2 </p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int majorityElement(int[] nums) &#123;            HashMap map&#x3D;new HashMap&lt;Integer,Integer&gt;();            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                    if(map.get(nums[i])!&#x3D;null)&#123;                         map.put(nums[i],(int)map.get(nums[i])+1);                       &#125;else&#123;                        map.put(nums[i],1);                    &#125;            &#125;            Set&lt;Integer&gt; sets &#x3D;map.keySet();            for(Integer value : sets )&#123;                System.out.println(&quot;key&quot;+value);                System.out.println(&quot;value&quot;+map.get(value));                if((int)map.get(value)&gt;nums.length&#x2F;2)&#123;                    return value;                &#125;            &#125;            return -1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最小的k个数</p><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p> </p><p>示例 1：</p><p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p><p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int[] getLeastNumbers(int[] arr, int k) &#123;        Arrays.sort(arr);        int[] result&#x3D;new int[k];        for(int i&#x3D;0;i&lt;k;i++)&#123;            result[i]&#x3D;arr[i];        &#125;        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连续子数组的最大和</p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p> </p><p>示例1:</p><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxSubArray(int[] nums) &#123;            if(nums.length&#x3D;&#x3D;1)&#123;                return nums[0];            &#125;        &#x2F;&#x2F;这个是最后的值大小        int max&#x3D;nums[0];        &#x2F;&#x2F;这个是临时的一个最大值 因为是连续的一个最大值 所以需要这个临时的，        int tempMax&#x3D;nums[0];        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;            &#x2F;&#x2F;这个最大值就是之前积累的加上这个值大 还是单个这个大            tempMax&#x3D;Math.max(nums[i],tempMax+nums[i]);            &#x2F;&#x2F;把连续加上的判断的值和之前积累的最大值做 最大留存就得出了            max&#x3D;Math.max(max,tempMax);         &#125;        return max;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在排序数组中查找数字 I</p><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int search(int[] nums, int target) &#123;           HashMap map&#x3D; new HashMap&lt;Integer,Integer&gt;();        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;            if(map.get(nums[i])&#x3D;&#x3D;null)&#123;                 map.put(nums[i],1);            &#125;else&#123;                int temp&#x3D;(int)map.get(nums[i]);                map.put(nums[i],temp+1);            &#125;      &#125;         if(map.get(target)&#x3D;&#x3D;null)&#123;             return 0;         &#125;else&#123;            return (int)map.get(target);         &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 0～n-1中缺失的数字</p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p> </p><p>示例 1:</p><p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int missingNumber(int[] nums) &#123;                   for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                if(nums[i]!&#x3D;i)&#123;                    return i;                &#125;            &#125;            return nums[nums.length-1]+1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扑克牌中的顺子</p><p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p> </p><p>示例 1:</p><p>输入: [1,2,3,4,5]<br>输出: True </p><p>示例 2:</p><p>输入: [0,0,1,2,5]<br>输出: True</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean isStraight(int[] nums) &#123;            &#x2F;&#x2F;先排序一下            Arrays.sort(nums);            &#x2F;&#x2F;搞            int zoreNumber&#x3D;0;            for(int i&#x3D;0;i&lt;nums.length-1;i++)&#123;                if(nums[i]&#x3D;&#x3D;0)&#123;                    zoreNumber++;                    continue;                &#125;                if(nums[i+1]&#x3D;&#x3D;nums[i])&#123;                    return false;                &#125;                zoreNumber&#x3D;zoreNumber-(nums[i+1]-nums[i]-1);            &#125;            System.out.print(&quot;zoreNumber&quot;+zoreNumber);            if(zoreNumber&gt;&#x3D;0)&#123;                return true;            &#125;else&#123;                return false;            &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>股票的最大利润</p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p> </p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxProfit(int[] prices) &#123;        int minValue&#x3D;Integer.MAX_VALUE;        int maxResult&#x3D;0;        for(int i&#x3D;0;i&lt;prices.length;i++)&#123;            minValue &#x3D;Math.min(minValue,prices[i]);            int tempResult &#x3D;prices[i]-minValue;            maxResult&#x3D;Math.max(maxResult,tempResult);        &#125;        return maxResult;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 数组中和为 0 的三个数</p><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。</p><p> </p><p>示例 1：</p><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p><p>输入：nums = []<br>输出：[]<br>示例 3：</p><p>输入：nums = [0]<br>输出：[]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;            Arrays.sort(nums);          ArrayList&lt;List&lt;Integer&gt;&gt; result&#x3D;  new ArrayList&lt;List&lt;Integer&gt;&gt;();          ArrayList&lt;Integer&gt; arrList&#x3D; new ArrayList&lt;Integer&gt;();                     for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                int target&#x3D;-nums[i];                int start&#x3D;i+1;                int end&#x3D;nums.length-1;                while(start&lt;end&amp;&amp;start&lt;&#x3D;nums.length-1&amp;&amp;end&lt;&#x3D;nums.length-1)&#123;                    if(nums[start]+nums[end]&#x3D;&#x3D;target)&#123;                        ArrayList&lt;Integer&gt; list&#x3D;new ArrayList();                        list.add(nums[start]);                        list.add(nums[end]);                        list.add(nums[i]);                        if(!result.contains(list))&#123;                            result.add(list);                        &#125;                        start++;                        end--;                    &#125;else if(nums[start]+nums[end]&lt;target)&#123;                        start++;                    &#125;else&#123;                        end--;                    &#125;                &#125;            &#125;        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并排序的数组</p><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p>示例:</p><p>输入:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public void merge(int[] A, int m, int[] B, int n) &#123;               for(int i&#x3D;m;i&lt;m+n;i++)&#123;            A[i]&#x3D;B[i-m];        &#125;        Arrays.sort(A);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>搜索旋转数组</p><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p><p>示例1:</p><p> 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5<br> 输出: 8（元素5在该数组中的索引）<br>示例2:</p><p> 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11<br> 输出：-1 （没有找到）</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int search(int[] arr, int target) &#123;        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;                if(arr[i]&#x3D;&#x3D;target)&#123;                    return i;                &#125;        &#125;         return -1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排序矩阵查找</p><p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        if(matrix&#x3D;&#x3D;null||matrix.length&#x3D;&#x3D;0)&#123;            return false;        &#125;        &#x2F;&#x2F;  遍历的做法        &#x2F;&#x2F;   int colume&#x3D;-1;        &#x2F;&#x2F;   int m&#x3D;matrix.length;        &#x2F;&#x2F;   int n&#x3D;matrix[0].length;        &#x2F;&#x2F;  for(int i&#x3D;0;i&lt;m;i++)&#123;        &#x2F;&#x2F;      for(int j&#x3D;0;j&lt;n;j++)&#123;        &#x2F;&#x2F;          if(matrix[i][j]&#x3D;&#x3D;target)&#123;        &#x2F;&#x2F;              return true;        &#x2F;&#x2F;          &#125;                         &#x2F;&#x2F;      &#125;        &#x2F;&#x2F;  &#125;            int m&#x3D;0;            int n&#x3D;matrix[0].length-1;            while(m&lt;matrix.length&amp;&amp;n&gt;&#x3D;0)&#123;                if(matrix[m][n]&#x3D;&#x3D;target)&#123;                    return true;                &#125;else if(matrix[m][n]&gt;target)&#123;                    n--;                &#125;else&#123;                    m++;                &#125;            &#125;         return false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连续数列</p><p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p><p>示例：</p><p>输入： [-2,1,-3,4,-1,2,1,-5,4]<br>输出： 6<br>解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶：</p><p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int maxSubArray(int[] nums) &#123;        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;            return -1;        &#125;        int max&#x3D;nums[0];        int current&#x3D;nums[0];        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;            if(current+nums[i]&gt;nums[i])&#123;                current&#x3D;current+nums[i];            &#125;else&#123;                current&#x3D;nums[i];            &#125;            max&#x3D;Math.max(current,max);        &#125;            return max;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>无重复字符的最长子串</p><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p><p>输入: s = “”<br>输出: 0</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int lengthOfLongestSubstring(String s) &#123;            char chars[]&#x3D; s.toCharArray();            int max&#x3D;0;            ArrayList&lt;Character&gt; list&#x3D; new  ArrayList();            if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0)&#123;                return 0;            &#125;            for(int i&#x3D;0;i&lt;chars.length;i++)&#123;                  Character character&#x3D;  new Character(chars[i]);                    if(list.contains(character))&#123;                        int index&#x3D;list.indexOf(character);                        for(int j&#x3D;index;j&gt;&#x3D;0;j--)&#123;                            list.remove(j);                        &#125;                        if(!list.contains(character))&#123;                            list.add(character);                        &#125;                    &#125;else&#123;                        list.add(character);                        max&#x3D;Math.max(max,list.size());                    &#125;            &#125;            return max;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长回文子串</p><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p> </p><p>示例 1：</p><p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：”bb”<br>示例 3：</p><p>输入：s = “a”<br>输出：”a”<br>示例 4：</p><p>输入：s = “ac”<br>输出：”a”</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String longestPalindrome(String s) &#123;        char chars[]&#x3D;s.toCharArray();        int length&#x3D;s.length();        if(length&lt;2)&#123;            return s;        &#125;        Boolean arr[][]&#x3D;new Boolean[length][length];        for(int i&#x3D;0;i&lt;length;i++)&#123;            arr[i][i]&#x3D;true;        &#125;        int maxhublength&#x3D;1;        int start&#x3D;0;        for(int j&#x3D;1;j&lt;length;j++)&#123;            for(int i&#x3D;0;i&lt;j;i++)&#123;                if(chars[j]!&#x3D;chars[i])&#123;                        arr[i][j]&#x3D;false;                &#125;else&#123;                    if(j-i&lt;3)&#123;                        arr[i][j]&#x3D;true;                    &#125;else&#123;                         arr[i][j]&#x3D;arr[i+1][j-1];                    &#125;                &#125;                if(((j-i+1)&gt;maxhublength)&amp;&amp;arr[i][j])&#123;                    maxhublength&#x3D;j-i+1;                    start&#x3D;i;                &#125;            &#125;        &#125;      &#x2F;&#x2F;不会        String result&#x3D;s.substring(start,start+maxhublength);                return  result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长公共前缀</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p> </p><p>示例 1：</p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：</p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        &#x2F;&#x2F;先判空一下        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0)&#123;            return &quot;&quot;;        &#125;        &#x2F;&#x2F; 拿第一个为基准        String firstString&#x3D;strs[0];        &#x2F;&#x2F;这个是一个字符串的建造器        StringBuilder build&#x3D; new StringBuilder();        &#x2F;&#x2F;遍历第一个字符串的字符        for(int i&#x3D;0;i&lt;firstString.length();i++)&#123;            char c&#x3D;firstString.charAt(i);            &#x2F;&#x2F;如果某一个字符串的字符没有对应字符就会被return  因为是要连续一样的字符串            for(int j&#x3D;1;j&lt;strs.length;j++)&#123;                if(strs[j].length()&lt;&#x3D;i||c!&#x3D;strs[j].charAt(i))&#123;                   return build.toString();                &#125;            &#125;            build.append(c);        &#125;        return build.toString();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 有效的括号</p><p> 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。 </p><p>示例 1：</p><p>输入：s = “()”<br>输出：true<br>示例 2：</p><p>输入：s = “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s = “(]”<br>输出：false<br>示例 4：</p><p>输入：s = “([)]”<br>输出：false<br>示例 5：</p><p>输入：s = “{[]}”<br>输出：true</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean isValid(String s) &#123;    &#x2F;&#x2F;搞一个栈      Stack&lt;Character&gt; stack&#x3D;  new Stack&lt;&gt;();    &#x2F;&#x2F;遍历这个字符串      for(int i&#x3D;0;i&lt;s.length();i++)&#123;          &#x2F;&#x2F;因为只有三种类型，看到某一个就放入相反的即可          char c&#x3D;s.charAt(i);          if(c&#x3D;&#x3D;&#39;(&#39;)&#123;              stack.push(&#39;)&#39;);          &#125;else if(c&#x3D;&#x3D;&#39;&#123;&#39;)&#123;              stack.push(&#39;&#125;&#39;);          &#125;else if(c&#x3D;&#x3D;&#39;[&#39;)&#123;              stack.push(&#39;]&#39;);              &#x2F;&#x2F;如果遍历还没有为空  或者弹出来的字符跟放进去的不一样 那么就返回false          &#125;else if (stack.isEmpty()||c!&#x3D;stack.pop())&#123;              return false;          &#125;      &#125;      return stack.isEmpty();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> </p><p>括号生成</p><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 </p><p>示例 1：</p><p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p><p>输入：n = 1<br>输出：[“()”]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public List&lt;String&gt; generateParenthesis(int n) &#123;     List&lt;String&gt; res&#x3D;new ArrayList&lt;String&gt;();        generate(res,&quot;&quot;,0,0,n);        return res;    &#125;    public void generate(List&lt;String&gt; res,String ans,int count1,int count2,int n)&#123;             if(count1&gt;n||count2&gt;n)&#123;                return;            &#125;            if(count2&#x3D;&#x3D;n&amp;&amp;count1&#x3D;&#x3D;n)&#123;                res.add(ans);            &#125;             if(count1&gt;&#x3D;count2)&#123;               String ans1 &#x3D; new String(ans);             generate(res, ans+&quot;(&quot;, count1+1, count2, n);                 generate(res, ans1+&quot;)&quot;, count1, count2+1, n);            &#125;        &#x2F;&#x2F;不是很懂    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串相乘</p><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><p> </p><p>示例 1:</p><p>输入: num1 = “2”, num2 = “3”<br>输出: “6”<br>示例 2:</p><p>输入: num1 = “123”, num2 = “456”<br>输出: “56088” </p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String multiply(String num1, String num2) &#123;        if (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;            return &quot;0&quot;;        &#125;        String ans &#x3D; &quot;0&quot;;        int m &#x3D; num1.length(), n &#x3D; num2.length();        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;            StringBuffer curr &#x3D; new StringBuffer();            int add &#x3D; 0;            for (int j &#x3D; n - 1; j &gt; i; j--) &#123;                curr.append(0);            &#125;            int y &#x3D; num2.charAt(i) - &#39;0&#39;;            for (int j &#x3D; m - 1; j &gt;&#x3D; 0; j--) &#123;                int x &#x3D; num1.charAt(j) - &#39;0&#39;;                int product &#x3D; x * y + add;                curr.append(product % 10);                add &#x3D; product &#x2F; 10;            &#125;            if (add !&#x3D; 0) &#123;                curr.append(add % 10);            &#125;            ans &#x3D; addStrings(ans, curr.reverse().toString());        &#125;        return ans;    &#125;    public String addStrings(String num1, String num2) &#123;        int i &#x3D; num1.length() - 1, j &#x3D; num2.length() - 1, add &#x3D; 0;        StringBuffer ans &#x3D; new StringBuffer();        while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0 || add !&#x3D; 0) &#123;            int x &#x3D; i &gt;&#x3D; 0 ? num1.charAt(i) - &#39;0&#39; : 0;            int y &#x3D; j &gt;&#x3D; 0 ? num2.charAt(j) - &#39;0&#39; : 0;            int result &#x3D; x + y + add;            ans.append(result % 10);            add &#x3D; result &#x2F; 10;            i--;            j--;        &#125;        ans.reverse();        return ans.toString();        &#x2F;&#x2F;这个题不会 想不明白    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复原 IP 地址</p><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#x32;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#x2e;&#49;">&#x31;&#x39;&#x32;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#x2e;&#49;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><p> </p><p>示例 1：</p><p>输入：s = “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]<br>示例 2：</p><p>输入：s = “0000”<br>输出：[“0.0.0.0”]<br>示例 3：</p><p>输入：s = “1111”<br>输出：[“1.1.1.1”]<br>示例 4：</p><p>输入：s = “010010”<br>输出：[“0.10.0.10”,”0.100.1.0”]<br>示例 5：</p><p>输入：s = “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public List&lt;String&gt; restoreIpAddresses(String s) &#123;  ArrayList&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;();        for (int i &#x3D; 1; i &lt; 4; i++) &#123;            for (int j &#x3D; 1; j &lt; 4; j++) &#123;                for (int k &#x3D; 1; k &lt; 4; k++) &#123;                    for (int l &#x3D; 0; l &lt; 4; l++) &#123;                        if (i + j + k + l &#x3D;&#x3D; s.length()) &#123;                            String s1 &#x3D; s.substring(0, i);                            String s2 &#x3D; s.substring(i, i+j);                            String s3 &#x3D; s.substring(i + j, i + j + k);                            String s4 &#x3D; s.substring(i + j + k, i + j + k + l);                            if (checkout(s1) &amp;&amp; checkout(s2) &amp;&amp; checkout(s3) &amp;&amp; checkout(s4)) &#123;                                StringBuilder builder &#x3D; new StringBuilder();                                String ip &#x3D; builder.append(s1).append(&quot;.&quot;).append(s2).append(&quot;.&quot;).append(s3).append(&quot;.&quot;).append(s4).toString();                                strings.add(ip);                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return strings;    &#125;              public boolean checkout(String s) &#123;        if (s.equals(&quot;&quot;))&#123;            return false;        &#125;        if (s.charAt(0) &#x3D;&#x3D; &#39;0&#39; &amp;&amp; s.length() !&#x3D; 1) &#123;            return false;        &#125; else if (s.charAt(0) &#x3D;&#x3D; &#39;0&#39; &amp;&amp; s.length() &#x3D;&#x3D; 1) &#123;            return true;        &#125;        try &#123;            if (Integer.valueOf(s) &lt;&#x3D; 255) &#123;                if (s.charAt(0) !&#x3D; &#39;0&#39;) &#123;                    return true;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125; catch (Exception e) &#123;            return false;        &#125;        return false;    &#125;    &#x2F;&#x2F;这个题也是不太会的    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> </p><p>验证回文串</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean isPalindrome(String s) &#123;            if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0)&#123;                return false;            &#125;            &#x2F;&#x2F;先把它搞成小写的字母            s&#x3D;s.toLowerCase();            &#x2F;&#x2F;搞一个列表存储            ArrayList&lt;Character&gt; list&#x3D;new ArrayList&lt;Character&gt;();            &#x2F;&#x2F;遍历 判断是否是空和字母 数字 只加字母和数字            for(int i&#x3D;0;i&lt;s.length();i++)&#123;                char c&#x3D;s.charAt(i);                if(c!&#x3D;&#39; &#39;&amp;&amp;c-&#39;a&#39;&lt;26&amp;&amp;c-&#39;a&#39;&gt;&#x3D;0)&#123;                    list.add(c);                &#125;                if(c&gt;&#x3D;&#39;0&#39;&amp;&amp;c&lt;&#x3D;&#39;9&#39;)&#123;                    list.add(c);                &#125;            &#125;            &#x2F;&#x2F;判断头尾是否相等就可以了        for(int i&#x3D;0;i&lt;(list.size()&#x2F;2);i++)&#123;            if(list.get(i)!&#x3D;list.get(list.size()-i-1))&#123;                return false;            &#125;        &#125;            return  true;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较版本号</p><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。 </p><p>示例 1：</p><p>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”<br>示例 2：</p><p>输入：version1 = “1.0”, version2 = “1.0.0”<br>输出：0<br>解释：version1 没有指定下标为 2 的修订号，即视为 “0”<br>示例 3：</p><p>输入：version1 = “0.1”, version2 = “1.1”<br>输出：-1<br>解释：version1 中下标为 0 的修订号是 “0”，version2 中下标为 0 的修订号是 “1” 。0 &lt; 1，所以 version1 &lt; version2</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int compareVersion(String version1, String version2) &#123;        &#x2F;&#x2F;先根据. 切割字符          String [] a1 &#x3D;  version1.split(&quot;\\.&quot;);          String [] a2 &#x3D;  version2.split(&quot;\\.&quot;);        &#x2F;&#x2F;例子1 需要把前面的0给删除但是 Integer.valueOf 已经能满足这一点        &#x2F;&#x2F;例子2 需要缺少下标的时候把值默认为0        &#x2F;&#x2F;这个题就是题目太难理解了          for(int n&#x3D;0;n&lt;Math.max(a1.length,a2.length);n++)&#123;              int i&#x3D;(n&lt;a1.length?Integer.valueOf(a1[n]):0);              int j&#x3D;(n&lt;a2.length?Integer.valueOf(a2[n]):0);              if(i&lt;j)&#123;                  return -1;              &#125;else if(i&gt;j)&#123;                   return 1;              &#125;          &#125;          return 0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最大数</p><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p> </p><p>示例 1：</p><p>输入：nums = [10,2]<br>输出：”210”<br>示例 2：</p><p>输入：nums = [3,30,34,5,9]<br>输出：”9534330”<br>示例 3：</p><p>输入：nums = [1]<br>输出：”1”<br>示例 4：</p><p>输入：nums = [10]<br>输出：”10”</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String largestNumber(int[] nums) &#123;            &#x2F;&#x2F;进行冒泡排序 排序的核心是 将两个字符加起来，然后进行排序大的排前面 小的排后面            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                for(int j&#x3D;i+1;i&lt;nums.length;j++)&#123;                    if(i&gt;&#x3D;nums.length||j&gt;&#x3D;nums.length)&#123;                        break;                    &#125;                    String temp1&#x3D;nums[i]+&quot;&quot;+nums[j];                    String temp2&#x3D;nums[j]+&quot;&quot;+nums[i];                    if(Long.parseLong(temp1)&lt;Long.parseLong(temp2))&#123;                            int temp&#x3D;nums[i];                             nums[i]&#x3D;nums[j];                             nums[j]&#x3D;temp;                    &#125;                &#125;            &#125;            &#x2F;&#x2F;排完序的数组进行拼接 最后完成          StringBuilder build&#x3D; new StringBuilder();            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;                if(&quot;0&quot;.equals(build.toString())&amp;&amp;nums[i]&#x3D;&#x3D;0)&#123;                        continue;                &#125;               build.append(nums[i]);            &#125;            return build.toString();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反转字符串</p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p> </p><p>示例 1：</p><p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public void reverseString(char[] s) &#123;        &#x2F;&#x2F; 遍历列表 将最后一个和第一个取出来 然后进行调换就可以了        for(int i&#x3D;0;i&lt;s.length&#x2F;2;i++)&#123;            char first&#x3D;s[i];            char last&#x3D;s[s.length-1-i];            char temp &#x3D;first;            first&#x3D;last;            last&#x3D;temp;            s[i]&#x3D;first;            s[s.length-1-i]&#x3D;last;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串相加</p><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p><p> </p><p>示例 1：</p><p>输入：num1 = “11”, num2 = “123”<br>输出：”134”<br>示例 2：</p><p>输入：num1 = “456”, num2 = “77”<br>输出：”533”<br>示例 3：</p><p>输入：num1 = “0”, num2 = “0”<br>输出：”0”</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String addStrings(String num1, String num2) &#123;        &#x2F;&#x2F;将字符串长度        int l1&#x3D;num1.length()-1;        int l2&#x3D;num2.length()-1;        &#x2F;&#x2F;标志是否进位了        int add&#x3D;0;        &#x2F;&#x2F;字符串建造者        StringBuilder build&#x3D;new StringBuilder();        &#x2F;&#x2F;        while(add!&#x3D;0||l1&gt;&#x3D;0||l2&gt;&#x3D;0)&#123;            &#x2F;&#x2F;获取最低位然后减去’0‘拿到数值 如果长度低于0了 那么就返回0             int x&#x3D;l1&gt;&#x3D;0?num1.charAt(l1)-&#39;0&#39;:0;                int y&#x3D;l2&gt;&#x3D;0?num2.charAt(l2)-&#39;0&#39;:0;             System.out.print(&quot;x&quot;+x);                   System.out.print(&quot;y&quot;+y);                  &#x2F;&#x2F;两个数相加 然后加上进位的那个数             int sum&#x3D;x+y+add;            &#x2F;&#x2F;这个数取模             int result&#x3D;sum%10;              &#x2F;&#x2F;除以10 看是否有进位            add&#x3D;sum&#x2F;10;             &#x2F;&#x2F;将这个进位放到字符串数组中，但是这个是一个反序的            build.append(result);            &#x2F;&#x2F;当然要长度同时减1            --l1;            --l2;        &#125;        &#x2F;&#x2F;将字符串反转        return build.reverse().toString();          &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证IP地址</p><p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。</p><p>如果是有效的 IPv4 地址，返回 “IPv4” ；<br>如果是有效的 IPv6 地址，返回 “IPv6” ；<br>如果不是上述类型的 IP 地址，返回 “Neither” 。<br>IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；</p><p>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p><p>IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。</p><p>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。</p><p>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。</p><p> </p><p>示例 1：</p><p>输入：IP = “172.16.254.1”<br>输出：”IPv4”<br>解释：有效的 IPv4 地址，返回 “IPv4”<br>示例 2：</p><p>输入：IP = “2001:0db8:85a3:0:0:8A2E:0370:7334”<br>输出：”IPv6”<br>解释：有效的 IPv6 地址，返回 “IPv6”<br>示例 3：</p><p>输入：IP = “256.256.256.256”<br>输出：”Neither”<br>解释：既不是 IPv4 地址，又不是 IPv6 地址<br>示例 4：</p><p>输入：IP = “2001:0db8:85a3:0:0:8A2E:0370:7334:”<br>输出：”Neither”<br>示例 5：</p><p>输入：IP = “1e1.4.5.6”<br>输出：”Neither”</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String validIPAddress(String ip) &#123;        &#x2F;&#x2F;先将ip进行切割            String[] ipv4&#x3D;ip.split(&quot;\\.&quot;);            String[] ipv6&#x3D;ip.split(&quot;:&quot;);        &#x2F;&#x2F;按正常的规则            if(ipv4.length&#x3D;&#x3D;4&amp;&amp;ip.charAt(0)!&#x3D;&#39;.&#39;&amp;&amp;ip.charAt(ip.length()-1)!&#x3D;&#39;.&#39;)&#123;                &#x2F;&#x2F;遍历ip                for(String s : ipv4)&#123;                    if(s.length()&#x3D;&#x3D;0||s.length()&gt;&#x3D;4||(s.charAt(0)&#x3D;&#x3D;&#39;0&#39;&amp;&amp;s.length()&gt;1))&#123;                        return &quot;Neither&quot;;                    &#125;                    int num&#x3D;0;                    &#x2F;&#x2F;遍历数组下面的规则 每个小数组 只能是数字 且数字相加不能超过256                    for(int i&#x3D;0;i&lt;s.length();i++)&#123;                        char ch&#x3D;s.charAt(i);                        if(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;                            return &quot;Neither&quot;;                        &#125;else&#123;                            num&#x3D;num*10+(ch-&#39;0&#39;);                        &#125;                        System.out.print(&quot;num&quot;+num);                        if(num&gt;&#x3D;256)&#123;                            return &quot;Neither&quot;;                        &#125;                    &#125;                &#125;                return &quot;IPv4&quot;;            &#125;        &#x2F;&#x2F;ipv6 数组长度不能超过8  全部能不能超过16 不能 :开头或者结尾  if (ipv6.length &#x3D;&#x3D; 8 &amp;&amp; ip.length() &gt;&#x3D; 15 &amp;&amp; ip.charAt(0) !&#x3D; &#39;:&#39;         &amp;&amp; ip.charAt(ip.length() - 1) !&#x3D; &#39;:&#39;) &#123;            for (String s : ipv6) &#123;                if (s.length() &#x3D;&#x3D; 0 || s.length() &gt; 4) return &quot;Neither&quot;;                for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;                    char ch &#x3D; s.charAt(i);                    System.out.print(ch);                    if (!(ch &gt;&#x3D; &#39;0&#39;  &amp;&amp; ch &lt;&#x3D; &#39;9&#39; || ch &gt;&#x3D; &#39;A&#39; &amp;&amp; ch &lt;&#x3D; &#39;F&#39;                     || ch &gt;&#x3D; &#39;a&#39; &amp;&amp; ch &lt;&#x3D; &#39;f&#39;)) return &quot;Neither&quot;;                &#125;            &#125;            return &quot;IPv6&quot;;        &#125;        return &quot;Neither&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长回文子序列</p><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p> </p><p>示例 1：</p><p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p><p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。 </p> <pre class="line-numbers language-none"><code class="language-none"> class Solution &#123;    public int longestPalindromeSubseq(String s) &#123;            int n&#x3D;s.length();            int [][] dp&#x3D;new int[n][n];            for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;                dp[i][i]&#x3D;1;                char c1&#x3D;s.charAt(i);                for(int j&#x3D;i+1;j&lt;n;j++)&#123;                    char c2&#x3D;s.charAt(j);                    if(c1&#x3D;&#x3D;c2)&#123;                        dp[i][j]&#x3D;dp[i+1][j-1]+2;                    &#125;else&#123;                        dp[i][j]&#x3D;Math.max(dp[i+1][j],dp[i][j-1]);                    &#125;                &#125;            &#125;            &#x2F;&#x2F;不太会        return dp[0][n-1];    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最长公共子序列</p><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><p> </p><p>示例 1：</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br>示例 2：</p><p>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。<br>示例 3：</p><p>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int longestCommonSubsequence(String text1, String text2) &#123;            int m&#x3D;text1.length();            int n&#x3D;text2.length();&#x2F;&#x2F; 为了把第一行和第一列给空出来            int[][] arr&#x3D;new int [m+1][n+1];      &#x2F;&#x2F; 从1行开始 第一列开始            for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;                for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;                    &#x2F;&#x2F;如果相等那么就是大家的上一个加1也就是左上角                    char c1&#x3D; text1.charAt(i-1);                    char c2&#x3D;text2.charAt(j-1);                    if(c1&#x3D;&#x3D;c2)&#123;                        arr[i][j]&#x3D;arr[i-1][j-1]+1;                    &#125;else&#123;                        &#x2F;&#x2F;如果不相等，那么就取上面和左边的最大值，也就是两个长度的数组的最大值                        arr[i][j]&#x3D;Math.max(arr[i-1][j],arr[i][j-1]);                    &#125;                &#125;            &#125;                return arr[m][n];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串的排列</p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p> </p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p> </p><p>示例:</p><p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”] </p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String[] permutation(String s) &#123;     Set&lt;String&gt; list&#x3D;new HashSet&lt;&gt;();        char[]arr&#x3D;s.toCharArray();        StringBuilder sb &#x3D;new StringBuilder();        boolean[] visited&#x3D;new boolean[arr.length];        dfs(arr,&quot;&quot;,visited,list);        return list.toArray(new String[0]);    &#125;    public void dfs(char[] arr,String s,boolean[] visited,Set&lt;String&gt; list)&#123;            if(s.length()&#x3D;&#x3D;arr.length)&#123;                list.add(s);                return;            &#125;            for(int i&#x3D;0;i&lt;arr.length;i++)&#123;                if(visited[i])&#123;                    continue;                &#125;                visited[i]&#x3D;true;                dfs(arr,s+String.valueOf(arr[i]),visited,list);                visited[i]&#x3D;false;            &#125;        &#x2F;&#x2F;不太会    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p> </p><p>示例 1:</p><p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi” </p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int translateNum(int num) &#123;        &#x2F;&#x2F;因为问的是个数        &#x2F;&#x2F;如果小于9 那么就只有一种可能            if(num&lt;&#x3D;9)&#123;                return 1;            &#125;            &#x2F;&#x2F;先拿最后两位出来            int ba&#x3D;num%100;            if(ba&gt;&#x3D;26||ba&lt;&#x3D;9)&#123;                &#x2F;&#x2F;如果小于9且大于26 那么切割一次               return translateNum(num&#x2F;10);                  &#125;else&#123;                &#x2F;&#x2F;如果在26和9之间的那么有两种可能 一种是切一次 种是切两次                return translateNum(num&#x2F;10)+translateNum(num&#x2F;100);            &#125;           &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 第一个只出现一次的字符</p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p>示例 1:</p><p>输入：s = “abaccdeff”<br>输出：’b’<br>示例 2:</p><p>输入：s = “”<br>输出：’ ‘</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public char firstUniqChar(String s) &#123;        char result&#x3D;&#39; &#39;;        &#x2F;&#x2F;存储字符和对应的次数      HashMap&lt;Character,Integer&gt; map&#x3D; new HashMap&lt;Character,Integer&gt;();      &#x2F;&#x2F;将字符串和次数整理到map中        for(int i&#x3D;0;i&lt;s.length();i++)&#123;           char at&#x3D; s.charAt(i);            if(map.get(at)&#x3D;&#x3D;null)&#123;                map.put(at,1);            &#125;else&#123;               int value&#x3D; (int)map.get(at);               map.put(at,value+1);            &#125;        &#125;        &#x2F;&#x2F;遍历map找出次数为1的       Set&lt;Character&gt; sets&#x3D; map.keySet();      ArrayList&lt;Character&gt; list&#x3D;  new ArrayList&lt;Character&gt;();       for(Character c:sets)&#123;           if((int)map.get(c)&#x3D;&#x3D;1)&#123;              list.add(c);           &#125;       &#125;       &#x2F;&#x2F;通过字符串遍历 如果存在次数为1的返回，可以完成第一次的设定       for(int i&#x3D;0;i&lt;s.length();i++)&#123;            if(list.contains(s.charAt(i)))&#123;                return s.charAt(i);            &#125;       &#125;        return result;    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻转单词顺序</p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p> </p><p>示例 1：</p><p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public String reverseWords(String s) &#123;        if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0)&#123;            return &quot;&quot;;        &#125;        &#x2F;&#x2F;先把字符串的前面和后面空格去掉        s&#x3D;s.trim();        String result&#x3D;&quot;&quot;;        &#x2F;&#x2F;将字符串按空格切割        String [] strArr&#x3D;s.split(&quot; &quot;);        &#x2F;&#x2F;将数组的前面和后面进行调转        for(int i&#x3D;0;i&lt;strArr.length&#x2F;2;i++)&#123;            String firstStr&#x3D;strArr[i];            String secondStr&#x3D;strArr[strArr.length-1-i];            String tempStr&#x3D;firstStr;             firstStr&#x3D;secondStr;             secondStr&#x3D;tempStr;            strArr[i]&#x3D;firstStr;            strArr[strArr.length-1-i]&#x3D;secondStr;        &#125;        &#x2F;&#x2F;最后拼接回来        for(int i&#x3D;0;i&lt;strArr.length;i++)&#123;            result&#x3D;result.trim()+&quot; &quot;+strArr[i];        &#125;        return result.trim();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把字符串转换成整数</p><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p> </p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><p>输入: “42”<br>输出: 42<br>示例 2:</p><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int strToInt(String str) &#123;            &#x2F;&#x2F;字符串先去空格            str&#x3D;str.trim();            int result&#x3D;0;            &#x2F;&#x2F;标志是否应该取反            boolean reverse&#x3D;false;            &#x2F;&#x2F;字符串为空 或者长度为0            if(str&#x3D;&#x3D;null||str.length()&#x3D;&#x3D;0)&#123;                return 0;            &#125;            &#x2F;&#x2F;看第一位是不是负数            if(str.charAt(0)&#x3D;&#x3D;&#39;-&#39;)&#123;                reverse&#x3D;true;                str&#x3D;str.substring(1,str.length());            &#125;else if(str.charAt(0)&#x3D;&#x3D;&#39;+&#39;)&#123;                reverse&#x3D;false;                str&#x3D;str.substring(1,str.length());            &#125;            &#x2F;&#x2F;将字符串切割开然后放进去 字符串建造器            StringBuilder build&#x3D;new StringBuilder();            for(int i&#x3D;0;i&lt;str.length();i++)&#123;              char at&#x3D;str.charAt(i);                if(at-&#39;0&#39;&lt;&#x3D;9&amp;&amp;at-&#39;0&#39;&gt;&#x3D;0)&#123;                    build.append(at);                &#125;else&#123;                    break;                &#125;            &#125;            &#x2F;&#x2F;如果长度为0 那么            if(build.length()&#x3D;&#x3D;0)&#123;                return result;            &#125;            &#x2F;&#x2F;如果数值大于int的最大值            long tempResult&#x3D;0;            &#x2F;&#x2F;如果超过了返回integer最大值            for(int i&#x3D;0;i&lt;build.length();i++)&#123;                tempResult&#x3D;tempResult*10+Integer.valueOf(build.charAt(i)-&#39;0&#39;);                if(tempResult&gt;Integer.MAX_VALUE)&#123;                    if(reverse)&#123;                        return Integer.MIN_VALUE;                    &#125;else&#123;                        return Integer.MAX_VALUE;                    &#125;                &#125;            &#125;                 &#x2F;&#x2F;将long转成int 然后取反 返回            result&#x3D;(int)tempResult;            if(reverse)&#123;                result&#x3D;-result;            &#125;            return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串轮转</p><p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p><p>示例1:</p><p> 输入：s1 = “waterbottle”, s2 = “erbottlewat”<br> 输出：True<br>示例2:</p><p> 输入：s1 = “aa”, s2 = “aba”<br> 输出：False</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean isFlipedString(String s1, String s2) &#123;        &#x2F;&#x2F;如果有一个空 那么就返回false        if(s1&#x3D;&#x3D;null||s2&#x3D;&#x3D;null)&#123;            return false;        &#125;        &#x2F;&#x2F;如果长度不相等        if(s1.length()!&#x3D;s2.length())&#123;                return false;        &#125;        &#x2F;&#x2F;将两个 s2进行拼接 因为无论怎么转 只要一拼接 那么就会有出现 一样的        String ss&#x3D;s2+s2;        &#x2F;&#x2F; 看有没有包含住就可以了        return ss.contains(s1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无重复字符串的排列组合</p><p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p><p>示例1:</p><p> 输入：S = “qwe”<br> 输出：[“qwe”, “qew”, “wqe”, “weq”, “ewq”, “eqw”]<br>示例2:</p><p> 输入：S = “ab”<br> 输出：[“ab”, “ba”]</p> <pre class="line-numbers language-none"><code class="language-none">   class Solution &#123;     List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();     StringBuffer s&#x3D;new StringBuffer();            public String[] permutation(String S) &#123;        dfs(S,list,s);        return list.toArray(new String[list.size()]);    &#125;    public void dfs(String S,List&lt;String&gt; list,StringBuffer s)&#123;        if(s.length() &#x3D;&#x3D; S.length())&#123;            list.add(new String(s));            return;        &#125;        for(int i&#x3D;0;i&lt;S.length();i++)&#123;            String zz&#x3D;new String(s);            if(zz.contains(S.charAt(i)+&quot;&quot;))&#123;                continue;            &#125;            s.append(S.charAt(i));            dfs(S,list,s);            s.deleteCharAt(s.length()-1);        &#125;        &#x2F;&#x2F;没有看懂    &#125;&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 有重复字符串的排列组合</p><p> 有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p><p>示例1:</p><p> 输入：S = “qqe”<br> 输出：[“eqq”,”qeq”,”qqe”]<br>示例2:</p><p> 输入：S = “ab”<br> 输出：[“ab”, “ba”]</p> <pre class="line-numbers language-none"><code class="language-none"> class Solution &#123;    LinkedList&lt;String&gt; list&#x3D; new LinkedList&lt;String&gt;();    public String[] permutation(String S) &#123;        dfs(S.toCharArray(),0);        return list.toArray(new String[0]);    &#125;     public void  dfs(char[] c,int k)&#123;        if(k&#x3D;&#x3D;c.length)&#123;            list.add(new String(c));            return;        &#125;        HashSet&lt;Character&gt; set&#x3D; new HashSet&lt;&gt;();        for(int i&#x3D;k;i&lt;c.length;i++)&#123;            if(!set.contains(c[i]))&#123;                set.add(c[i]);                swap(c,i,k);                dfs(c,k+1);                swap(c,i,k);            &#125;        &#125;        &#x2F;&#x2F;这个题还没有    &#125;    public void swap(char[] c,int x,int y)&#123;        char  temp&#x3D;c[x];        c[x]&#x3D;c[y];        c[y]&#x3D;temp;    &#125;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p> 二叉树的中序遍历</p><p> 给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><p> </p><p>示例 1：</p><p>输入：root = [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：root = []<br>输出：[]<br>示例 3：</p><p>输入：root = [1]<br>输出：[1]<br>示例 4：</p><p>输入：root = [1,2]<br>输出：[2,1]<br>示例 5：</p><p>输入：root = [1,null,2]<br>输出：[1,2]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;        &#x2F;&#x2F;搞个列表         ArrayList&lt;Integer&gt; list &#x3D;new  ArrayList&lt;Integer&gt;();         &#x2F;&#x2F;如果为空就返回空         if(root&#x3D;&#x3D;null)&#123;             return list;         &#125;        rebuildTree(root,list);        return list;    &#125;    public void rebuildTree(TreeNode root,ArrayList&lt;Integer&gt; list)&#123;        &#x2F;&#x2F;如果为空就是返回这个是定递归的退出条件        if(root&#x3D;&#x3D;null)&#123;           return;        &#125;        &#x2F;&#x2F;如果左子树不为空 那么就将左子树放进去        if(root.left!&#x3D;null)&#123;        rebuildTree(root.left,list);        &#125;        &#x2F;&#x2F;放一个根节点        list.add(root.val);        &#x2F;&#x2F;如果右子树不为空 那么就将右子树放进去        if(root.right!&#x3D;null)&#123;        rebuildTree(root.right,list);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证二叉搜索树</p><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。 </p><p>示例 1：</p><p>输入：root = [2,1,3]<br>输出：true<br>示例 2：</p><p>输入：root = [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 </p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        &#x2F;&#x2F;递归  传一个最小和一个最大        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);    &#125;    public boolean isValidBST(TreeNode node, long lower, long upper) &#123;        &#x2F;&#x2F;如果为空返回true        if (node &#x3D;&#x3D; null) &#123;            return true;        &#125;    &#x2F;&#x2F;这个值小于下界 或者这个值大于上界就返回false        if (node.val &lt;&#x3D; lower || node.val &gt;&#x3D; upper) &#123;            return false;        &#125;        &#x2F;&#x2F;继续分隔两边的根进行        return isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的层序遍历</p><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p> </p><p>示例 1：</p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p><p>输入：root = [1]<br>输出：[[1]]<br>示例 3：</p><p>输入：root = []<br>输出：[]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;     ArrayList&lt;List&lt;Integer&gt;&gt; list&#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();            &#x2F;&#x2F; 如果为空 返回空            if(root&#x3D;&#x3D;null)&#123;                return list;            &#125;        &#x2F;&#x2F;队列        LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();        &#x2F;&#x2F;先加一个根进去        queue.add(root);        &#x2F;&#x2F;当根不为空的时候        while(!queue.isEmpty())&#123;            ArrayList&lt;Integer&gt; tempList&#x3D;new ArrayList&lt;Integer&gt;();            &#x2F;&#x2F;先拿出目前长度            int size&#x3D;queue.size();            &#x2F;&#x2F;长度大于0的时候            while(size&gt;0)&#123;                &#x2F;&#x2F;从队列中拉一个出来            TreeNode node&#x3D;queue.poll();            &#x2F;&#x2F;放进去列表中            tempList.add(node.val);            &#x2F;&#x2F;队列的左边不为空 加入            if(node.left!&#x3D;null)&#123;                queue.add(node.left);            &#125;            &#x2F;&#x2F;队列的右边不为空 加入            if(node.right!&#x3D;null)&#123;                queue.add(node.right);            &#125;            &#x2F;&#x2F;长度一直在递减              --size;            &#125;            &#x2F;&#x2F;列表加入这个字符串            list.add(tempList);        &#125;        &#x2F;&#x2F;列表返回        return list;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>平衡二叉树</p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p><p> </p><p>示例 1：</p><p>输入：root = [3,9,20,null,null,15,7]<br>输出：true<br>示例 2：</p><p>输入：root = [1,2,2,3,3,null,null,4,4]<br>输出：false<br>示例 3：</p><p>输入：root = []<br>输出：true</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public boolean isBalanced(TreeNode root) &#123;        &#x2F;&#x2F;如果为空那么可以            if(root&#x3D;&#x3D;null)&#123;                return true;            &#125;        &#x2F;&#x2F;左右子树的深度            int left&#x3D;depth(root.left);            int right&#x3D;depth(root.right);            &#x2F;&#x2F;还有子树的左右子树也需要是平衡树            return Math.abs(left-right)&lt;&#x3D;1&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);    &#125;&#x2F;&#x2F;算出以一个树为基础的深度为多少    public int depth(TreeNode root)&#123;            if(root&#x3D;&#x3D;null)&#123;                return 0;            &#125;            return Math.max(depth(root.left),depth(root.right))+1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求根节点到叶节点数字之和</p><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。</p><p> </p><p>示例 1：</p><p>输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25<br>示例 2：</p><p>输入：root = [4,9,0,5,1]<br>输出：1026<br>解释：<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>从根到叶子节点路径 4-&gt;0 代表数字 40<br>因此，数字总和 = 495 + 491 + 40 = 1026</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public int sumNumbers(TreeNode root) &#123;            return count(root,0);    &#125;    &#x2F;&#x2F;递归调用左边和右边相加    int count(TreeNode root,int sum)&#123;            if(root&#x3D;&#x3D;null)&#123;                return 0;            &#125;else if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)&#123;                return sum*10+root.val;            &#125;else&#123;                return count(root.left,sum*10+root.val)+count(root.right,sum*10+root.val);            &#125;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的前序遍历</p><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p> </p><p>示例 1：</p><p>输入：root = [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p><p>输入：root = []<br>输出：[]<br>示例 3：</p><p>输入：root = [1]<br>输出：[1]<br>示例 4：</p><p>输入：root = [1,2]<br>输出：[1,2]<br>示例 5：</p><p>输入：root = [1,null,2]<br>输出：[1,2]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        &#x2F;&#x2F;搞个列表        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();        &#x2F;&#x2F;如果为空就直接返回        if(root&#x3D;&#x3D;null)&#123;            return list;        &#125;        &#x2F;&#x2F;递归        createTree(root,list);        return list;    &#125;    public void  createTree(TreeNode root, ArrayList list)&#123;            if(root&#x3D;&#x3D;null)&#123;                return;            &#125;            &#x2F;&#x2F;注意顺序 先序就把根放前面            list.add(root.val);            &#x2F;&#x2F;如果左子树不为空 递归左子树            if(root.left!&#x3D;null)&#123;                createTree(root.left,list);            &#125;            &#x2F;&#x2F;如果右子树不为空 递归右子树            if(root.right!&#x3D;null)&#123;                createTree(root.right,list);            &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的后序遍历</p><p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 </p><p>示例 1：</p><p>输入：root = [1,null,2,3]<br>输出：[3,2,1]</p><p>示例 2：</p><p>输入：root = []<br>输出：[]<br>示例 3：</p><p>输入：root = [1]<br>输出：[1]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    &#x2F;&#x2F;这个题跟前序遍历 和中序遍历原理一模一样    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;            ArrayList&lt;Integer&gt; list&#x3D; new ArrayList&lt;Integer&gt;();            if(root&#x3D;&#x3D;null)&#123;                return list;            &#125;            createTree(root,list);            return list;    &#125;    public void createTree(TreeNode root,ArrayList list)&#123;        if(root&#x3D;&#x3D;null)&#123;            return ;        &#125;        if(root.left!&#x3D;null)&#123;            createTree(root.left,list);        &#125;        if(root.right!&#x3D;null)&#123;            createTree(root.right,list);        &#125;        list.add(root.val);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的右视图</p><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>示例 1:</p><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br>示例 2:</p><p>输入: [1,null,3]<br>输出: [1,3]<br>示例 3:</p><p>输入: []<br>输出: []</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;    &#x2F;&#x2F;搞一个作为结果     ArrayList&lt;Integer&gt; result&#x3D;new ArrayList&lt;Integer&gt;();     if(root&#x3D;&#x3D;null)&#123;         return result;     &#125;     &#x2F;&#x2F;搞个列表存储     ArrayList&lt;List&lt;Integer&gt;&gt; list&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;();    &#x2F;&#x2F;搞个队列     LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D; new LinkedBlockingQueue&lt;TreeNode&gt;();     &#x2F;&#x2F;队列接入一个根     queue.add(root);     &#x2F;&#x2F;根不为空的时候  这个模型就是把树转成了列表     while(!queue.isEmpty())&#123;         int size&#x3D;queue.size();        ArrayList&lt;Integer&gt; tempList&#x3D; new ArrayList&lt;Integer&gt;();         while(size&gt;0)&#123;            TreeNode tree&#x3D;queue.poll();            if(tree.left!&#x3D;null)&#123;                queue.add(tree.left);            &#125;            if(tree.right!&#x3D;null)&#123;                queue.add(tree.right);            &#125;            tempList.add(tree.val);             size--;         &#125;         list.add(tempList);     &#125;        &#x2F;&#x2F;把列表的最后一个放进另外一个列表即可     for(int i&#x3D;0;i&lt;list.size();i++)&#123;        List&lt;Integer&gt; tempList&#x3D;list.get(i);         result.add(tempList.get(tempList.size()-1));      &#125;          return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完全二叉树的节点个数</p><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p> </p><p>示例 1：</p><p>输入：root = [1,2,3,4,5,6]<br>输出：6<br>示例 2：</p><p>输入：root = []<br>输出：0<br>示例 3：</p><p>输入：root = [1]<br>输出：1</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public int countNodes(TreeNode root) &#123;        &#x2F;&#x2F;如果为空 那么返回0        if(root&#x3D;&#x3D;null)&#123;            return 0;        &#125;    &#x2F;&#x2F;搞一个队列     LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();    &#x2F;&#x2F;队列加入一个根节点    queue.add(root);    &#x2F;&#x2F;列表     ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();     &#x2F;&#x2F;当队列不为空的时候        while(!queue.isEmpty())&#123;            &#x2F;&#x2F;队列长度            int size&#x3D;queue.size();            &#x2F;&#x2F;当大小大于0            while(size&gt;0)&#123;               TreeNode tree&#x3D;queue.poll();               &#x2F;&#x2F;将左右子树加入                if(tree.left!&#x3D;null)&#123;                    queue.add(tree.left);                &#125;                if(tree.right!&#x3D;null)&#123;                    queue.add(tree.right);                &#125;                &#x2F;&#x2F;列表加入                list.add(tree.val);                size--;            &#125;        &#125;        &#x2F;&#x2F;这个数字就是节点的数字            return list.size();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉搜索树中第K小的元素</p><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p><p> </p><p>示例 1：</p><p>输入：root = [3,1,4,null,2], k = 1<br>输出：1<br>示例 2：</p><p>输入：root = [5,3,6,2,4,null,null,1], k = 3<br>输出：3</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public int kthSmallest(TreeNode root, int k) &#123;         ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();        if(root&#x3D;&#x3D;null)&#123;            return 0;        &#125;        &#x2F;&#x2F;这个还是那个层次遍历的模型 然后搞成一个列表 然后搞成一个数组，然后对数组进行排序 然后 就可以看到第k小的数字了        LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();        queue.add(root);        while(!queue.isEmpty())&#123;            int size&#x3D;queue.size();             while(size&gt;0)&#123;                TreeNode tree&#x3D; queue.poll();                            if(tree.left!&#x3D;null)&#123;                    queue.add(tree.left);                &#125;                if(tree.right!&#x3D;null)&#123;                    queue.add(tree.right);                &#125;                 list.add(tree.val);                --size;            &#125;        &#125;        int[] arr&#x3D;new int[list.size()];        for(int i&#x3D;0;i&lt;list.size();i++)&#123;            arr[i]&#x3D;list.get(i);        &#125;        Arrays.sort(arr);        return arr[k-1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的最近公共祖先</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p> </p><p>示例 1：</p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p><p>输入：root = [1,2], p = 1, q = 2<br>输出：1</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;     HashMap&lt;Integer, TreeNode&gt; parent &#x3D; new HashMap&lt;&gt;();    HashSet&lt;Integer&gt; visited &#x3D; new HashSet&lt;&gt;();    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        dfs(root);        while (p !&#x3D; null) &#123;            visited.add(p.val);            p &#x3D; parent.get(p.val);        &#125;        while (q !&#x3D; null) &#123;            if (visited.contains(q.val)) &#123;                return q;            &#125;            &#x2F;&#x2F;从下往上访问父节点  map存的是父节点            q &#x3D; parent.get(q.val);        &#125;        return null;    &#125;          public void dfs(TreeNode root) &#123;        if (root.left !&#x3D; null) &#123;            parent.put(root.left.val, root);            dfs(root.left);        &#125;        if (root.right !&#x3D; null) &#123;            parent.put(root.right.val, root);            dfs(root.right);        &#125;        &#x2F;&#x2F;没看懂    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的直径</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p> </p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    int ans;    public int diameterOfBinaryTree(TreeNode root) &#123;        ans &#x3D; 1;        depth(root);        return ans - 1;    &#125;    public int depth(TreeNode node) &#123;        if (node &#x3D;&#x3D; null) &#123;            return 0; &#x2F;&#x2F; 访问到空节点了，返回0        &#125;        int L &#x3D; depth(node.left); &#x2F;&#x2F; 左儿子为根的子树的深度        int R &#x3D; depth(node.right); &#x2F;&#x2F; 右儿子为根的子树的深度        ans &#x3D; Math.max(ans, L+R+1); &#x2F;&#x2F; 计算d_node即L+R+1 并更新ans        return Math.max(L, R) + 1; &#x2F;&#x2F; 返回该节点为根的子树的深度    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并二叉树</p><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。</p><p> </p><p>示例 1：</p><p>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<br>示例 2：</p><p>输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;        &#x2F;&#x2F;如果2为空 返回1        if(root2&#x3D;&#x3D;null)&#123;               return root1;        &#125;        &#x2F;&#x2F;如果1位空 返回2        if(root1&#x3D;&#x3D;null)&#123;               return root2;        &#125;        &#x2F;&#x2F;如果都不会空 相加        root1.val&#x3D;root1.val+root2.val;        &#x2F;&#x2F;递归 左边和左边        root1.left&#x3D;mergeTrees(root1.left,root2.left);        &#x2F;&#x2F;递归 右边和右边        root1.right&#x3D;mergeTrees(root1.right,root2.right);        return root1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的镜像</p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p>     4<br>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：</p><p>     4<br>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p><p> </p><p>示例 1：</p><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public TreeNode mirrorTree(TreeNode root) &#123;        &#x2F;&#x2F;如果为空那么返回为空         if(root&#x3D;&#x3D;null)&#123;            return null;          &#125;            &#x2F;&#x2F;这个本质上是调换两个子树            TreeNode leftTree&#x3D; root.left;            TreeNode temp&#x3D;leftTree;            root.left&#x3D; root.right;            root.right&#x3D;temp;            &#x2F;&#x2F;然后递归继续去换子树            mirrorTree(root.left);            mirrorTree(root.right);        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对称的二叉树</p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>    1<br>   / <br>  2   2<br>   \   <br>   3    3</p><p> </p><p>示例 1：</p><p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        &#x2F;&#x2F;如果为空也是一个镜像函数          if(root&#x3D;&#x3D;null)&#123;              return true;          &#125;            &#x2F;&#x2F;判断是否镜像        return isSame(root,root);    &#125;    public boolean isSame(TreeNode root,TreeNode monitorTree)&#123;        &#x2F;&#x2F;如果为空可以       if(root&#x3D;&#x3D;null&amp;&amp;monitorTree&#x3D;&#x3D;null)&#123;           return true;       &#125;        &#x2F;&#x2F;如果有一个不为空 一个为空不行       if(root&#x3D;&#x3D;null||monitorTree&#x3D;&#x3D;null)&#123;           return false;       &#125;        &#x2F;&#x2F;如果值相等 那么  对应镜像的值去匹配  左子树的跟另外一个右子树比 右子树的跟左子树比        if(root.val&#x3D;&#x3D;monitorTree.val)&#123;            return isSame(root.left,monitorTree.right)&amp;&amp;isSame(root.right,monitorTree.left);        &#125;else&#123;            return false;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上到下打印二叉树 II</p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p> </p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        &#x2F;&#x2F;存储结果的列表       ArrayList&lt;List&lt;Integer&gt;&gt;  result&#x3D;    new ArrayList&lt;List&lt;Integer&gt;&gt;();       &#x2F;&#x2F;如果为空的话 直接返回       if(root&#x3D;&#x3D;null)&#123;           return result;       &#125;        LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D; new LinkedBlockingQueue&lt;TreeNode&gt;();        &#x2F;&#x2F;队列中放进一个根的数值        queue.add(root);        &#x2F;&#x2F;如果不为空那么就继续        while(!queue.isEmpty())&#123;            &#x2F;&#x2F;先取出当期的队列长度            int size &#x3D;queue.size();            &#x2F;&#x2F;搞一个列表            ArrayList&lt;Integer&gt; tempList&#x3D;new ArrayList&lt;Integer&gt;();            &#x2F;&#x2F;如果队列长度大于0            while(size&gt;0)&#123;                 &#x2F;&#x2F;从队列中搞一个出来                TreeNode tree&#x3D;queue.poll();                &#x2F;&#x2F;如果左子树不为空就放进去                if(tree.left!&#x3D;null)&#123;                    queue.add(tree.left);                &#125;                &#x2F;&#x2F;如果右子树不为空也放进去                if(tree.right!&#x3D;null)&#123;                    queue.add(tree.right);                &#125;                &#x2F;&#x2F;把值放到一个列表之中                tempList.add(tree.val);                &#x2F;&#x2F;大小减一                   --size;            &#125;            &#x2F;&#x2F;将结果返回回去            result.add(tempList);        &#125;        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上到下打印二叉树 III</p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p> </p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;        &#x2F;&#x2F;搞一个结果的列表       ArrayList&lt;List&lt;Integer&gt;&gt;  result&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;();       &#x2F;&#x2F;如果为空返回        if(root&#x3D;&#x3D;null)&#123;            return result;        &#125;        &#x2F;&#x2F;这个是要不要反转的标志        boolean flag&#x3D;false;        &#x2F;&#x2F;队列      LinkedBlockingQueue&lt;TreeNode&gt; queue &#x3D; new LinkedBlockingQueue&lt;TreeNode&gt;();      &#x2F;&#x2F;先放一个根目录      queue.add(root);        &#x2F;&#x2F;当队列不为空的时候        while(!queue.isEmpty())&#123;            &#x2F;&#x2F;队列长度            int size&#x3D;queue.size();            &#x2F;&#x2F;临时的数组长度        ArrayList&lt;Integer&gt; list&#x3D;new  ArrayList&lt;Integer&gt;();            while(size&gt;0)&#123;                &#x2F;&#x2F;从队列拿出第一个                TreeNode tree&#x3D;queue.poll();                &#x2F;&#x2F;如果存在左右子树就放进去                if(tree.left!&#x3D;null)&#123;                    queue.add(tree.left);                &#125;                if(tree.right!&#x3D;null)&#123;                    queue.add(tree.right);                &#125;                &#x2F;&#x2F;列表放这个数的值                list.add(tree.val);                &#x2F;&#x2F;                --size;            &#125;            &#x2F;&#x2F;控制是否需要反转          if(flag)&#123;            Collections.reverse(list);          &#125;          &#x2F;&#x2F;标志位取反          flag&#x3D;!flag;          &#x2F;&#x2F;将结果加进去           result.add(list);        &#125;        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树中和为某一值的路径</p><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p> </p><p>示例 1：</p><p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p><p>输入：root = [1,2,3], targetSum = 5<br>输出：[]<br>示例 3：</p><p>输入：root = [1,2], targetSum = 0<br>输出：[]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val &#x3D; val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val &#x3D; val; *         this.left &#x3D; left; *         this.right &#x3D; right; *     &#125; * &#125; *&#x2F;class Solution &#123;    &#x2F;&#x2F;搞个结果的容器    List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123;        &#x2F;&#x2F;深度优先        dfs(root,target,new ArrayList());        return result;    &#125;    public void dfs(TreeNode root, int target,List list)&#123;        &#x2F;&#x2F;如果为空的话就返回            if(root&#x3D;&#x3D;null)&#123;                return ;            &#125;            &#x2F;&#x2F;列表加入根的值            list.add(root.val);            &#x2F;&#x2F;如果这个值是跟目标匹配            if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null&amp;&amp;root.val&#x3D;&#x3D;target)&#123;                result.add(new ArrayList&lt;&gt;(list));            &#125;            &#x2F;&#x2F;进行左边和右边目标值            dfs(root.left,target-root.val,list);            dfs(root.right,target-root.val,list);            &#x2F;&#x2F;列表删除前面那个            list.remove(list.size()-1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二叉树的深度</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public int maxDepth(TreeNode root) &#123;    &#x2F;&#x2F;搞一个队列来存树    LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();    if(root&#x3D;&#x3D;null)&#123;        return 0;    &#125;    &#x2F;&#x2F;先加一个根进去    queue.add(root);    &#x2F;&#x2F;深度为0    int depth&#x3D;0;    &#x2F;&#x2F;当队列不为空的时候继续搞    while(!queue.isEmpty())&#123;        int size &#x3D; queue.size();        &#x2F;&#x2F;当队列长度大于0的时候        while(size&gt;0)&#123;            &#x2F;&#x2F;队列搞一个出来           TreeNode tree&#x3D; queue.poll();           &#x2F;&#x2F;当队列不为空  队列加入            if(tree.left!&#x3D;null)&#123;                queue.add(tree.left);            &#125;            &#x2F;&#x2F;当队列不为空 队列加入            if(tree.right!&#x3D;null)&#123;                queue.add(tree.right);            &#125;            &#x2F;&#x2F;队列递减            size--;        &#125;        &#x2F;&#x2F;当走出一个循环的时候 深度会加1        depth++;    &#125;    return depth;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>平衡二叉树</p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p> </p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><pre><code>3</code></pre><p>   / <br>  9  20<br>    /  <br>   15   7<br>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><pre><code>   1  / \ 2   2/ \</code></pre><p>   3   3<br>  / <br> 4   4<br>返回 false 。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public boolean isBalanced(TreeNode root) &#123;        if(root&#x3D;&#x3D;null)&#123;            return true;        &#125;        &#x2F;&#x2F;         &#x2F;&#x2F;左树的最大深度        int left&#x3D;depth(root.left);        &#x2F;&#x2F;右子树的最大深度        int right&#x3D;depth(root.right);        &#x2F;&#x2F;其实就是一直找 以这个根为节点的左右最大深度        return Math.abs(left-right)&lt;&#x3D;1&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);    &#125;        &#x2F;&#x2F;这个功能主要是以某一个根为节点的最大深度    public int depth(TreeNode root)&#123;            if(root&#x3D;&#x3D;null)&#123;                return 0;            &#125;            return Math.max(depth(root.left),depth(root.right))+1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求和路径</p><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p>返回:</p><p>3<br>解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();    public int pathSum(TreeNode root, int sum) &#123;        &#x2F;&#x2F;当根为空的时候 返回0        if(root&#x3D;&#x3D;null)&#123;            return 0;        &#125;        &#x2F;&#x2F;深度优先        dfs(root,sum,new ArrayList());         &#x2F;&#x2F;而且要递归根的左边和右边        pathSum(root.left,sum);        &#x2F;&#x2F;递归根的左边和右边        pathSum(root.right,sum);        return result.size();    &#125;    &#x2F;&#x2F;深度优先的套路 这个模型主要是用来解决路径的值等于某一个值的    public void dfs(TreeNode root,int target,ArrayList list)&#123;        &#x2F;&#x2F;如果为空返回        if(root&#x3D;&#x3D;null)&#123;            return;        &#125;        &#x2F;&#x2F;列表加入一个值        list.add(root.val);           &#x2F;&#x2F;深度递归 将目标值改成目标值减去树的根值        dfs(root.left,target-root.val,list);        dfs(root.right,target-root.val,list);        &#x2F;&#x2F;如果目标等于跟的值 那么这个结果加入列表        if(target&#x3D;&#x3D;root.val)&#123;            result.add(new ArrayList(list));        &#125;        &#x2F;&#x2F;将值减去1 达到一个回溯的效果        list.remove(list.size()-1);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p> </p><p>示例 1：</p><p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br>示例 2：</p><p>输入：head = [1], n = 1<br>输出：[]<br>示例 3：</p><p>输入：head = [1,2], n = 1<br>输出：[1]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        &#x2F;&#x2F;基本的思路就是把链表转成数组 然后删掉倒数几个 然后再把数组还原回去          ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();         while(head!&#x3D;null)&#123;             list.add(head.val);             head&#x3D;head.next;         &#125;        list.remove(list.size()-n);                   if(list.size()&lt;&#x3D;0)&#123;            return null;        &#125;                ListNode root&#x3D;new  ListNode(list.get(0));        ListNode index&#x3D;root;        for(int i&#x3D;1;i&lt;list.size();i++)&#123;            System.out.print(list.get(i));            ListNode  temp &#x3D;  new ListNode(list.get(i));            index.next&#x3D;temp;            index&#x3D;temp;        &#125;        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并两个有序链表</p><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p> </p><p>示例 1：</p><p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p><p>输入：l1 = [], l2 = []<br>输出：[]<br>示例 3：</p><p>输入：l1 = [], l2 = [0]<br>输出：[0]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;        &#x2F;&#x2F;如果list2 为空 返回list1        if(list2&#x3D;&#x3D;null)&#123;            return list1;        &#125;        &#x2F;&#x2F;如果list1为空返回list2        if(list1&#x3D;&#x3D;null)&#123;            return list2;        &#125;        &#x2F;&#x2F;搞两个数组存储       ArrayList&lt;Integer&gt; arrayList1&#x3D; new ArrayList&lt;Integer&gt;();       ArrayList&lt;Integer&gt; arrayList2&#x3D; new ArrayList&lt;Integer&gt;();        &#x2F;&#x2F;当列表不为空的时候 装进去数组        while(list1!&#x3D;null)&#123;               arrayList1.add(list1.val);               list1&#x3D;list1.next;         &#125;          &#x2F;&#x2F;当列表2不为空的时候装进去数组        while(list2!&#x3D;null)&#123;            arrayList2.add(list2.val);            list2&#x3D;list2.next;        &#125;        int length&#x3D;arrayList1.size()+arrayList2.size();        int[] arr&#x3D;new int[length];        &#x2F;&#x2F;搞一个可以容纳这么多的数组        for(int i&#x3D;0;i&lt;arrayList1.size();i++)&#123;            arr[i]&#x3D;arrayList1.get(i);        &#125;        &#x2F;&#x2F;都装进去        for(int i&#x3D;arrayList1.size();i&lt;(arrayList1.size()+arrayList2.size());i++)&#123;            arr[i]&#x3D;arrayList2.get(i-arrayList1.size());        &#125;        &#x2F;&#x2F;对数组进行排序        Arrays.sort(arr);       ListNode root&#x3D; new ListNode(arr[0]);       ListNode tempNode&#x3D;root;        &#x2F;&#x2F;将 数组按列表复原        for(int i&#x3D;1;i&lt;arr.length;i++)&#123;        ListNode node&#x3D; new ListNode(arr[i]);        tempNode.next&#x3D;node;        tempNode&#x3D;node;        &#125;        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>合并K个升序链表</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p> </p><p>示例 1：</p><p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p><p>输入：lists = []<br>输出：[]<br>示例 3：</p><p>输入：lists = [[]]<br>输出：[]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    &#x2F;&#x2F;思路还是将 链表转成了所有数组 然后组装回去一个链表    public ListNode mergeKLists(ListNode[] lists) &#123;        if(lists&#x3D;&#x3D;null||lists.length&#x3D;&#x3D;0||(lists.length&#x3D;&#x3D;1&amp;&amp;lists[0]&#x3D;&#x3D;null))&#123;            return null;        &#125;      ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();      for(int i&#x3D;0;i&lt;lists.length;i++)&#123;        ListNode node&#x3D;  lists[i];        while(node!&#x3D;null)&#123;            list.add(node.val);            node&#x3D;node.next;        &#125;      &#125;        int length&#x3D;list.size();        if(length&lt;&#x3D;0)&#123;            return null;        &#125;        int[] arr &#x3D; new int[length];        for(int i&#x3D;0;i&lt;list.size();i++)&#123;            arr[i]&#x3D;list.get(i);        &#125;        Arrays.sort(arr);         ListNode root&#x3D; new ListNode(arr[0]);      ListNode index&#x3D;root;      for(int i&#x3D;1;i&lt;arr.length;i++)&#123;          System.out.print(arr[i]);         ListNode node&#x3D; new ListNode(arr[i]);         index.next&#x3D;node;         index&#x3D;node;      &#125;        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除排序链表中的重复元素 II</p><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p><p> </p><p>示例 1：</p><p>输入：head = [1,2,3,3,4,4,5]<br>输出：[1,2,5]<br>示例 2：</p><p>输入：head = [1,1,1,2,3]<br>输出：[2,3]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null)&#123;            return head;        &#125;        HashMap&lt;Integer,Integer&gt; map&#x3D; new HashMap&lt;Integer,Integer&gt;();        ArrayList&lt;Integer&gt;  list&#x3D; new ArrayList&lt;&gt;();        while(head!&#x3D;null)&#123;            if(!list.contains(head.val))&#123;                list.add(head.val);            &#125;            if(map.get(head.val)&#x3D;&#x3D;null)&#123;                map.put(head.val,1);            &#125;else&#123;                map.put(head.val,map.get(head.val)+1);            &#125;            head&#x3D;head.next;        &#125;        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;list.size();i++)&#123;        &#x2F;&#x2F;     System.out.print(list.get(i));        &#x2F;&#x2F;     System.out.print(map.get(list.get(i)));        &#x2F;&#x2F; &#125;        ListNode result&#x3D;null;        ListNode index&#x3D;null;        for(int i&#x3D;0;i&lt;list.size();i++)&#123;             if(map.get(list.get(i))&#x3D;&#x3D;1)&#123;                if(result&#x3D;&#x3D;null)&#123;                    result&#x3D; new ListNode(list.get(i));                    index&#x3D;result;                &#125;else&#123;                    System.out.print(list.get(i));                     ListNode temp&#x3D; new ListNode(list.get(i));                     index.next&#x3D;temp;                     index&#x3D;index.next;                &#125;                          &#125;        &#125;        &#x2F;&#x2F;暂时没有时间看看        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除排序链表中的重复元素</p><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><p> </p><p>示例 1：</p><p>输入：head = [1,1,2]<br>输出：[1,2]<br>示例 2：</p><p>输入：head = [1,1,2,3,3]<br>输出：[1,2,3]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;     public ListNode deleteDuplicates(ListNode head) &#123;        if(head&#x3D;&#x3D;null)&#123;            return null;        &#125;        &#x2F;&#x2F;当node不为空的时候就会往下移动，但是只有当下一个不等于当前这个的时候才会移动           ListNode temp&#x3D;head;           while(temp!&#x3D;null)&#123;               if(temp.next!&#x3D;null)&#123;                   if(temp.val&#x3D;&#x3D;temp.next.val)&#123;                       temp.next&#x3D;temp.next.next;                   &#125;               &#125;               if(temp.next&#x3D;&#x3D;null||temp.next.val!&#x3D;temp.val)&#123;                    temp&#x3D;temp.next;               &#125;                                              &#125;        return head;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反转链表 II</p><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 </p><p>示例 1：</p><p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]<br>示例 2：</p><p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode reverseBetween(ListNode head, int left, int right) &#123;        ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();        ListNode temp&#x3D;head;        while(temp!&#x3D;null)&#123;            list.add(temp.val);            temp&#x3D;temp.next;        &#125;        int[] arr&#x3D;new int[list.size()];       for(int i&#x3D;0;i&lt;list.size();i++)&#123;            arr[i]&#x3D;list.get(i);        &#125;              for(int i&#x3D;0;i&lt;(right-left+1)&#x2F;2;i++)&#123;          int tempValue&#x3D;arr[left+i-1];          arr[left+i-1]&#x3D;arr[right-i-1];          arr[right-i-1]&#x3D;tempValue;       &#125;        for(int i&#x3D;0;i&lt;list.size();i++)&#123;             System.out.print(arr[i]);        &#125;               ListNode result&#x3D;null;        ListNode index&#x3D;null;        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;                if(result&#x3D;&#x3D;null)&#123;                    result&#x3D; new ListNode(arr[i]);                    index&#x3D;result;                &#125;else&#123;                    index.next&#x3D;new ListNode(arr[i]);                    index&#x3D;index.next;                &#125;        &#125;        &#x2F;&#x2F;没有看懂               return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>环形链表</p><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val &#x3D; x; *         next &#x3D; null; *     &#125; * &#125; *&#x2F;public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;      &#x2F;&#x2F;如果为空那就返回      if(head&#x3D;&#x3D;null)&#123;          return false;      &#125;     ListNode temp;     &#x2F;&#x2F;将链表放在中间      temp&#x3D;head;      &#x2F;&#x2F;搞两个中间件      ListNode temp1&#x3D;temp;      ListNode temp2&#x3D;temp;      &#x2F;&#x2F;当这个不为空或者下一个不为空      while(temp2!&#x3D;null&amp;&amp;temp2.next!&#x3D;null)&#123;          temp1&#x3D;temp1.next;          temp2&#x3D;temp2.next.next;          &#x2F;&#x2F;如果是环形的话他们就一定会重复 如果不是环形的 那么跑一次就没有了          if(temp1&#x3D;&#x3D;temp2)&#123;              return true;          &#125;      &#125;      return  false;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LRU 缓存</p><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p> </p><p>示例：</p><p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p><pre class="line-numbers language-none"><code class="language-none">class LRUCache &#123;    &#x2F;&#x2F;要搞这个LUR需要搞一个map加一个双向链表    private int capacity;    &#x2F;&#x2F;容量大小    private int size &#x3D; 0;    &#x2F;&#x2F;map    private Map&lt;Integer, Entry&gt; cache &#x3D; new HashMap&lt;Integer, Entry&gt;();    &#x2F;&#x2F;这个是双向链表的头和尾    private Entry head, tail;    public LRUCache(int capacity) &#123;        this.capacity &#x3D; capacity;        this.size &#x3D; 0;        head &#x3D; new Entry();        tail &#x3D; new Entry();        head.next &#x3D; tail;        tail.prev &#x3D; head;    &#125;&#x2F;&#x2F;  获取的时候从map取出来 发现为空就返回 不为空就插入到头那边    public int get(int key) &#123;        Entry node &#x3D; cache.get(key);        if (node &#x3D;&#x3D; null) &#123;            return -1;        &#125;        moveToHead(node);        return node.value;    &#125;    &#x2F;&#x2F;插入到头那边就是先从尾巴删掉 然后加入到头那边    private void moveToHead(Entry node) &#123;        removeNode(node);        addToHead(node);    &#125;    &#x2F;&#x2F;加入到头那边  添加节点就是 这个节点的前一个为头，节点的下一个是头的下一个  头的前一个为这个  头的下一个为这个    private void addToHead(Entry node) &#123;        node.prev &#x3D; head;        node.next &#x3D; head.next;        head.next.prev &#x3D; node;        head.next &#x3D; node;    &#125;    &#x2F;&#x2F;删除这个节点   删除节点就是 这个节点的前面的下一个变成这的下一个    这个节点的下一个的前一个变成节点的前一个    private void removeNode(Entry node) &#123;        node.prev.next &#x3D; node.next;        node.next.prev &#x3D; node.prev;    &#125;    &#x2F;&#x2F;放进去的话 从map拿出来 如果存在就刷新  如果不存在的话 就加入 加入的时候如果发现已经超过了最大的话那么就删掉最后一个    public void put(int key, int value) &#123;        Entry node &#x3D; cache.get(key);        if (node &#x3D;&#x3D; null) &#123;            &#x2F;&#x2F; 如果 key 不存在，创建一个新的节点            Entry newNode &#x3D; new Entry(key, value);            &#x2F;&#x2F; 添加进哈希表            cache.put(key, newNode);            &#x2F;&#x2F; 添加至双向链表的头部            addToHead(newNode);            ++size;            if (size &gt; capacity) &#123;                &#x2F;&#x2F; 如果超出容量，删除双向链表的尾部节点                Entry tail &#x3D; removeTail();                &#x2F;&#x2F; 删除哈希表中对应的项                cache.remove(tail.key);                --size;            &#125;        &#125; else &#123;            &#x2F;&#x2F; 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部            node.value &#x3D; value;            moveToHead(node);        &#125;    &#125;    &#x2F;&#x2F;删掉最后一个就是双向链表的尾结点的前一个    private Entry removeTail() &#123;        Entry res &#x3D; tail.prev;        removeNode(res);        return res;    &#125;    class Entry &#123;        int key;        int value;        Entry prev;        Entry next;        public Entry(int key, int value) &#123;            this.key &#x3D; key;            this.value &#x3D; value;        &#125;        public Entry() &#123;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排序链表</p><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p> </p><p>示例 1：</p><p>输入：head = [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p><p>输入：head = [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p><p>输入：head = []<br>输出：[]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode sortList(ListNode head) &#123;        if(head&#x3D;&#x3D;null)&#123;            return null;             &#125;    &#x2F;&#x2F;这个思路是把链表搞成数组 然后数组排序 然后再组装成链表      ArrayList&lt;Integer&gt; list&#x3D;  new ArrayList&lt;Integer&gt;();         while(head!&#x3D;null)&#123;             list.add(head.val);             head&#x3D;head.next;           &#125;            int[] arr&#x3D; new  int[list.size()];                      for(int i&#x3D;0;i&lt;list.size();i++)&#123;              arr[i]&#x3D;list.get(i);             &#125;                      Arrays.sort(arr);        ListNode root&#x3D;new ListNode(arr[0]);        ListNode index&#x3D;root;        for(int i&#x3D;1;i&lt;arr.length;i++)&#123;            System.out.print(arr[i]);             ListNode node&#x3D;   new ListNode(arr[i]);             index.next&#x3D;node;             index&#x3D;node;        &#125;        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>奇偶链表</p><p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><p> </p><p>示例 1:</p><p>输入: head = [1,2,3,4,5]<br>输出: [1,3,5,2,4]<br>示例 2:</p><p>输入: head = [2,1,3,5,6,4,7]<br>输出: [2,3,6,7,1,5,4]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode oddEvenList(ListNode head) &#123;        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null)&#123;            return head;        &#125;        ListNode l1&#x3D;new ListNode(0);        ListNode l2&#x3D;new ListNode(0);        ListNode tempHead&#x3D;head;        ListNode temp1&#x3D;l1;        ListNode temp2&#x3D;l2;        boolean isOdd&#x3D;true;                while(tempHead!&#x3D;null)&#123;        if(isOdd)&#123;                l1.next&#x3D;tempHead;                l1&#x3D;l1.next;            &#125;else&#123;                l2.next&#x3D;tempHead;                l2&#x3D;l2.next;            &#125;             isOdd&#x3D;!isOdd;            tempHead&#x3D;tempHead.next;        &#125;           if(l1.next!&#x3D;null)&#123;                l1.next&#x3D;null;            &#125;            if(l2.next!&#x3D;null)&#123;                l2.next&#x3D;null;            &#125;            l1.next&#x3D;temp2.next;            return temp1.next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两数相加 II</p><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p> </p><p>示例1：</p><p>输入：l1 = [7,2,4,3], l2 = [5,6,4]<br>输出：[7,8,0,7]<br>示例2：</p><p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[8,0,7]<br>示例3：</p><p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        &#x2F;&#x2F;搞两个栈来存储 因为刚好满足这个特性         Stack&lt;Integer&gt;  stack1&#x3D;    new Stack&lt;Integer&gt;();            Stack&lt;Integer&gt;  stack2&#x3D;    new Stack&lt;Integer&gt;();            while(l1!&#x3D;null)&#123;                stack1.push(l1.val);                l1&#x3D;l1.next;            &#125;            while(l2!&#x3D;null)&#123;                stack2.push(l2.val);                l2&#x3D;l2.next;            &#125;            &#x2F;&#x2F;进位的标志            int carry&#x3D;0;            &#x2F;&#x2F;根            ListNode head&#x3D;null;            while(!stack1.isEmpty()||!stack2.isEmpty()||carry&gt;0)&#123;                &#x2F;&#x2F;进位的                int sum&#x3D;carry;                &#x2F;&#x2F;从栈弹一个出来                sum+&#x3D;stack1.isEmpty()?0:stack1.pop();                &#x2F;&#x2F;从栈弹一个出来                sum+&#x3D; stack2.isEmpty()?0:stack2.pop();                &#x2F;&#x2F;只取一位                 ListNode node&#x3D;new ListNode(sum%10);                 &#x2F;&#x2F;下一位指向头                 node.next&#x3D;head;                 &#x2F;&#x2F;下一个                 head&#x3D;node;                 &#x2F;&#x2F;除以时                 carry&#x3D;sum&#x2F;10;            &#125;                &#x2F;&#x2F;返回这个头                return head;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链表中倒数第k个节点</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode getKthFromEnd(ListNode head, int k) &#123;    &#x2F;&#x2F;先把链表放到列表中      ArrayList&lt;ListNode&gt; list&#x3D;  new ArrayList&lt;ListNode&gt;();      while(head!&#x3D;null)&#123;          list.add(head);          head&#x3D;head.next;      &#125;      &#x2F;&#x2F;然后从列表中拿出倒数第几个元素     return  list.get(list.size()-k);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反转链表</p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p> </p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123;    public ListNode reverseList(ListNode head) &#123;    if(head&#x3D;&#x3D;null)&#123;        return head;    &#125;    &#x2F;&#x2F;先搞一个列表 将链表按值放进去     ArrayList&lt;Integer&gt; list&#x3D; new ArrayList&lt;Integer&gt;();        while(head!&#x3D;null)&#123;            list.add(head.val);            head&#x3D;head.next;        &#125;        &#x2F;&#x2F;对列表进行排序        Collections.reverse(list);        &#x2F;&#x2F; 把列表按链表的方式排序回来       ListNode root&#x3D; new ListNode(list.get(0));       ListNode index&#x3D;root;        for(int i&#x3D;1;i&lt;list.size();i++)&#123;            int temp&#x3D;list.get(i);            ListNode tree &#x3D;new ListNode(temp);            index.next&#x3D;tree;            index&#x3D;tree;        &#125;        return root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><p>在节点 c1 开始相交。</p><p> </p><p>示例 1：</p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 </p><p>示例 2：</p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 </p><p>示例 3：</p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val &#x3D; x; *         next &#x3D; null; *     &#125; * &#125; *&#x2F;public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        &#x2F;&#x2F;链表a 链表b            ListNode  headATemp&#x3D;headA;            ListNode  headBTemp&#x3D;headB;            &#x2F;&#x2F;当A 不为空的时候 取出一个A 遍历b 如果遍历到的了话 那么就返回回去            while(headATemp!&#x3D;null)&#123;                    while(headBTemp!&#x3D;null)&#123;                        if(headATemp&#x3D;&#x3D;headBTemp)&#123;                            return headATemp;                        &#125;                        headBTemp&#x3D;headBTemp.next;                    &#125;                    headBTemp&#x3D;headB;                headATemp&#x3D;headATemp.next;            &#125;            return null;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链表中环的入口节点</p><p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p> </p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val &#x3D; x; *         next &#x3D; null; *     &#125; * &#125; *&#x2F;public class Solution &#123;       public ListNode detectCycle(ListNode head) &#123;        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null)&#123;            return null;        &#125;        ListNode fastNode&#x3D;head;        ListNode slowNode&#x3D;head;        while(fastNode !&#x3D; null &amp;&amp; fastNode.next !&#x3D; null)&#123;            fastNode&#x3D;fastNode.next.next;            slowNode&#x3D;slowNode.next;            if(fastNode&#x3D;&#x3D;slowNode)&#123;                 fastNode &#x3D; head;                while(slowNode !&#x3D; fastNode)&#123;                    slowNode &#x3D; slowNode.next;                    fastNode &#x3D; fastNode.next;                &#125;                return slowNode;            &#125;                       &#125;        &#x2F;&#x2F;环在第一个        return null;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回文链表</p><p>给定一个链表的 头节点 head ，请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p><p> </p><p>示例 1：</p><p>输入: head = [1,2,3,3,2,1]<br>输出: true<br>示例 2：</p><p>输入: head = [1,2]<br>输出: false</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val &#x3D; val; &#125; *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125; * &#125; *&#x2F;class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        &#x2F;&#x2F;如果列表为空 返回false        if(head&#x3D;&#x3D;null)&#123;            return false;        &#125;        &#x2F;&#x2F;搞一个列表长度        ArrayList&lt;ListNode&gt; arr&#x3D;new ArrayList&lt;ListNode&gt;();        &#x2F;&#x2F;把链表搞成列表        while(head!&#x3D;null)&#123;            arr.add(head);            head&#x3D;head.next;        &#125;        &#x2F;&#x2F;看一下列表是不是一个回文树        for(int i&#x3D;0;i&lt;arr.size()&#x2F;2;i++)&#123;            if(arr.get(i).val!&#x3D;arr.get(arr.size()-1-i).val)&#123;                    return false;            &#125;        &#125;        return true;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>整数反转</p><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。 </p><p>示例 1：</p><p>输入：x = 123<br>输出：321<br>示例 2：</p><p>输入：x = -123<br>输出：-321<br>示例 3：</p><p>输入：x = 120<br>输出：21<br>示例 4：</p><p>输入：x = 0<br>输出：0</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int reverse(int x) &#123;        if(x&#x3D;&#x3D;0)&#123;            return 0;        &#125;        &#x2F;&#x2F;这个flag是用来标志负        boolean flag&#x3D;false;        &#x2F;&#x2F;如果小于0 就取反 标记这个负        if(x&lt;0)&#123;            flag&#x3D;true;            x&#x3D;-x;        &#125;        &#x2F;&#x2F;搞一个列表        ArrayList&lt;Integer&gt; list&#x3D; new ArrayList&lt;Integer&gt;();        &#x2F;&#x2F;把数字切割然后放到列表            while(x&gt;0)&#123;                int last&#x3D;x%10;                list.add(last);                    x&#x3D;x&#x2F;10;            &#125;            &#x2F;&#x2F;把列表还原 主要要判断如果大小大于integer 的最大值 那么久返回0            long result&#x3D;0;            for(int i&#x3D;0;i&lt;list.size();i++)&#123;                   if(result*10+list.get(i)&gt;Integer.MAX_VALUE)&#123;                       return 0;                   &#125;else&#123;                      result&#x3D;result*10+list.get(i);                    &#125;            &#125;            if(flag)&#123;                result&#x3D;-result;            &#125;        return (int)result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回文数</p><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><p> </p><p>示例 1：</p><p>输入：x = 121<br>输出：true<br>示例 2：</p><p>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3：</p><p>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。<br>示例 4：</p><p>输入：x = -101<br>输出：false</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public boolean isPalindrome(int x) &#123;        &#x2F;&#x2F;如果数值小于0那么返回false        if(x&lt;0)&#123;            return false;        &#125;        &#x2F;&#x2F;搞个列表      ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();        &#x2F;&#x2F;当数值大于0的时候 取余10  然后加入列表 然后除以10      while(x&gt;0)&#123;          int last&#x3D;x%10;          list.add(last);          x&#x3D;x&#x2F;10;      &#125;        &#x2F;&#x2F;然后就直接对比      for(int i&#x3D;0;i&lt;list.size()&#x2F;2;i++)&#123;          if(list.get(i)!&#x3D;list.get(list.size()-1-i))&#123;              return false;          &#125;      &#125;    return true;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> x 的平方根 </p><p> 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p> </p><p>示例 1：</p><p>输入：x = 4<br>输出：2<br>示例 2：</p><p>输入：x = 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int mySqrt(int x) &#123;        &#x2F;&#x2F;二分查找的思路          &#x2F;&#x2F;左边        int left&#x3D;0;        &#x2F;&#x2F;右边        int right&#x3D;x;        &#x2F;&#x2F;用来返回结果        int index&#x3D;0;        &#x2F;&#x2F;当左边小于右边的时候        while(left&lt;&#x3D;right)&#123;            &#x2F;&#x2F;获取中间的那一个            int mid&#x3D;left+(right-left)&#x2F;2;            &#x2F;&#x2F;中间的数平方 如果小于 从中间的左边算起 如果大于从中间右边算起            if((long)mid*mid&lt;&#x3D;x)&#123;                index&#x3D;mid;                left&#x3D;mid+1;            &#125;else&#123;                right&#x3D;mid-1;            &#125;        &#125;        &#x2F;&#x2F;返回下标        return index;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>阶乘后的零</p><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p><p>提示 n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p><p> </p><p>示例 1：</p><p>输入：n = 3<br>输出：0<br>解释：3! = 6 ，不含尾随 0<br>示例 2：</p><p>输入：n = 5<br>输出：1<br>解释：5! = 120 ，有一个尾随 0<br>示例 3：</p><p>输入：n = 0<br>输出：0</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int trailingZeroes(int n) &#123;        &#x2F;&#x2F;其实就是算5的个数             int zoreCount&#x3D;0;         while(n &gt;&#x3D; 5) &#123;            zoreCount +&#x3D; n &#x2F; 5;            n &#x2F;&#x3D; 5;          &#125;        return zoreCount;            &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>K 进制表示下的各位数字总和</p><p>给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。</p><p>转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。</p><p> </p><p>示例 1：</p><p>输入：n = 34, k = 6<br>输出：9<br>解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。<br>示例 2：</p><p>输入：n = 10, k = 10<br>输出：1<br>解释：n 本身就是 10 进制。 1 + 0 = 1 。</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int sumBase(int n, int k) &#123;        &#x2F;&#x2F;搞一个结果            int result&#x3D;0;            &#x2F;&#x2F;当n不等于0的时候            while(n!&#x3D;0)&#123;                &#x2F;&#x2F;结果等于结果加上n 余上k进制                result&#x3D;result+(n%k);                &#x2F;&#x2F;这个数出于k                n&#x3D;n&#x2F;k;            &#125;            return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用两个栈实现队列</p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p> </p><p>示例 1：</p><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p><pre class="line-numbers language-none"><code class="language-none">class CQueue &#123;    &#x2F;&#x2F;用两个栈来实现一个队列 就是先把栈的数据导出来 然后 弹出一个 然后在倒回去      Stack&lt;Integer&gt; firstStack&#x3D; new Stack&lt;Integer&gt;();        Stack&lt;Integer&gt; secondStack&#x3D; new Stack&lt;Integer&gt;();    public CQueue() &#123;    &#125;        public void appendTail(int value) &#123;            firstStack.push(value);    &#125;        public int deleteHead() &#123;        if(firstStack.isEmpty())&#123;            return -1;        &#125;        while(!firstStack.isEmpty())&#123;            int value&#x3D; firstStack.pop();            secondStack.push(value);        &#125;        int temp&#x3D;secondStack.pop();        while(!secondStack.isEmpty())&#123;            int value&#x3D;secondStack.pop();            firstStack.push(value);        &#125;        return temp;    &#125;&#125;&#x2F;** * Your CQueue object will be instantiated and called as such: * CQueue obj &#x3D; new CQueue(); * obj.appendTail(value); * int param_2 &#x3D; obj.deleteHead(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>斐波那契数列</p><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p> </p><p>示例 1：</p><p>输入：n = 2<br>输出：1<br>示例 2：</p><p>输入：n = 5<br>输出：5</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int fib(int n) &#123;        &#x2F;&#x2F;用一个数组来进行递归添加        if(n&#x3D;&#x3D;0)&#123;            return 0;        &#125;        if(n&#x3D;&#x3D;1)&#123;            return 1;        &#125;        int[] arr&#x3D;new int[n+1];        arr[0]&#x3D;0;        arr[1]&#x3D;1;        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;            arr[i]&#x3D;(arr[i-1]+arr[i-2])%1000000007;        &#125;        return arr[n];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>青蛙跳台阶问题</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><p>输入：n = 2<br>输出：2<br>示例 2：</p><p>输入：n = 7<br>输出：21<br>示例 3：</p><p>输入：n = 0<br>输出：1</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int numWays(int n) &#123;        &#x2F;&#x2F;如果n小于等于1那么返回1     if(n&lt;&#x3D;1)&#123;            return 1;        &#125;        &#x2F;&#x2F;搞个数组加1         int[] arr&#x3D;new int[n+1];         &#x2F;&#x2F;数组  最终长度为 arr[i]&#x3D;arr[i-1]+arr[i-2]        arr[0]&#x3D;1;        arr[1]&#x3D;2;          for(int i&#x3D;2;i&lt;n;i++)&#123;             arr[i]&#x3D;(arr[i-1]+arr[i-2])%1000000007;         &#125;         return arr[n-1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 二进制中1的个数<br>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><p>提示：</p><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p>示例 1：</p><p>输入：n = 11 (控制台输入 00000000000000000000000000001011)<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p><p>输入：n = 128 (控制台输入 00000000000000000000000010000000)<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p><p>输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><pre class="line-numbers language-none"><code class="language-none">public class Solution &#123;    &#x2F;&#x2F; you need to treat n as an unsigned value    public int hammingWeight(int n) &#123;        &#x2F;&#x2F;这个就是拿1 进行不断的左移 然后匹配到了就加1        int count&#x3D;0;       int flag&#x3D;1;       while(flag!&#x3D;0)&#123;           if((n&amp;flag)!&#x3D;0)&#123;               count++;           &#125;           flag&lt;&lt;&#x3D;1;       &#125;       return count;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求平方根</p><p>给定一个非负整数 x ，计算并返回 x 的平方根，即实现 int sqrt(int x) 函数。</p><p>正数的平方根有两个，只输出其中的正数平方根。</p><p>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。</p><p> </p><p>示例 1:</p><p>输入: x = 4<br>输出: 2<br>示例 2:</p><p>输入: x = 8<br>输出: 2<br>解释: 8 的平方根是 2.82842…，由于小数部分将被舍去，所以返回 2</p><pre class="line-numbers language-none"><code class="language-none">class Solution &#123;    public int mySqrt(int x) &#123;        &#x2F;&#x2F;这个题用二分法然后接近结果        int  left&#x3D;0;        int  right&#x3D;x;        int result&#x3D;0;        while(left&lt;&#x3D;right)&#123;            int mid&#x3D;(left+(right-left)&#x2F;2);                if((long)mid*mid&lt;&#x3D;x)&#123;                    result&#x3D;mid;                    left&#x3D;mid+1;                &#125;else&#123;                    right&#x3D;mid-1;                &#125;                        &#125;        return result;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈的最小值</p><p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p><p>示例：</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><pre class="line-numbers language-none"><code class="language-none">class MinStack &#123;    &#x2F;** initialize your data structure here. *&#x2F;    &#x2F;&#x2F;搞两个栈 一个放最小值 一个放正常值  每次放正常值的时候会先把最小值拿出来 然后比较一下 一起同步塞一个最小值进去    Stack&lt;Integer&gt; stack&#x3D; new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; minStack&#x3D; new Stack&lt;Integer&gt;();    public MinStack() &#123;    &#125;        public void push(int x) &#123;        stack.push(x);        if(minStack.size()&gt;0)&#123;         int min&#x3D;minStack.peek();         min&#x3D;Math.min(min,x);         minStack.push(min);        &#125;else&#123;            minStack.push(x);        &#125;    &#125;        public void pop() &#123;        stack.pop();        minStack.pop();    &#125;        public int top() &#123;        return stack.peek();       &#125;        public int getMin() &#123;       return minStack.peek();     &#125;&#125;&#x2F;** * Your MinStack object will be instantiated and called as such: * MinStack obj &#x3D; new MinStack(); * obj.push(x); * obj.pop(); * int param_3 &#x3D; obj.top(); * int param_4 &#x3D; obj.getMin(); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用的算法总结&quot;&gt;&lt;a href=&quot;#常用的算法总结&quot; class=&quot;headerlink&quot; title=&quot;常用的算法总结&quot;&gt;&lt;/a&gt;常用的算法总结&lt;/h1&gt;&lt;h2 id=&quot;数组-模块&quot;&gt;&lt;a href=&quot;#数组-模块&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="算法总结" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/08/04/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2021/08/04/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-08-04T09:54:06.278Z</published>
    <updated>2024-03-02T09:48:25.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装hexo"><a href="#一、安装hexo" class="headerlink" title="一、安装hexo"></a>一、安装hexo</h1><p>##1.安装Node.js<br>hexo是一款基于Node.js的静态博客框架，所以要使用它必须先安装Node.js。网上很多教程讲的都是如何编译源码安装Node.js。但我认为应该用最简单的方式取获取和使用软件或者框架，不是每个初学者都需要从一个软件的源代码编译开始学习。当然，在日后想要更深入理解它的时候，挖出它的源代码进行分析也是一种十分有效的途径。<br>下面是ubuntu下使用apt-get安装Node.js的方法（源自博客如何在Ubuntu上安装最新版本的Node.js ）</p><p>1.apt-get update<br>2.apt-get install -y python-software-properties 3.software-properties-common<br>4.add-apt-repository ppa:chris-lea/node.js<br>5.apt-get update<br>6.apt-get install nodejs</p><h2 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h2><p>之后安装hexo就更简单了，只需要这一行代码</p><p>npm install hexo -g<br>3.更新hexo</p><p>npm update hexo -g </p><h1 id="二、创建和配置hexo项目"><a href="#二、创建和配置hexo项目" class="headerlink" title="二、创建和配置hexo项目"></a>二、创建和配置hexo项目</h1><h2 id="1-初始化hexo项目"><a href="#1-初始化hexo项目" class="headerlink" title="1.初始化hexo项目"></a>1.初始化hexo项目</h2><p>hexo init [folder]<br>如果指定 folder_，便会在目前的资料夹建立一个名为 _folder 的新资料夹，否则会在当前文件夹初始化。<br>执行完这条命令，会出现如下提示:</p><p>INFO You are almost done! Don’t forget to run ‘npm install’ before you start blogging with Hexo!</p><p>所以记得执行npm install</p><h2 id="2-创建新的文章"><a href="#2-创建新的文章" class="headerlink" title="2.创建新的文章"></a>2.创建新的文章</h2><p>hexo new “文章标题”<br>执行完创建命令后会生成以下文件:</p><p>source/_posts/文章标题.md</p><p>之后只需要在这个markdown文件里面编写自己的博客文章就可以了</p><h2 id="3-添加主题"><a href="#3-添加主题" class="headerlink" title="3.添加主题"></a>3.添加主题</h2><p>有很多人为hexo编写了很多漂亮的主题，可以自己去主题列表选择<br>安装的方法也很简单，这些主题都是托管在github上的，只要把它们克隆到项目文件夹的themes目录下面就可以了。当然还需要去__config.yml修改配置，选择使用哪个主题：</p><p>theme: 主题名</p><h2 id="4-启动服务器"><a href="#4-启动服务器" class="headerlink" title="4.启动服务器"></a>4.启动服务器</h2><p>编写完文章之后只需要运行下面命令就可以在浏览器地址栏输入 <a href="http://0.0.0.0:4000/">http://0.0.0.0:4000</a> 查看自己的博客了</p><p>hexo server</p><h2 id="三、配置博客信息"><a href="#三、配置博客信息" class="headerlink" title="三、配置博客信息"></a>三、配置博客信息</h2><p>可以在项目根目录下的_config.yml文件配置博客的标题，作者，语言等相关信息</p><h1 id="四、部署到Github"><a href="#四、部署到Github" class="headerlink" title="四、部署到Github"></a>四、部署到Github</h1><p>github提供了一个名叫Github Pages的服务，我们可以免费的用它来搭建自己的博客。<br>做法很简单，首先在github建立与你用户名对应的仓库，仓库名必须为 “你的github用户名.github.io”</p><p>接着执行以下命令在本机安装hexo-deployer-git</p><p>npm install hexo-deployer-git –save<br>然后在_config.yml文件，找到下面的内容</p><p>Deployment<br>Docs: <a href="http://hexo.io/docs/deployment.html">http://hexo.io/docs/deployment.html</a><br>deploy:<br>  type:<br>将它们修改为</p><p> Deployment<br> Docs: <a href="http://hexo.io/docs/deployment.html">http://hexo.io/docs/deployment.html</a><br>deploy:<br>  type: git<br>  repository: <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;">&#x67;&#105;&#116;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:你的github用户名/你的github用户名.github.io<br>  branch: master</p><p>最后执行以下三条命令即可：</p><p>hexo clean</p><p>hexo generate</p><p>hexo deploy</p><p>（当然你必须为你的电脑添加github ssh key才能正常执行hexo deploy命令上传代码）</p><h1 id="五、绑定域名"><a href="#五、绑定域名" class="headerlink" title="五、绑定域名"></a>五、绑定域名</h1><p>按照github pages的文档，是在github项目根目录下创建CNAME文件。但因为每次使用hexo更新博客再次上传，都会清除掉之前创建的CNAME文件。所以我们把CNAME放在source目录下（想上传的文件都放在该目录下）</p><p>完整步骤如下:</p><p>在source目录下添加一个CNAM文件，没有后缀名，里面内容为你的域名(如我的是:blog.islinjw.cn)。</p><p>ping username.github.io记录下IP地址</p><p>购买域名，配置域名解析username.github.io的ip地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、安装hexo&quot;&gt;&lt;a href=&quot;#一、安装hexo&quot; class=&quot;headerlink&quot; title=&quot;一、安装hexo&quot;&gt;&lt;/a&gt;一、安装hexo&lt;/h1&gt;&lt;p&gt;##1.安装Node.js&lt;br&gt;hexo是一款基于Node.js的静态博客框架，所以要使用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MVVM与JetPacket结合</title>
    <link href="http://example.com/2021/08/01/MVVM%20%E4%B8%8EJetpack%E7%BB%93%E5%90%88/"/>
    <id>http://example.com/2021/08/01/MVVM%20%E4%B8%8EJetpack%E7%BB%93%E5%90%88/</id>
    <published>2021-07-31T16:00:00.000Z</published>
    <updated>2021-12-26T14:37:22.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>MVVM是目前谷歌推荐的Android开发层次框架，如果跟JetPacket相互结合 可以更好的进行相关的开发。</p><h1 id="使用到的JetPacket组件"><a href="#使用到的JetPacket组件" class="headerlink" title="使用到的JetPacket组件"></a>使用到的JetPacket组件</h1><p>LiveData 、Room 、ViewModel、DataBinding</p><h1 id="代码分层分包"><a href="#代码分层分包" class="headerlink" title="代码分层分包"></a>代码分层分包</h1><p>比如我们需要开发一个用户信息模块 根据mvvm的设计理念我们可以这个分包</p><pre class="line-numbers language-none"><code class="language-none">|-- api|-- room|-- userInfo|   |-- model|   |-- repository|   |-- view|   |-- viewmodel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>api 是结合retrofit的请求库 作为全局的网络请求url封装</li><li>room 作为全局数据库的一个封装包，提供各种持久化数据库的入口</li><li>model  作为一个小功能的数据层</li><li>repository 是当这个功能的获取数据比较复杂的时候可以多加一层</li><li>view是作为数据的显示层</li><li>viewmodel 作为viewmodel层主要是进行逻辑处理</li></ul><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><p>1.别忘了添加权限</p><pre class="line-numbers language-none"><code class="language-none">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.dataBinding 需要打开</p><pre class="line-numbers language-none"><code class="language-none">dataBinding &#123;     enabled &#x3D; true &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>添加环境依赖</li></ol><pre class="line-numbers language-none"><code class="language-none">implementation &#39;androidx.lifecycle:lifecycle-extensions:2.2.0&#39;implementation &#39;com.squareup.retrofit2:retrofit:2.6.2&#39;implementation &#39;com.squareup.retrofit2:converter-gson:2.4.0&#39;implementation &#39;com.squareup.picasso:picasso:2.71828&#39;implementation &#39;androidx.room:room-runtime:2.2.2&#39;implementation &#39;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0&#39;implementation &#39;de.hdodenhof:circleimageview:3.0.1&#39;annotationProcessor &#39;androidx.room:room-compiler:2.2.2&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>定义model层</li></ol><pre class="line-numbers language-none"><code class="language-none">@Entity(tableName &#x3D; &quot;user&quot;)public class User &#123;    @PrimaryKey()    @ColumnInfo(name &#x3D; &quot;id&quot;, typeAffinity &#x3D; ColumnInfo.INTEGER)    public int id;    @ColumnInfo(name &#x3D; &quot;name&quot;, typeAffinity &#x3D; ColumnInfo.TEXT)    public String name;    @ColumnInfo(name &#x3D; &quot;avatar&quot;, typeAffinity &#x3D; ColumnInfo.TEXT)    @SerializedName(&quot;avatar_url&quot;)    public String avatar;    @ColumnInfo(name &#x3D; &quot;followers&quot;, typeAffinity &#x3D; ColumnInfo.INTEGER)    public int followers;    @ColumnInfo(name &#x3D; &quot;following&quot;, typeAffinity &#x3D; ColumnInfo.INTEGER)    public int following;    @ColumnInfo(name &#x3D; &quot;blog&quot;, typeAffinity &#x3D; ColumnInfo.TEXT)    public String blog;    @ColumnInfo(name &#x3D; &quot;company&quot;, typeAffinity &#x3D; ColumnInfo.TEXT)    public String company;    @ColumnInfo(name &#x3D; &quot;bio&quot;, typeAffinity &#x3D; ColumnInfo.TEXT)    public String bio;    @ColumnInfo(name &#x3D; &quot;location&quot;, typeAffinity &#x3D; ColumnInfo.TEXT)    public String location;    @ColumnInfo(name &#x3D; &quot;html_url&quot;, typeAffinity &#x3D; ColumnInfo.TEXT)    @SerializedName(&quot;html_url&quot;)    public String htmlUrl;    public User(            int id, String name, String avatar, int followers, int following, String blog, String company, String bio, String location, String htmlUrl) &#123;        this.id &#x3D; id;        this.name &#x3D; name;        this.avatar &#x3D; avatar;        this.followers &#x3D; followers;        this.following &#x3D; following;        this.blog &#x3D; blog;        this.company &#x3D; company;        this.bio &#x3D; bio;        this.location &#x3D; location;        this.htmlUrl &#x3D; htmlUrl;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>创建数据库</li></ol><pre class="line-numbers language-none"><code class="language-none">@Database(entities &#x3D; User.class, version &#x3D; 1, exportSchema &#x3D; false)public abstract class UserDatebase extends RoomDatabase &#123;    private static final String DATABASE_NAME &#x3D; &quot;user_db&quot;;    private static UserDatebase databaseInstance;    public static synchronized UserDatebase getInstance(Context context) &#123;        if (databaseInstance &#x3D;&#x3D; null) &#123;            databaseInstance &#x3D; Room.databaseBuilder(context.getApplicationContext(), UserDatebase.class, DATABASE_NAME).build();        &#125;        return databaseInstance;    &#125;    public abstract UserDao getUserDao();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">@Daopublic interface UserDao &#123;    @Insert(onConflict &#x3D; OnConflictStrategy.REPLACE)    void insertUser(User user);    @Delete    void deleteStudent(User user);    @Query(&quot;SELECT * FROM user WHERE name&#x3D; :name&quot;)    LiveData&lt;User&gt; getUserByName(String name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.定义网络请求</p><pre class="line-numbers language-none"><code class="language-none">public interface API &#123;    @GET(&quot;users&#x2F;&#123;userId&#125;&quot;)    Call&lt;User&gt; getUser(@Path(&quot;userId&quot;) String userId);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class RetrofitClient &#123;    private static final String BASE_URL &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;;    private static RetrofitClient retrofitClient;    private Retrofit retrofit;    private RetrofitClient() &#123;        retrofit &#x3D; new Retrofit.Builder().baseUrl(BASE_URL).addConverterFactory(GsonConverterFactory.create()).build();    &#125;    public static synchronized RetrofitClient getInstance() &#123;        if (retrofitClient &#x3D;&#x3D; null) &#123;            retrofitClient &#x3D; new RetrofitClient();        &#125;        return retrofitClient;    &#125;    public API getApi() &#123;        return retrofit.create(API.class);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7.将数据库和网络库的获取方式放在application方便获取</p><pre class="line-numbers language-none"><code class="language-none">public class MyApplication extends android.app.Application &#123;    private static UserDatebase userDatebase;    private static API api;    @Override    public void onCreate() &#123;        super.onCreate();        userDatebase &#x3D; UserDatebase.getInstance(this);        api &#x3D; RetrofitClient.getInstance().getApi();    &#125;    public static API getApi() &#123;        return api;    &#125;    public static UserDatebase getUserDatebase() &#123;        return userDatebase;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>8.假设我们要获取的数据非常复杂，我们可以多搞一个repository层(当然这一层也是可以没有的)</p><pre class="line-numbers language-none"><code class="language-none">public class UserRepository &#123;    private String TAG &#x3D; this.getClass().getName();    private UserDao userDao;    private API api;    public UserRepository(UserDao userDao, API api) &#123;        this.api &#x3D; api;        this.userDao &#x3D; userDao;    &#125;    public LiveData&lt;User&gt; getUser(final String name) &#123;        refresh(name);        return userDao.getUserByName(name);    &#125;    public void refresh(String name) &#123;        api.getUser(name).enqueue(new Callback&lt;User&gt;() &#123;            @Override            public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123;                if (response.body() !&#x3D; null) &#123;                    insterUer(response.body());                &#125;            &#125;            @Override            public void onFailure(Call&lt;User&gt; call, Throwable t) &#123;                Log.i(TAG, &quot;onFailure: &quot;, t);            &#125;        &#125;);    &#125;    private void insterUer(final User user) &#123;        AsyncTask.execute(new Runnable() &#123;            @Override            public void run() &#123;                userDao.insertUser(user);            &#125;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>9.将viewmodel层给实现</p><pre class="line-numbers language-none"><code class="language-none">public class UserViewModel extends AndroidViewModel &#123;    private LiveData&lt;User&gt; user;    private UserRepository userRepository;    private String userName &#x3D; &quot;whd&quot;;    public UserViewModel(@NonNull Application application) &#123;        super(application);        UserDatebase userDatebase &#x3D; MyApplication.getUserDatebase();        UserDao userDao &#x3D; userDatebase.getUserDao();        userRepository &#x3D; new UserRepository(userDao, MyApplication.getApi());        user &#x3D; userRepository.getUser(userName);    &#125;    public LiveData&lt;User&gt; getUser()&#123;        return user;    &#125;    public void refresh()&#123;        userRepository.refresh(userName);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>10.我们再看下view层 包括Activity和xml</p><pre class="line-numbers language-none"><code class="language-none">class Main2Activity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main2)        var binding &#x3D;            DataBindingUtil.setContentView&lt;ActivityMain2Binding&gt;(this, R.layout.activity_main2)        val userViewModel &#x3D; ViewModelProvider(this).get(UserViewModel::class.java)        userViewModel.user.observe(this,            Observer&lt;User&gt; &#123;                binding.user &#x3D; it            &#125;)        val swipeRefresh &#x3D; binding.swipeRefresh        swipeRefresh.setOnRefreshListener &#123;            userViewModel.refresh()            swipeRefresh.isRefreshing &#x3D; false        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xml包括了一些数据的显示</p><pre class="line-numbers language-mxl" data-language="mxl"><code class="language-mxl">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;layout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;    &lt;data&gt;        &lt;variable            name&#x3D;&quot;user&quot;            type&#x3D;&quot;com.example.mvvm_jetpack.userInfo.model.User&quot; &#x2F;&gt;    &lt;&#x2F;data&gt;    &lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout        android:id&#x3D;&quot;@+id&#x2F;swipeRefresh&quot;        android:layout_width&#x3D;&quot;match_parent&quot;        android:layout_height&#x3D;&quot;match_parent&quot;&gt;        &lt;RelativeLayout            android:layout_width&#x3D;&quot;match_parent&quot;            android:layout_height&#x3D;&quot;wrap_content&quot;&gt;            &lt;ImageView                android:layout_width&#x3D;&quot;wrap_content&quot;                android:layout_height&#x3D;&quot;wrap_content&quot;                android:scaleType&#x3D;&quot;fitStart&quot;&gt;&lt;&#x2F;ImageView&gt;            &lt;view                android:layout_width&#x3D;&quot;match_parent&quot;                android:layout_height&#x3D;&quot;match_parent&quot;                android:layout_marginLeft&#x3D;&quot;128dp&quot;                android:layout_marginTop&#x3D;&quot;128dp&quot;                android:layout_marginRight&#x3D;&quot;128dp&quot;&gt;&lt;&#x2F;view&gt;            &lt;LinearLayout xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;                android:layout_width&#x3D;&quot;match_parent&quot;                android:layout_height&#x3D;&quot;match_parent&quot;                android:layout_marginTop&#x3D;&quot;80dp&quot;                android:gravity&#x3D;&quot;center_horizontal&quot;                android:orientation&#x3D;&quot;vertical&quot;&gt;                &lt;de.hdodenhof.circleimageview.CircleImageView                    android:id&#x3D;&quot;@+id&#x2F;profile_image&quot;                    android:layout_width&#x3D;&quot;96dp&quot;                    android:layout_height&#x3D;&quot;96dp&quot;                    app:civ_border_color&#x3D;&quot;#CCCCCC&quot;                    app:civ_border_width&#x3D;&quot;2dp&quot;                    app:image&#x3D;&quot;@&#123;user.avatar&#125;&quot;                    &gt;&lt;&#x2F;de.hdodenhof.circleimageview.CircleImageView&gt;                &lt;TextView                    android:layout_width&#x3D;&quot;wrap_content&quot;                    android:layout_height&#x3D;&quot;wrap_content&quot;                    android:layout_marginTop&#x3D;&quot;8dp&quot;                    android:text&#x3D;&quot;@&#123;user.name&#125;&quot;                    android:textSize&#x3D;&quot;22sp&quot;                    android:textStyle&#x3D;&quot;bold&quot;                    &gt;&lt;&#x2F;TextView&gt;                &lt;TextView                    android:layout_width&#x3D;&quot;wrap_content&quot;                    android:layout_height&#x3D;&quot;wrap_content&quot;                    android:layout_marginTop&#x3D;&quot;8dp&quot;                    android:text&#x3D;&quot;@&#123;user.bio&#125;&quot;                    android:textSize&#x3D;&quot;16sp&quot;&gt;&lt;&#x2F;TextView&gt;                &lt;TextView                    android:layout_width&#x3D;&quot;wrap_content&quot;                    android:layout_height&#x3D;&quot;wrap_content&quot;                    android:layout_marginTop&#x3D;&quot;8dp&quot;                    android:text&#x3D;&quot;@&#123;user.company&#125;&quot;                    android:textSize&#x3D;&quot;16sp&quot;&gt;&lt;&#x2F;TextView&gt;                &lt;TextView                    android:layout_width&#x3D;&quot;wrap_content&quot;                    android:layout_height&#x3D;&quot;wrap_content&quot;                    android:layout_marginTop&#x3D;&quot;8dp&quot;                    android:text&#x3D;&quot;@&#123;user.location&#125;&quot;                    android:textSize&#x3D;&quot;16sp&quot;&gt;&lt;&#x2F;TextView&gt;                &lt;LinearLayout                    android:layout_width&#x3D;&quot;wrap_content&quot;                    android:layout_height&#x3D;&quot;wrap_content&quot;                    android:layout_marginTop&#x3D;&quot;8dp&quot;                    android:orientation&#x3D;&quot;horizontal&quot;&gt;                    &lt;TextView                        android:layout_width&#x3D;&quot;wrap_content&quot;                        android:layout_height&#x3D;&quot;wrap_content&quot;                        android:text&#x3D;&quot;@&#123;user.followers&#125;&quot;                        android:textSize&#x3D;&quot;16sp&quot;&gt;&lt;&#x2F;TextView&gt;                    &lt;TextView                        android:layout_width&#x3D;&quot;wrap_content&quot;                        android:layout_height&#x3D;&quot;wrap_content&quot;                        android:layout_marginLeft&#x3D;&quot;12dp&quot;                        android:text&#x3D;&quot;@&#123;user.following&#125;&quot;                        android:textSize&#x3D;&quot;16dp&quot;                        &gt;&lt;&#x2F;TextView&gt;                &lt;&#x2F;LinearLayout&gt;                &lt;TextView                    android:layout_width&#x3D;&quot;wrap_content&quot;                    android:layout_height&#x3D;&quot;wrap_content&quot;                    android:layout_marginTop&#x3D;&quot;8dp&quot;                    android:text&#x3D;&quot;@&#123;user.htmlUrl&#125;&quot;                    android:textSize&#x3D;&quot;16dp&quot; &#x2F;&gt;                &lt;TextView                    android:layout_width&#x3D;&quot;wrap_content&quot;                    android:layout_height&#x3D;&quot;wrap_content&quot;                    android:layout_marginTop&#x3D;&quot;8dp&quot;                    android:text&#x3D;&quot;@&#123;user.blog&#125;&quot;                    android:textSize&#x3D;&quot;16dp&quot; &#x2F;&gt;            &lt;&#x2F;LinearLayout&gt;        &lt;&#x2F;RelativeLayout&gt;    &lt;&#x2F;androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt;&lt;&#x2F;layout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还将圆形头像的加载给到Picasa来加载</p><pre class="line-numbers language-none"><code class="language-none">public class ImageViewBindAdapter &#123;    @BindingAdapter(value &#x3D; &#123;&quot;image&quot;, &quot;defaultImageResource&quot;&#125;, requireAll &#x3D; false)    public static void setImage(ImageView imageView, String imageUrl, int imageSource) &#123;        if (!TextUtils.isEmpty(imageUrl)) &#123;            Picasso.get().load(imageUrl).placeholder(R.drawable.ic_launcher_background).error(R.drawable.ic_launcher_background).into(imageView);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是Mvvm结合Jetpack的使用，希望在平时项目中多运用，写出更高效和优质的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;MVVM是目前谷歌推荐的Android开发层次框架，如果跟JetPacket相互结合 可以更好的进行相关的开发。&lt;/p&gt;
&lt;h1 id=&quot;使</summary>
      
    
    
    
    <category term="架构" scheme="http://example.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="日常积累" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>线程优化</title>
    <link href="http://example.com/2021/04/18/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/04/18/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-17T16:00:00.000Z</published>
    <updated>2022-08-04T15:25:54.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>了解线程的调度有利于我们开发项目</p><p>线程调度模型<br>1、分时调度模型：轮流获取，均分cpu时间<br>2、抢占式调度模型:优先级搞的获取 jvm采用<br>Android ui线程的优先级是如下 越小优先级越高</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THREAD_PRIORITY_DEFAULT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="常见的线程的方式"><a href="#常见的线程的方式" class="headerlink" title="常见的线程的方式"></a>常见的线程的方式</h1><h2 id="Thread-方式"><a href="#Thread-方式" class="headerlink" title="Thread 方式"></a>Thread 方式</h2><p>优点：最简单，最常见异步方式<br>缺点：不易复用，频繁创建及销毁开销大<br>复杂场景不易使用</p><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>适合长时间消息队列</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>集成了Service 在内部创建了HandlerThread<br>执行在异步执行<br>优先级比较高，不容易被kill</p><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>Android 提供的工具类<br>无需要自己处理线程切换</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>已复用，减少频繁创建，销毁时间<br>功能强大：并发数控等</p><h2 id="Rxjava"><a href="#Rxjava" class="headerlink" title="Rxjava"></a>Rxjava</h2><p>由强大的scheduler 集合提供了强大的切换方式</p><p>线程使用准则<br>1、创建线程必须命名，这样方便定位</p><p>2、关键一步任务要监控 比如aop监控</p><p>3、设置合理的线程优先级</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ThreadPoolUtils</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> mService<span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>            thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"thread name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> thread<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span>   mService<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;了解线程的调度有利于我们开发项目&lt;/p&gt;
&lt;p&gt;线程调度模型&lt;br&gt;1、分时调度模型：轮流获取，均分cpu时间&lt;br&gt;2、抢</summary>
      
    
    
    
    <category term="性能优化" scheme="http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="线程优化" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>apk瘦身优化</title>
    <link href="http://example.com/2021/04/08/%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/04/08/%E7%98%A6%E8%BA%AB%E4%BC%98%E5%8C%96/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2022-08-04T15:24:06.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>apk的大小有助于更好的打入市场</p><h2 id="apk的组成"><a href="#apk的组成" class="headerlink" title="apk的组成"></a>apk的组成</h2><p>1、代码相关 class.dex<br>2、资源相关 res 、asserts、resources.arsc<br>3、lib 的so</p><h2 id="apk的分析工具"><a href="#apk的分析工具" class="headerlink" title="apk的分析工具"></a>apk的分析工具</h2><p>1、AndroidStudio 直接拖apk进来，可以分析数据占用大小</p><p><img src="/images/androidstudio_apk_size.png" alt="AndroidStudio"></p><p>2、jadx 可以反编译出文件的数据 在jadx/jadx-gui/build/install/jadx-gui/bin/jadx-gui 可以打开反编译的可视化工具</p><p><img src="/images/jadx.png" alt="反编译工具"></p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>1、代码混淆</p><p>2、三方库的处理<br>基础库统一，去掉冗余的库<br>在选择的时候也应该选择更小的库</p><p>3、移除无用代码</p><h2 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h2><p>1、可以通过AndroidStudio/Refactor/Remove unused resource 删除没有引用的资源，它会列出所有没有用到的资源</p><p>2、将png图片换成比较小的格式图片</p><h2 id="so优化"><a href="#so优化" class="headerlink" title="so优化"></a>so优化</h2><p>so 是Android的动态链接库<br>abiFilters 设置支持的so架构<br>一般选择armeabi架构就足够了</p><p>其他方案so动态下载</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;apk的大小有助于更好的打入市场&lt;/p&gt;
&lt;h2 id=&quot;apk的组成&quot;&gt;&lt;a href=&quot;#apk的组成&quot; class=&quot;</summary>
      
    
    
    
    <category term="性能优化" scheme="http://example.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="apk大小优化" scheme="http://example.com/tags/apk%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>UML入门</title>
    <link href="http://example.com/2021/04/01/UML%E5%85%A5%E9%97%A8%E5%88%9D%E8%AF%86/"/>
    <id>http://example.com/2021/04/01/UML%E5%85%A5%E9%97%A8%E5%88%9D%E8%AF%86/</id>
    <published>2021-03-31T16:00:00.000Z</published>
    <updated>2022-04-21T13:28:17.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当有新人接手你的项目时候，你是否有足够的项目结构介绍资料给到新人？ 当你作为一个新人接手别人的项目的时候，看项目的结构图的时候是否会一脸懵逼，因为你没有系统的学习UML相关的知识。了解UML图的绘制一方面可以检查自己的代码设计，并能向他人进行讲解。</p><p><img src="/images/UML_background.png" alt="背景"></p><h2 id="介绍常见的箭头类型"><a href="#介绍常见的箭头类型" class="headerlink" title="介绍常见的箭头类型"></a>介绍常见的箭头类型</h2><p><img src="/images/arrow.png" alt="箭头"></p><p>如上图我们从左往右依次介绍一下，分别是 依赖关系，关联关系，继承关系，实现关系，聚合关系，组合关系</p><p>依赖关系：所谓依赖关系就是你这个类要能执行必须依赖另外一个对象，这样你可以把箭头指向这个类<br>关联关系：就是你这个类会使用到另外一个类，但是不是一定要用这个类。<br>继承关系：你这个类需要继承另外一个类<br>实现关系：你这个类会实现某个接口类<br>聚合：聚合表示一种弱拥有关系，体现的是A对象可以包含B但是B对象不是A对象的一部分，例如燕群可以包含一只燕，但是燕子也可以自己一个<br>组合：合成是一种强拥有关系，体现了严格的部分和整体关系，例如人是又器官组成的，器官离开了人不可以存活</p><h2 id="分别举个例子"><a href="#分别举个例子" class="headerlink" title="分别举个例子"></a>分别举个例子</h2><p>依赖关系：<br>我们可以看到这个类的实现必须要依赖AndroidPhone这个类<br><img src="/images/uml_relyOn.png" alt="依赖关系"></p><p>继承关系:<br><img src="/images/uml_extend.png" alt="继承关系"></p><p><img src="/images/uml_extend2.png" alt="继承关系"></p><p>实现关系<br><img src="/images/uml_implements.png" alt="实现关系"></p><p><img src="/images/uml_implements2.png" alt="实现关系"></p><p>聚合与组合<br><img src="/images/uml_combination.png" alt="聚合与组合"></p><p><img src="/images/uml_combination2.png" alt="聚合与组合"></p><p>记住聚合跟组合的区别就是在两个类是否可以独立工作</p><p><img src="/images/uml_class_all.png" alt="整体类图全貌，常见类图画法"></p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>圆角矩形：表示“动作”<br><img src="/images/uml_active.png" alt="动作"></p><p>菱形：表示“决策”<br><img src="/images/uml_decision.png" alt="决策"></p><p>粗实线：表示并行活动的开始（分离）和结束（汇合）<br><img src="/images/uml_decision.png" alt="结束和分离"></p><p>黑圆：工作流的开始（初始节点）<br><img src="/images/uml_start.png" alt="开始"></p><p>黑圈套住的黑圆：工作流的结束（结束节点）<br><img src="/images/uml_end_point.png" alt="结束"></p><p>活动图的一些规则<br>第一个粗实线之后可以有若干分支，每个分支都是并行执行的<br>• 第二个粗实线之前，所有的分支汇合，所有的分支活动都完成才进入之后的环节<br>• 初始节点有且只有一个，结束节点可能不止一个</p><p><img src="/images/uml_all_active.png" alt="常见的活动图"></p><p>一些注意事项：<br>• 当有多个对象出现在活动图中时，可以考虑引入泳道<br>• 一个活动只能存在于唯一的泳道里</p><p><img src="/images/uml_some_active.png" alt="常见的多泳道活动图"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>对象的三种命名方式：</p><p>显示实例名和类名，方式：实例名:类名<br>只显示类名，表示它是一个匿名对象，方式：:类名<br>只显示实例名，方式：实例名</p><p><img src="/images/uml_time.png" alt="时序图"></p><p>同步消息：消息的发送者把消息传递给接收者后停止活动，等待消息的接收者放弃或者返回消息，之<br>后才能执行下一步操作<br>• 异步消息：消息的发送者把消息传递给接收者后继续自己的活动，不等待接受者放弃或者返回消息</p><p>组合片段（Combined Fragments） • 抉择（Alt）：与 if…then…else 对应<br>• 选项（Opt）：表示符合条件时执行<br>• 循环（Loop）：与 for 或者 foreach 对应<br>• 并行（Par）：与多线程对应</p><p><img src="/images/uml_time_if.png" alt="时序图"></p><p><img src="/images/uml_time_loop.png" alt="时序图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当有新人接手你的项目时候，你是否有足够的项目结构介绍资料给到新人？ 当你作为一个新人接手别人的项目的时候，看项目的结构图的时候是否会一脸懵逼</summary>
      
    
    
    
    <category term="日常积累" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="日常积累" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读-EventBus</title>
    <link href="http://example.com/2021/03/08/EventBus/"/>
    <id>http://example.com/2021/03/08/EventBus/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2022-07-21T16:27:32.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="EventBus作为一款事件发布的第三方开源框架，几乎是每个项目都会使用到，使用它可以对Fragment和Fragment之间-Activity和Activity之间，不同组件之间信息交互变得便捷，减少耦合性上有非常显著的效果，为了搞清楚EventBus-这个Android开发中国民级的开源组件源码，我们来看一下源码是怎么写的"><a href="#EventBus作为一款事件发布的第三方开源框架，几乎是每个项目都会使用到，使用它可以对Fragment和Fragment之间-Activity和Activity之间，不同组件之间信息交互变得便捷，减少耦合性上有非常显著的效果，为了搞清楚EventBus-这个Android开发中国民级的开源组件源码，我们来看一下源码是怎么写的" class="headerlink" title="EventBus作为一款事件发布的第三方开源框架，几乎是每个项目都会使用到，使用它可以对Fragment和Fragment之间 Activity和Activity之间，不同组件之间信息交互变得便捷，减少耦合性上有非常显著的效果，为了搞清楚EventBus 这个Android开发中国民级的开源组件源码，我们来看一下源码是怎么写的"></a>EventBus作为一款事件发布的第三方开源框架，几乎是每个项目都会使用到，使用它可以对Fragment和Fragment之间 Activity和Activity之间，不同组件之间信息交互变得便捷，减少耦合性上有非常显著的效果，为了搞清楚EventBus 这个Android开发中国民级的开源组件源码，我们来看一下源码是怎么写的</h2><p>title: 启动优化<br>date: 2022-01-30<br>categories: 性能优化<br>tags: Android开发 </p><hr><h1 id="为什么要做启动优化"><a href="#为什么要做启动优化" class="headerlink" title="为什么要做启动优化"></a>为什么要做启动优化</h1><h2 id="1、第一体验很重要"><a href="#1、第一体验很重要" class="headerlink" title="1、第一体验很重要"></a>1、第一体验很重要</h2><h2 id="2、八秒定律：如果打开需要8秒钟那么用户就会放弃"><a href="#2、八秒定律：如果打开需要8秒钟那么用户就会放弃" class="headerlink" title="2、八秒定律：如果打开需要8秒钟那么用户就会放弃"></a>2、八秒定律：如果打开需要8秒钟那么用户就会放弃</h2><h1 id="冷启动是衡量的标准"><a href="#冷启动是衡量的标准" class="headerlink" title="冷启动是衡量的标准"></a>冷启动是衡量的标准</h1><p>冷启动流程<br>click-&gt;ipc-process.start-&gt;ActivityThread-&gt;bindApplication-&gt;LifeCycle-&gt;ViewRootImpl</p><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><p>Application和Activity 生命周期方法是优化的方向 其他的地方其实无法干预</p><h2 id="adb命令获取启动时间"><a href="#adb命令获取启动时间" class="headerlink" title="adb命令获取启动时间"></a>adb命令获取启动时间</h2><p>adb shell am start -W packagename/首屏Activity</p><pre class="line-numbers language-none"><code class="language-none">adb shell am start -W com.example.better&#x2F;.MainActivityStarting: Intent &#123; act&#x3D;android.intent.action.MAIN cat&#x3D;[android.intent.category.LAUNCHER] cmp&#x3D;com.example.better&#x2F;.MainActivity &#125;Status: okActivity: com.example.better&#x2F;.MainActivityThisTime: 364TotalTime: 364WaitTime: 374Complete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>WaitTime 表示AMS启动Activity的总耗时</p><p>TotalTime 表示所有Activity启动耗时</p><p>ThisTime 表示最后一个Activity启动耗时</p><h2 id="手动打点"><a href="#手动打点" class="headerlink" title="手动打点"></a>手动打点</h2><p>就是从开始时间到ui展示出来的时比如你从application 开始到View画出来时间</p><p>比如创建一个类来负责记录时间</p><pre class="line-numbers language-none"><code class="language-none">class LauncherTimer &#123;    private static long sTime;    public static void startRecord() &#123;        sTime &#x3D; System.currentTimeMillis();    &#125;    public static void endRecord() &#123;        long cost &#x3D; System.currentTimeMillis() - sTime;        Log.i(&quot;cost&quot;, &quot;endRecord: &quot; + cost);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，应该是View绘制出来作为结束时间,比如可以监听某个View绘制的时候作为结束时间</p><pre class="line-numbers language-none"><code class="language-none">findViewById(R.id.text).getViewTreeObserver().addOnPreDrawListener(() -&gt; &#123;           LauncherTimer.endRecord();           return true;       &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><h3 id="1、traceview"><a href="#1、traceview" class="headerlink" title="1、traceview"></a>1、traceview</h3><p>使用方式</p><pre><code>Debug.startMethodTracing(&quot;app&quot;);Debug.stopMethodTracing();<pre class="line-numbers language-none"><code class="language-none">它会在应用的目录上生成一个xx.trace 文件 通过Studio打开后可以发现大概长这样![trace](&#x2F;images&#x2F;trace.png)上面滑动部分是你需要选中的时间范围中间部分会列出所有线程,还有每个做了什么事情，也就是方法调用栈点击方法可以知道每个方法的耗时total就是这个方法的耗时，children 就是子方法的耗时self 就是自己花费了多长时间知道了这些就可以进行性能优化多关注TopDown就可以知道哪些方法耗时了### 2、systemtrace## 基础使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    implementation &#39;org.greenrobot:eventbus:3.0.0&#39;<pre class="line-numbers language-none"><code class="language-none">在回调方法中加入注册和反注册功能，然后在方法中加入注解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>  @Override    protected void onStart() &#123;        super.onStart();        EventBus.getDefault().register(this);    &#125;    @Override    protected void onStop() &#123;        super.onStop();        EventBus.getDefault().unregister(this);    &#125;    @Subscribe(threadMode = ThreadMode.MAIN)    public void onmessage(MyBusEvent event) &#123;          Toast.makeText(this, event, Toast.LENGTH_SHORT).show();    &#125;<pre class="line-numbers language-none"><code class="language-none">最后一步就是在任意地方发送一个广播<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>public void postEvent() &#123;        EventBus.getDefault().post(new MyBusEvent(&quot;hhh&quot;));    &#125;<pre class="line-numbers language-none"><code class="language-none">## 源码解析我们先看第一句 EventBus.getDefault()到底做了什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>public static EventBus getDefault() &#123;        if (defaultInstance == null) &#123;            synchronized (EventBus.class) &#123;                if (defaultInstance == null) &#123;                    defaultInstance = new EventBus();                &#125;            &#125;        &#125;        return defaultInstance;    &#125;<pre class="line-numbers language-none"><code class="language-none">非常明显是做了一个双层锁的单例模式我们来看一下new EventBus构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre> public EventBus() &#123;        this(DEFAULT_BUILDER);    &#125;<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();<pre class="line-numbers language-none"><code class="language-none">调用了一个参数的构造方法传入了一个变量这这个变量就是它EventBusBuilder 所以其实是一个建造者模式，我们看一下EventBusBuilder和传参数的构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>   EventBus(EventBusBuilder builder) &#123;        subscriptionsByEventType = new HashMap&lt;&gt;();        typesBySubscriber = new HashMap&lt;&gt;();        stickyEvents = new ConcurrentHashMap&lt;&gt;();        mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);        backgroundPoster = new BackgroundPoster(this);        asyncPoster = new AsyncPoster(this);        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,                builder.strictMethodVerification, builder.ignoreGeneratedIndex);        logSubscriberExceptions = builder.logSubscriberExceptions;        logNoSubscriberMessages = builder.logNoSubscriberMessages;        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;        throwSubscriberException = builder.throwSubscriberException;        eventInheritance = builder.eventInheritance;        executorService = builder.executorService;    &#125;        <pre class="line-numbers language-none"><code class="language-none">可以看到做了很多的初始化操作subscriptionsByEventType 这个是以发送的对象为key subscrption为value的一个hashmap typesBySubscriber这个是一个以subscrption为key发送对象为value的一个hashmapstickyEvents 是一个粘性事件 mapHandlerPoster是一个继承Handler的调度器 我们有必要看一下这个类的代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>final class HandlerPoster extends Handler &#123;    private final PendingPostQueue queue;    private final int maxMillisInsideHandleMessage;    private final EventBus eventBus;    private boolean handlerActive;    HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123;        super(looper);        this.eventBus = eventBus;        this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;        queue = new PendingPostQueue();    &#125;    void enqueue(Subscription subscription, Object event) &#123;        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);        synchronized (this) &#123;            queue.enqueue(pendingPost);            if (!handlerActive) &#123;                handlerActive = true;                if (!sendMessage(obtainMessage())) &#123;                    throw new EventBusException(&quot;Could not send handler message&quot;);                &#125;            &#125;        &#125;    &#125;    @Override    public void handleMessage(Message msg) &#123;        boolean rescheduled = false;        try &#123;            long started = SystemClock.uptimeMillis();            while (true) &#123;                PendingPost pendingPost = queue.poll();                if (pendingPost == null) &#123;                    synchronized (this) &#123;                        // Check again, this time in synchronized                        pendingPost = queue.poll();                        if (pendingPost == null) &#123;                            handlerActive = false;                            return;                        &#125;                    &#125;                &#125;                eventBus.invokeSubscriber(pendingPost);                long timeInMethod = SystemClock.uptimeMillis() - started;                if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;                    if (!sendMessage(obtainMessage())) &#123;                        throw new EventBusException(&quot;Could not send handler message&quot;);                    &#125;                    rescheduled = true;                    return;                &#125;            &#125;        &#125; finally &#123;            handlerActive = rescheduled;        &#125;    &#125;&#125;<pre class="line-numbers language-none"><code class="language-none">我们可以看到PendingPostQueue是一个即将发送的消息队列，handlerActive是这个eventBus有没有运行起来，我们看一下他的handleMessage方法 ，其实就是从队列中拿到一个即将发送的消息，然后就是调用invokeSubscriber方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> void invokeSubscriber(PendingPost pendingPost) &#123;        Object event = pendingPost.event;        Subscription subscription = pendingPost.subscription;        PendingPost.releasePendingPost(pendingPost);        if (subscription.active) &#123;            invokeSubscriber(subscription, event);        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">我们回到EventBus的一个参数的构造方法从HandlerPoster继续往下看下去，我们看到了BackgroundPoster这个分发器我们看一下源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>final class BackgroundPoster implements Runnable &#123;    private final PendingPostQueue queue;    private final EventBus eventBus;    private volatile boolean executorRunning;    BackgroundPoster(EventBus eventBus) &#123;        this.eventBus = eventBus;        queue = new PendingPostQueue();    &#125;    public void enqueue(Subscription subscription, Object event) &#123;        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);        synchronized (this) &#123;            queue.enqueue(pendingPost);            if (!executorRunning) &#123;                executorRunning = true;                eventBus.getExecutorService().execute(this);            &#125;        &#125;    &#125;    @Override    public void run() &#123;        try &#123;            try &#123;                while (true) &#123;                    PendingPost pendingPost = queue.poll(1000);                    if (pendingPost == null) &#123;                        synchronized (this) &#123;                            // Check again, this time in synchronized                            pendingPost = queue.poll();                            if (pendingPost == null) &#123;                                executorRunning = false;                                return;                            &#125;                        &#125;                    &#125;                    eventBus.invokeSubscriber(pendingPost);                &#125;            &#125; catch (InterruptedException e) &#123;                Log.w(&quot;Event&quot;, Thread.currentThread().getName() + &quot; was interruppted&quot;, e);            &#125;        &#125; finally &#123;            executorRunning = false;        &#125;    &#125;&#125;<pre class="line-numbers language-none"><code class="language-none">其实就是一个线程 我们看run方法，其实跟前面是的HandlerPoster类似就是将事件调用invokeSubscriber方法通过反射去执行，这里就不再多说了，我们继续看AsyncPoster 这个类,其实这个类跟上面的类似，只不过它是拿到一个进行反射调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>class AsyncPoster implements Runnable &#123;    private final PendingPostQueue queue;    private final EventBus eventBus;    AsyncPoster(EventBus eventBus) &#123;        this.eventBus = eventBus;        queue = new PendingPostQueue();    &#125;    public void enqueue(Subscription subscription, Object event) &#123;        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);        queue.enqueue(pendingPost);        eventBus.getExecutorService().execute(this);    &#125;    @Override    public void run() &#123;        PendingPost pendingPost = queue.poll();        if(pendingPost == null) &#123;            throw new IllegalStateException(&quot;No pending post available&quot;);        &#125;        eventBus.invokeSubscriber(pendingPost);    &#125;&#125;<pre class="line-numbers language-none"><code class="language-none">我们继续看subscriberMethodFinder这个是一个方法找寻器，这个就是通过它来找寻有subscribe的方法，我们再后面再详细介绍这个类后面像各种logSubscriberExceptions等异常 我们就不深入介绍了，我们主要介绍主流程，不考虑很多异常情况，我们走主流程接下里我们先来看一下注解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface Subscribe &#123;    ThreadMode threadMode() default ThreadMode.POSTING;         boolean sticky() default false;    int priority() default 0;&#125;public enum ThreadMode &#123;   POSTING,    MAIN,    BACKGROUND,    ASYNC&#125;<pre class="line-numbers language-none"><code class="language-none">我们看到注解后面有线程类型 ，是否是粘性事件，优先级，我们来看一下ThreadMode的种类，有几种 POSTING是默认类型，MAIN是主线程类型BACKGROUND是起一个线程来发送事件 ASYNC是一个事件类型就是起一个线程来发送事件我们接下来看完注解 我们看一下register这个方法传入当前对象，我们直接看源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  public void register(Object subscriber) &#123;        Class&lt;?&gt; subscriberClass = subscriber.getClass();        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);        synchronized (this) &#123;            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;                subscribe(subscriber, subscriberMethod);            &#125;        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">我们看到它通过subscriberMethodFinder.findSubscriberMethods(subscriberClass);这个方法找到了一个方法集合我们看一下SubscriberMethod这个封装类先<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>public class SubscriberMethod &#123;    final Method method;    final ThreadMode threadMode;    final Class&lt;?&gt; eventType;    final int priority;    final boolean sticky;    /** Used for efficient comparison */    String methodString;    public SubscriberMethod(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, int priority, boolean sticky) &#123;        this.method = method;        this.threadMode = threadMode;        this.eventType = eventType;        this.priority = priority;        this.sticky = sticky;    &#125;&#125;<pre class="line-numbers language-none"><code class="language-none">其实就是把这个方法注解类型给封装起来包括优先级，是否粘性，线程模式，属于哪个类的我们回到 subscriberMethodFinder.findSubscriberMethods(subscriberClass)这个方法是怎么找的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);        if (subscriberMethods != null) &#123;            return subscriberMethods;        &#125;        if (ignoreGeneratedIndex) &#123;            subscriberMethods = findUsingReflection(subscriberClass);        &#125; else &#123;            subscriberMethods = findUsingInfo(subscriberClass);        &#125;        if (subscriberMethods.isEmpty()) &#123;            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);        &#125; else &#123;            METHOD_CACHE.put(subscriberClass, subscriberMethods);            return subscriberMethods;        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">先进行缓存的判断如果缓存有的话那么直接返回回去，如果缓存没有的话调用findUsingInfo方法去找我们跟到findUsingInfo中去看<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;        FindState findState = prepareFindState();        findState.initForSubscriber(subscriberClass);        while (findState.clazz != null) &#123;            findState.subscriberInfo = getSubscriberInfo(findState);            if (findState.subscriberInfo != null) &#123;                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();                for (SubscriberMethod subscriberMethod : array) &#123;                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;                        findState.subscriberMethods.add(subscriberMethod);                    &#125;                &#125;            &#125; else &#123;                findUsingReflectionInSingleClass(findState);            &#125;            findState.moveToSuperclass();        &#125;        return getMethodsAndRelease(findState);    &#125;<pre class="line-numbers language-none"><code class="language-none">我们先看一下FindState这个类 这个类里面有几个重要的列表和map有方法的集合，有方法为value 方法的参数对象为key的map 有方法为key订阅对象为value的map<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();        final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();        final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;();        final StringBuilder methodKeyBuilder = new StringBuilder(128);<pre class="line-numbers language-none"><code class="language-none">我们回到前面prepareFindState这方法是从池子中看能不能找到一样的，可以就复用 不可以就创建一个然后调用initForSubscriber这个方法这个方法其实是一些简单赋值操作我们看源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;        FindState findState = prepareFindState();        findState.initForSubscriber(subscriberClass);        while (findState.clazz != null) &#123;            findState.subscriberInfo = getSubscriberInfo(findState);            if (findState.subscriberInfo != null) &#123;                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();                for (SubscriberMethod subscriberMethod : array) &#123;                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;                        findState.subscriberMethods.add(subscriberMethod);                    &#125;                &#125;            &#125; else &#123;                findUsingReflectionInSingleClass(findState);            &#125;            findState.moveToSuperclass();        &#125;        return getMethodsAndRelease(findState);    &#125;<pre class="line-numbers language-none"><code class="language-none">其实大部分的情况下都会走到findUsingReflectionInSingleClass这个方法，这个才是解析注解方法的核心,我们看一下源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> private void findUsingReflectionInSingleClass(FindState findState) &#123;        Method[] methods;        try &#123;            // This is faster than getMethods, especially when subscribers are fat classes like Activities            methods = findState.clazz.getDeclaredMethods();        &#125; catch (Throwable th) &#123;            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149            methods = findState.clazz.getMethods();            findState.skipSuperClasses = true;        &#125;        for (Method method : methods) &#123;            int modifiers = method.getModifiers();            if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123;                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();                if (parameterTypes.length == 1) &#123;                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);                    if (subscribeAnnotation != null) &#123;                        Class&lt;?&gt; eventType = parameterTypes[0];                        if (findState.checkAdd(method, eventType)) &#123;                            ThreadMode threadMode = subscribeAnnotation.threadMode();                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));                        &#125;                    &#125;                &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;                    String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();                    throw new EventBusException(&quot;@Subscribe method &quot; + methodName +                            &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);                &#125;            &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();                throw new EventBusException(methodName +                        &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);            &#125;        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">首先通过findState的有一个订阅者的类反射拿到所有方法，对所有方法进行遍历，对每个方法进行遍历方法必须为PUBLIC，参数长度必须为1，然后必须有Subscribe这个注解获取方法的线程模式，是否是粘性事件，权重大小等 加入到findState的 subscriberMethods就是方法集合，最后返回方法集合，subscriberMethods这个类已经在上面详细讲解了，其实就是一个方法的封装,我们回到EventBus 的register方法 其实我们上面就是做好找到所有的方法并且每个方法都封装好最后成为一个 List subscriberMethods这个方法列表我们回顾一下源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> public void register(Object subscriber) &#123;        Class&lt;?&gt; subscriberClass = subscriber.getClass();        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);        synchronized (this) &#123;            for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;                subscribe(subscriber, subscriberMethod);            &#125;        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">我们看一下 subscribe(subscriber, subscriberMethod);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;        Class&lt;?&gt; eventType = subscriberMethod.eventType;        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);        if (subscriptions == null) &#123;            subscriptions = new CopyOnWriteArrayList&lt;&gt;();            subscriptionsByEventType.put(eventType, subscriptions);        &#125; else &#123;            if (subscriptions.contains(newSubscription)) &#123;                throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;                        + eventType);            &#125;        &#125;        int size = subscriptions.size();        for (int i = 0; i &lt;= size; i++) &#123;            if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;                subscriptions.add(i, newSubscription);                break;            &#125;        &#125;        List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);        if (subscribedEvents == null) &#123;            subscribedEvents = new ArrayList&lt;&gt;();            typesBySubscriber.put(subscriber, subscribedEvents);        &#125;        subscribedEvents.add(eventType);        if (subscriberMethod.sticky) &#123;            if (eventInheritance) &#123;          &lt;Class&gt;).                Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();                for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;                    Class&lt;?&gt; candidateEventType = entry.getKey();                    if (eventType.isAssignableFrom(candidateEventType)) &#123;                        Object stickyEvent = entry.getValue();                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);                    &#125;                &#125;            &#125; else &#123;                Object stickyEvent = stickyEvents.get(eventType);                checkPostStickyEventToSubscription(newSubscription, stickyEvent);            &#125;        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>final class Subscription &#123;    final Object subscriber;    final SubscriberMethod subscriberMethod;    &#125;<pre class="line-numbers language-none"><code class="language-none">我们先看一下Subscription 点击进去其实就是一个更大的封装类里面有每个一个订阅者 对应一个方法，我们接下里看下面代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);        if (subscriptions == null) &#123;            subscriptions = new CopyOnWriteArrayList&lt;&gt;();            subscriptionsByEventType.put(eventType, subscriptions);<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>我们先总结一下subscribe这个方法做了什么（1）首先判断是否有注册过改事件了如果注册了就抛出异常，如果没有就是正常的，创建一个Subscription 其实这个类就是一个注册类对应一个方法的封装，然后创建一个列表（2）按优先级加入subscriptionsByEventType 这个是一个已发出的参数类型为key subscriptions为value的map集合，然后将subscription根据优先级加入value中（3）然后在添加到typesBySubscriber的value的list中这个是以Subscriber为key 方法的参数为value的map中（4）分发粘性事件checkPostStickyEventToSubscription我们简单看一下checkPostStickyEventToSubscription,其实他最后是调用postToSubscription方法通过不同的线程模式调用不同的分发器，不同的分发器我们等一下讲，这里我们只要知道粘性事件也是走到了这里就可以了<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>  private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123;        if (stickyEvent != null) &#123;            // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)            // --&gt; Strange corner case, which we don&#39;t take care of here.            postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>    private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;        switch (subscription.subscriberMethod.threadMode) &#123;            case POSTING:                invokeSubscriber(subscription, event);                break;            case MAIN:                if (isMainThread) &#123;                    invokeSubscriber(subscription, event);                &#125; else &#123;                    mainThreadPoster.enqueue(subscription, event);                &#125;                break;            case BACKGROUND:                if (isMainThread) &#123;                    backgroundPoster.enqueue(subscription, event);                &#125; else &#123;                    invokeSubscriber(subscription, event);                &#125;                break;            case ASYNC:                asyncPoster.enqueue(subscription, event);                break;            default:                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">最后我们注册好了之后，我们就要来最后一步发送事件了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>    public void postEvent() &#123;        EventBus.getDefault().post(new MyBusEvent(&quot;hhh&quot;));    &#125;<pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>public void post(Object event) &#123;        PostingThreadState postingState = currentPostingThreadState.get();        List&lt;Object&gt; eventQueue = postingState.eventQueue;        eventQueue.add(event);        if (!postingState.isPosting) &#123;            postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();            postingState.isPosting = true;            if (postingState.canceled) &#123;                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);            &#125;            try &#123;                while (!eventQueue.isEmpty()) &#123;                    postSingleEvent(eventQueue.remove(0), postingState);                &#125;            &#125; finally &#123;                postingState.isPosting = false;                postingState.isMainThread = false;            &#125;        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">我们先看一下PostingThreadState<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> final static class PostingThreadState &#123;        final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;();        boolean isPosting;        boolean isMainThread;        Subscription subscription;        Object event;        boolean canceled;    &#125;<pre class="line-numbers language-none"><code class="language-none">其实就是事件发送的一个封装类，包括是否正在发送，是否主线程是否取消等，然后调用postSingleEvent方法，我们看如何实现的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;        Class&lt;?&gt; eventClass = event.getClass();        boolean subscriptionFound = false;        if (eventInheritance) &#123;            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);            int countTypes = eventTypes.size();            for (int h = 0; h &lt; countTypes; h++) &#123;                Class&lt;?&gt; clazz = eventTypes.get(h);                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);            &#125;        &#125; else &#123;            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);        &#125;        if (!subscriptionFound) &#123;            if (logNoSubscriberMessages) &#123;                Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass);            &#125;            if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;                    eventClass != SubscriberExceptionEvent.class) &#123;                post(new NoSubscriberEvent(this, event));            &#125;        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">做了很多处理 我们直接看postSingleEventForEventType方法，它返回了subscriptionFound 如果这个发送信息失败的话，就会打印出来，没有这个监听者，我们看一下postSingleEventForEventType是如何发送的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;        synchronized (this) &#123;            subscriptions = subscriptionsByEventType.get(eventClass);        &#125;        if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123;            for (Subscription subscription : subscriptions) &#123;                postingState.event = event;                postingState.subscription = subscription;                boolean aborted = false;                try &#123;                    postToSubscription(subscription, event, postingState.isMainThread);                    aborted = postingState.canceled;                &#125; finally &#123;                    postingState.event = null;                    postingState.subscription = null;                    postingState.canceled = false;                &#125;                if (aborted) &#123;                    break;                &#125;            &#125;            return true;        &#125;        return false;    &#125;<pre class="line-numbers language-none"><code class="language-none">我们可以看到它通过post的事件类型去从subscriptionsByEventType这个map中找到subscriptions这个对象然后调动postToSubscription这个方法最后释放之类的就不讲了，我们直接看postToSubscription这个方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;        switch (subscription.subscriberMethod.threadMode) &#123;            case POSTING:                invokeSubscriber(subscription, event);                break;            case MAIN:                if (isMainThread) &#123;                    invokeSubscriber(subscription, event);                &#125; else &#123;                    mainThreadPoster.enqueue(subscription, event);                &#125;                break;            case BACKGROUND:                if (isMainThread) &#123;                    backgroundPoster.enqueue(subscription, event);                &#125; else &#123;                    invokeSubscriber(subscription, event);                &#125;                break;            case ASYNC:                asyncPoster.enqueue(subscription, event);                break;            default:                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">这个方法上面也有提到 我们详细展开讲解，根据方法的一个线程模式采用四种不同的方式如果方法注册使用主线程方式那么如果发送也在主线程那么直接使用invokeSubscriber，这个其实是使用反射机制调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>void invokeSubscriber(Subscription subscription, Object event) &#123;        try &#123;            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);        &#125; catch (InvocationTargetException e) &#123;            handleSubscriberException(subscription, event, e.getCause());        &#125; catch (IllegalAccessException e) &#123;            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);        &#125;    &#125;<pre class="line-numbers language-none"><code class="language-none">如果注册主线程但是发送广播是在子线程的话，那么使用 mainThreadPoster.enqueue(subscription, event);mainThreadPoster这个类之前也有讲过 其实就是继承Runnable开启了一个线程我们回顾一下源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>final class HandlerPoster extends Handler &#123;   private final PendingPostQueue queue;   private final int maxMillisInsideHandleMessage;   private final EventBus eventBus;   private boolean handlerActive;   HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123;       super(looper);       this.eventBus = eventBus;       this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;       queue = new PendingPostQueue();   &#125;   void enqueue(Subscription subscription, Object event) &#123;       PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);       synchronized (this) &#123;           queue.enqueue(pendingPost);           if (!handlerActive) &#123;               handlerActive = true;               if (!sendMessage(obtainMessage())) &#123;                   throw new EventBusException(&quot;Could not send handler message&quot;);               &#125;           &#125;       &#125;   &#125;   @Override   public void handleMessage(Message msg) &#123;       boolean rescheduled = false;       try &#123;           long started = SystemClock.uptimeMillis();           while (true) &#123;               PendingPost pendingPost = queue.poll();               if (pendingPost == null) &#123;                   synchronized (this) &#123;                       // Check again, this time in synchronized                       pendingPost = queue.poll();                       if (pendingPost == null) &#123;                           handlerActive = false;                           return;                       &#125;                   &#125;               &#125;               eventBus.invokeSubscriber(pendingPost);               long timeInMethod = SystemClock.uptimeMillis() - started;               if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;                   if (!sendMessage(obtainMessage())) &#123;                       throw new EventBusException(&quot;Could not send handler message&quot;);                   &#125;                   rescheduled = true;                   return;               &#125;           &#125;       &#125; finally &#123;           handlerActive = rescheduled;       &#125;   &#125;&#125;<pre class="line-numbers language-none"><code class="language-none">这里其实就是通过handler来调用 eventBus.invokeSubscriber(pendingPost);来执行反射操作，换汤不换药如果你方法注册用BACKGROUND且发送在主线程那么就使用BackgroundPoster，它其实就是一个线程，run方法的意思就是死循环然后将消息队列里面的所有信息全部调用反射去执行如果你方法注册使用ASYNC 那么就会使用 asyncPoster.enqueue(subscription, event);这个asyncPoster其实也是一个线程，只是它每次取队列的一个进行反射调用我们最后看一下反注册方法unregister方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> public synchronized void unregister(Object subscriber) &#123;        List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);        if (subscribedTypes != null) &#123;            for (Class&lt;?&gt; eventType : subscribedTypes) &#123;                unsubscribeByEventType(subscriber, eventType);            &#125;            typesBySubscriber.remove(subscriber);        &#125; else &#123;            Log.w(TAG, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());        &#125;    &#125;private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;        List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);        if (subscriptions != null) &#123;            int size = subscriptions.size();            for (int i = 0; i &lt; size; i++) &#123;                Subscription subscription = subscriptions.get(i);                if (subscription.subscriber == subscriber) &#123;                    subscription.active = false;                    subscriptions.remove(i);                    i--;                    size--;                &#125;            &#125;        &#125;    &#125;```其实它很简单 就是将typesBySubscriber这个map中的对应key和value给删除掉 这样post方法就找不到这个 subscriptionsByEventType这个map也要删除掉对应的信息。4.总结看完了源码我们至少要懂得几个东西，一个是EventBus是靠两个关键的map来维护的，通过发送的事件类型来找到对应的方法来通过反射机制调用这个方法，这中间还穿插着很多知识点，像不同的线程采用不同的分发器，对方法的解析（反射拿到类所有方法进行遍历 ）和封装等。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h2 id=&quot;EventBus作为一款事件发布的第三方开源框架，几乎是每个项目都会使用到，使用它可以对Fragment和Fragment之间-A</summary>
      
    
    
    
    <category term="源码阅读" scheme="http://example.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="源码阅读" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MAT内存泄露与内存抖动</title>
    <link href="http://example.com/2021/03/08/%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2MAT%E6%A3%80%E6%B5%8B/"/>
    <id>http://example.com/2021/03/08/%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2MAT%E6%A3%80%E6%B5%8B/</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2022-04-10T12:26:19.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>在开发App的过程中我们会经常遇到内存抖动或者内存泄露的问题，我们需要用一些常用的工具去定位这些问题，但是像leakCarray之类的工具无脑的使用，总有一些地方是分析不了的，所以我们还是需要去分析内存泄露的本质，我们需要去了解所谓泄露的真正原因。</p><h2 id="2、内存抖动"><a href="#2、内存抖动" class="headerlink" title="2、内存抖动"></a>2、内存抖动</h2><h3 id="2-1、定义"><a href="#2-1、定义" class="headerlink" title="2.1、定义"></a>2.1、定义</h3><p>短时间内有大量对象创建销毁，它伴随着频繁的GC，所以就会有内存一边创建一边被GC掉的情况，只是在面试的时候容易搞出高大上的名词，把开发者问住了，我们可以通过Profile就可以检测出来了</p><h3 id="2-2、举个例子"><a href="#2-2、举个例子" class="headerlink" title="2.2、举个例子"></a>2.2、举个例子</h3><p>我循环遍历出于很多没有使用的对象，这个对象可能没有使用到，会被GC回收掉，但是我又再不断地创建</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">findViewById<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>leak_more<span class="token punctuation">)</span><span class="token punctuation">.</span>setOnClickListener <span class="token punctuation">&#123;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span>index in <span class="token number">0.</span><span class="token number">.10000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token keyword">var</span> paint <span class="token operator">=</span> <span class="token class-name">Paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/shake.png" alt="内存抖动图"></p><p>可以看到图是一个动态的齿状，一边创建出来 一边又被回收了，所以产生了这样的波浪状</p><p><img src="/images/dump_number.png" alt="内存数量图"><br>我们打开AndroidStudio在有问题的地方划上一个区域，下边会弹出一个对应的对象，你评估哪些对象个数是不合理的，像上面的例子就是Paint 是不合理的，一段时间内出现了十万个，点击字符串会出现右上角的对象，再点击右上角会出现代码在哪一行创建的，可以定位创建的地点，就可以定位解决问题了。</p><h3 id="2-3预防"><a href="#2-3预防" class="headerlink" title="2.3预防"></a>2.3预防</h3><p>（1）避免在循环中创建对象；<br>（2）避免在频繁调用的方法中创建对象，如View的onDraw方法;<br>（3）允许复用的情况下，使用对象池进行缓存，如：Handler的Message单链表(obtain)</p><h2 id="3、内存泄露"><a href="#3、内存泄露" class="headerlink" title="3、内存泄露"></a>3、内存泄露</h2><p>程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，一般来说长生命周期对象持有短生命周期对象强引用，从而导致短生命周期对象无法被回收！</p><h3 id="3-1、原理-可达性分析法"><a href="#3-1、原理-可达性分析法" class="headerlink" title="3.1、原理 可达性分析法"></a>3.1、原理 可达性分析法</h3><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所有的引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的</p><p><img src="/images/kedaxing.png" alt="可达性图"></p><h2 id="3-2、软引用，弱引用"><a href="#3-2、软引用，弱引用" class="headerlink" title="3.2、软引用，弱引用"></a>3.2、软引用，弱引用</h2><p>软引用：定义一些还有用但并非必须的对象。对于软引用关联的对象，GC不会直接回收，而是在系统将要内存溢出之前才会触发GC将这些对象进行回收。<br>弱引用：同样定义非必须对象。被弱引用关联的对象在GC执行时会被直接回收。</p><h2 id="3-3、检测"><a href="#3-3、检测" class="headerlink" title="3.3、检测"></a>3.3、检测</h2><p>内存泄露检测的方式有比较多种，之前其他地方有介绍过LeakCarray的使用和原理，今天主要介绍使用MAT工具进行检测</p><p><img src="/images/leak.png" alt="泄露代码"><br>故意写了一个handler 内存泄露</p><p>从memory profile 取出一段内存，这段内存可能就存在内存泄露的信息，我们进行分析一下<br><img src="/images/leak_info.png" alt="泄露的信息dump"></p><p>我取一些样本比如我们保存为 15.hprof 然后我们需要用Android SDK自带的 hprof-conv 环境怎么配我就不在这里细说了，需要的小伙伴自信查阅一下资料</p><p><img src="/images/hprof.png" alt="java 内存信息"></p><p>然后我们使用命令<br>hprof-conv -z 15.hprof 16.hprof 转换一下 然后用 elipse的mat 打开 一下 mat 没有的去下载就可以了,下载和环境配置由于篇幅问题就不在这里细讲了</p><p>用mat工具打开转换后的hprof文件，我们可以看到首页长这样<br><img src="/images/mat_first.png" alt="mat 打开后首页"></p><p>找到Histogram将它打开，我们可以看到好多个对象，先找到你要判别的对象，然后将他们的各种引用给去掉</p><p><img src="/images/gc_leak.png" alt="我们查看去掉各种引用后"></p><p>如果是这样的图说明去掉各种应用后这个对象还是存在的，也就是GC不掉的，它存在引用，所以GC是回收不了的，如果这个不在你的预计之中，比如这个Activity在你的计划之中，是应该finish掉的，但是它现在却存在且无法GC回收，那就是要考虑是不是存在内存泄露</p><p><img src="/images/has_leak.png" alt="去掉各种引用的结果"></p><p>如果结果是这样的，那么就说明不存在这个内存泄露的可能，对象都没有引用<br><img src="/images/no_leak.png" alt="去掉各种引用的结果"></p><p>以上就是通过MAT工具进行查看内存的回收情况，其本质还是紧紧围绕长生命周期的对象有没有引用到短生命周期的对象，判断是否泄露的标准还是可达性分析。</p><h2 id="4、使用AndroidStudio-Profiler进行内存泄露分析"><a href="#4、使用AndroidStudio-Profiler进行内存泄露分析" class="headerlink" title="4、使用AndroidStudio Profiler进行内存泄露分析"></a>4、使用AndroidStudio Profiler进行内存泄露分析</h2><h3 id="4-1、使用AndroidStudio现在就支持内存泄露的检查"><a href="#4-1、使用AndroidStudio现在就支持内存泄露的检查" class="headerlink" title="4.1、使用AndroidStudio现在就支持内存泄露的检查"></a>4.1、使用AndroidStudio现在就支持内存泄露的检查</h3><p>举个例子</p><p>有一个前置Activity</p><pre class="line-numbers language-none"><code class="language-none">class LeakBeforeActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_memory_leak_before)        findViewById&lt;Button&gt;(R.id.start_next).setOnClickListener &#123;            var intent &#x3D; Intent(this, MemoryLeakActivity::class.java)            startActivity(intent)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:ignore&#x3D;&quot;MissingDefaultResource&quot;&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;start_next&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;跳转到下一页&quot;&gt;&lt;&#x2F;Button&gt;    &lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个Activity</p><pre class="line-numbers language-none"><code class="language-none">class MemoryLeakActivity : AppCompatActivity(),CallBack &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_memory_leak);        val imageView &#x3D; findViewById&lt;ImageView&gt;(R.id.iv_memoryleak)        val bitmap &#x3D; BitmapFactory.decodeResource(resources, R.mipmap.icon)        imageView.setImageBitmap(bitmap)        CallBackManager.addCallBack(this)        findViewById&lt;Button&gt;(R.id.finish).setOnClickListener &#123;            finish()        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">class CallBackManager &#123;    companion object &#123;        val sCallBacks &#x3D; ArrayList&lt;CallBack&gt;()        fun addCallBack(call: CallBack) &#123;            sCallBacks.add(call)        &#125;        fun removeCallBack(call: CallBack) &#123;            sCallBacks.remove(call)        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;    android:layout_width&#x3D;&quot;match_parent&quot;    android:layout_height&#x3D;&quot;match_parent&quot;    android:orientation&#x3D;&quot;vertical&quot;    tools:ignore&#x3D;&quot;MissingDefaultResource&quot;&gt;    &lt;ImageView        android:id&#x3D;&quot;@+id&#x2F;iv_memoryleak&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;哈哈哈&quot;&gt;&lt;&#x2F;ImageView&gt;    &lt;Button        android:id&#x3D;&quot;@+id&#x2F;finish&quot;        android:layout_width&#x3D;&quot;wrap_content&quot;        android:layout_height&#x3D;&quot;wrap_content&quot;        android:text&#x3D;&quot;结束&quot;        &gt;&lt;&#x2F;Button&gt;    &lt;&#x2F;LinearLayout&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们反复开关Activty Activity就会被静态列表所引用，导致无法被回收，导致内存泄露<br>  val sCallBacks = ArrayList<CallBack>() 就是引用的集合</p><p>  <img src="/images/img_leak_big.png" alt="内存泄露图"></p><p> 划定一块内存dump 一块内存看</p><p>  <img src="/images/android_sudio_leak_info.png" alt="内存泄露详细数据"></p><p>我们从dump的数据可以看到  分配的内存情况，哪些数据占用了大内存，包括内存的引用情况都可以看到，值得注意的是左上角提示了我们有四个内存泄露，我们需要重点关注，我们点击进去看看，内存具体泄露在了哪里</p><p> <img src="/images/leak_detail.png" alt="内存泄露详细位置"> </p><p> 我们可以看到内存泄露的Activity  点击后点击右下角的应用，勾上显示引用的路径，我们就可以看到引用的路劲这样就知道为什么内存泄露 从而进行解决了。</p><p>个人是比较喜欢这种方式解决内存泄露的</p><h2 id="5、常见的内存泄露的场景如下，开发的时候记得多进行检讨"><a href="#5、常见的内存泄露的场景如下，开发的时候记得多进行检讨" class="headerlink" title="5、常见的内存泄露的场景如下，开发的时候记得多进行检讨"></a>5、常见的内存泄露的场景如下，开发的时候记得多进行检讨</h2><p>1、Handler持有的引用最好使用弱引用，在Activity被释放的时候要记得清空Message，取消Handler对象的Runnable；<br>2、非静态内部类、非静态匿名内部类会自动持有外部类的引用，为避免内存泄露，可以考虑把内部类声明为静态的；<br>3、对于生命周期比Activity长的对象，要避免直接引用Activity的context，可以考虑使用ApplicationContext；<br>4、广播接收器、EventBus等的使用过程中，注册/反注册应该成对使用；<br>5、不再使用的资源对象Cursor、File、Bitmap等要记住正确关闭；<br>6、集合里面的东西、有加入就应该对应有相应的删除；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h2&gt;&lt;p&gt;在开发App的过程中我们会经常遇到内存抖动或者内存泄露的问题，我们需要用一些常用的工具去定位这些问题，但是像leakCarr</summary>
      
    
    
    
    <category term="软件优化" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="软件优化" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary 详解</title>
    <link href="http://example.com/2021/03/05/LeakCanary/"/>
    <id>http://example.com/2021/03/05/LeakCanary/</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2021-11-07T05:00:29.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>LeakCanary 是一种方便的内存泄露检查工具，与相对于用dump 内存 然后用MAT工具去分析，要简单便捷很多，我们需要了解如何使用这个工具及其背后的原理</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>加入远程引用,强烈建议使用1.6以上的版本，以下的版本有各种各样的问题</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">debugCompile <span class="token string">'com.squareup.leakcanary:leakcanary-android:1.6.1'</span>   releaseCompile <span class="token string">'com.squareup.leakcanary:leakcanary-android-no-op:1.6.1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然你还需要添加一些权限说明</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>外部存储的写权限<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">uses</span><span class="token operator">-</span>permission android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>外部存储的读权限<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">uses</span><span class="token operator">-</span>permission android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.permission.READ_EXTERNAL_STORAGE"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">uses</span><span class="token operator">-</span>permission android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">uses</span><span class="token operator">-</span>permission android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.permission.WRITE_EXTERNAL_STORAGE"</span><span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在你的application中加入一行代码，接入工作就是算做完了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">LeakCanary</span><span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * Creates a &#123;@link RefWatcher&#125; that works out of the box, and starts watching activity  * references (on ICS+).  */</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">RefWatcher</span> <span class="token function">install</span><span class="token punctuation">(</span><span class="token class-name">Application</span> application<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token function">refWatcher</span><span class="token punctuation">(</span>application<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listenerServiceClass</span><span class="token punctuation">(</span><span class="token class-name">DisplayLeakService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">excludedRefs</span><span class="token punctuation">(</span><span class="token class-name">AndroidExcludedRefs</span><span class="token punctuation">.</span><span class="token function">createAppDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token function">buildAndInstall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建了一个RefWatcher 用来监控Activity的引用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">RefWatcher</span> <span class="token function">buildAndInstall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">LeakCanaryInternals</span><span class="token punctuation">.</span>installedRefWatcher <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"buildAndInstall() should only be called once."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token class-name">RefWatcher</span> refWatcher <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>refWatcher <span class="token operator">!=</span> DISABLED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>watchActivities<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">ActivityRefWatcher</span><span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> refWatcher<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>watchFragments<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">FragmentRefWatcher<span class="token punctuation">.</span>Helper</span><span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> refWatcher<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token class-name">LeakCanaryInternals</span><span class="token punctuation">.</span>installedRefWatcher <span class="token operator">=</span> refWatcher<span class="token punctuation">;</span>  <span class="token keyword">return</span> refWatcher<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">install</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">,</span> <span class="token class-name">RefWatcher</span> refWatcher<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">Application</span> application <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Application</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">ActivityRefWatcher</span> activityRefWatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActivityRefWatcher</span><span class="token punctuation">(</span>application<span class="token punctuation">,</span> refWatcher<span class="token punctuation">)</span><span class="token punctuation">;</span>   application<span class="token punctuation">.</span><span class="token function">registerActivityLifecycleCallbacks</span><span class="token punctuation">(</span>activityRefWatcher<span class="token punctuation">.</span>lifecycleCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一块其实是用Android 原生的方法，监听Activity的生命周期，只是把回调传进去了application</p><p>我们可以看一下整个的ActivityRefWatcher 最后Activity的销毁方法执行的时候会调用到 refWatcher.watch(activity)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ActivityRefWatcher</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">installOnIcsPlus</span><span class="token punctuation">(</span><span class="token class-name">Application</span> application<span class="token punctuation">,</span> <span class="token class-name">RefWatcher</span> refWatcher<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">install</span><span class="token punctuation">(</span>application<span class="token punctuation">,</span> refWatcher<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">install</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">,</span> <span class="token class-name">RefWatcher</span> refWatcher<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Application</span> application <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Application</span><span class="token punctuation">)</span> context<span class="token punctuation">.</span><span class="token function">getApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ActivityRefWatcher</span> activityRefWatcher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActivityRefWatcher</span><span class="token punctuation">(</span>application<span class="token punctuation">,</span> refWatcher<span class="token punctuation">)</span><span class="token punctuation">;</span>    application<span class="token punctuation">.</span><span class="token function">registerActivityLifecycleCallbacks</span><span class="token punctuation">(</span>activityRefWatcher<span class="token punctuation">.</span>lifecycleCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Application<span class="token punctuation">.</span>ActivityLifecycleCallbacks</span> lifecycleCallbacks <span class="token operator">=</span>      <span class="token keyword">new</span> <span class="token class-name">ActivityLifecycleCallbacksAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onActivityDestroyed</span><span class="token punctuation">(</span><span class="token class-name">Activity</span> activity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          refWatcher<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Application</span> application<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">RefWatcher</span> refWatcher<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">ActivityRefWatcher</span><span class="token punctuation">(</span><span class="token class-name">Application</span> application<span class="token punctuation">,</span> <span class="token class-name">RefWatcher</span> refWatcher<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>application <span class="token operator">=</span> application<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>refWatcher <span class="token operator">=</span> refWatcher<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">watchActivities</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Make sure you don't get installed twice.</span>    <span class="token function">stopWatchingActivities</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    application<span class="token punctuation">.</span><span class="token function">registerActivityLifecycleCallbacks</span><span class="token punctuation">(</span>lifecycleCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stopWatchingActivities</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    application<span class="token punctuation">.</span><span class="token function">unregisterActivityLifecycleCallbacks</span><span class="token punctuation">(</span>lifecycleCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看下一 refWatcher.watch(activity) 是执行了什么</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Watches the provided references and checks if it can be GCed. This method is non blocking, * the check is done on the &#123;@link WatchExecutor&#125; this &#123;@link RefWatcher&#125; has been constructed * with. * * @param referenceName An logical identifier for the watched object. */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">watch</span><span class="token punctuation">(</span><span class="token class-name">Object</span> watchedReference<span class="token punctuation">,</span> <span class="token class-name">String</span> referenceName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> DISABLED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">checkNotNull</span><span class="token punctuation">(</span>watchedReference<span class="token punctuation">,</span> <span class="token string">"watchedReference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">checkNotNull</span><span class="token punctuation">(</span>referenceName<span class="token punctuation">,</span> <span class="token string">"referenceName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token keyword">long</span> watchStartNanoTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">String</span> key <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  retainedKeys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token class-name">KeyedWeakReference</span> reference <span class="token operator">=</span>      <span class="token keyword">new</span> <span class="token class-name">KeyedWeakReference</span><span class="token punctuation">(</span>watchedReference<span class="token punctuation">,</span> key<span class="token punctuation">,</span> referenceName<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ensureGoneAsync</span><span class="token punctuation">(</span>watchStartNanoTime<span class="token punctuation">,</span> reference<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KeyedWeakReference 是一种弱引用，所以是将这个Activity对象给包了一层弱引用 然后开始GC</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">KeyedWeakReference</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> key<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token class-name">KeyedWeakReference</span><span class="token punctuation">(</span><span class="token class-name">Object</span> referent<span class="token punctuation">,</span> <span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span>      <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> referenceQueue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token function">checkNotNull</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> <span class="token string">"referent"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">checkNotNull</span><span class="token punctuation">(</span>referenceQueue<span class="token punctuation">,</span> <span class="token string">"referenceQueue"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token function">checkNotNull</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token function">checkNotNull</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看最关键的ensureGoneAsync 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"ReferenceEquality"</span><span class="token punctuation">)</span> <span class="token comment">// Explicitly checking for named null.</span>  <span class="token class-name">Retryable<span class="token punctuation">.</span>Result</span> <span class="token function">ensureGone</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">KeyedWeakReference</span> reference<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">long</span> watchStartNanoTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> gcStartNanoTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> watchDurationMs <span class="token operator">=</span> NANOSECONDS<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>gcStartNanoTime <span class="token operator">-</span> watchStartNanoTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">removeWeaklyReachableReferences</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>debuggerControl<span class="token punctuation">.</span><span class="token function">isDebuggerAttached</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// The debugger can create false leaks.</span>      <span class="token keyword">return</span> RETRY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">gone</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> DONE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    gcTrigger<span class="token punctuation">.</span><span class="token function">runGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">removeWeaklyReachableReferences</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">gone</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">long</span> startDumpHeap <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">long</span> gcDurationMs <span class="token operator">=</span> NANOSECONDS<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>startDumpHeap <span class="token operator">-</span> gcStartNanoTime<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">File</span> heapDumpFile <span class="token operator">=</span> heapDumper<span class="token punctuation">.</span><span class="token function">dumpHeap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>heapDumpFile <span class="token operator">==</span> RETRY_LATER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Could not dump the heap.</span>        <span class="token keyword">return</span> RETRY<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">long</span> heapDumpDurationMs <span class="token operator">=</span> NANOSECONDS<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startDumpHeap<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">HeapDump</span> heapDump <span class="token operator">=</span> heapDumpBuilder<span class="token punctuation">.</span><span class="token function">heapDumpFile</span><span class="token punctuation">(</span>heapDumpFile<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">referenceKey</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span>key<span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">referenceName</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span>name<span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">watchDurationMs</span><span class="token punctuation">(</span>watchDurationMs<span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">gcDurationMs</span><span class="token punctuation">(</span>gcDurationMs<span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">heapDumpDurationMs</span><span class="token punctuation">(</span>heapDumpDurationMs<span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      heapdumpListener<span class="token punctuation">.</span><span class="token function">analyze</span><span class="token punctuation">(</span>heapDump<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> DONE<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个是第一层GC判断 就是如果刚好加入就被GC掉了 那个中介Done了 如果暂时还没有被GC掉 那么就走gone(reference)方法<br>把heapDump信息给拿出来进行真正的分析判断 我们看一下 heapdumpListener.analyze(heapDump); 这个的实现我们看一下具体细节</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HeapAnalyzerService</span> <span class="token keyword">extends</span> <span class="token class-name">ForegroundService</span>    <span class="token keyword">implements</span> <span class="token class-name">AnalyzerProgressListener</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> LISTENER_CLASS_EXTRA <span class="token operator">=</span> <span class="token string">"listener_class_extra"</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> HEAPDUMP_EXTRA <span class="token operator">=</span> <span class="token string">"heapdump_extra"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runAnalysis</span><span class="token punctuation">(</span><span class="token class-name">Context</span> context<span class="token punctuation">,</span> <span class="token class-name">HeapDump</span> heapDump<span class="token punctuation">,</span>      <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractAnalysisResultService</span><span class="token punctuation">></span></span> listenerServiceClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setEnabledBlocking</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token class-name">HeapAnalyzerService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setEnabledBlocking</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> listenerServiceClass<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Intent</span> intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token class-name">HeapAnalyzerService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span>LISTENER_CLASS_EXTRA<span class="token punctuation">,</span> listenerServiceClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span>HEAPDUMP_EXTRA<span class="token punctuation">,</span> heapDump<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ContextCompat</span><span class="token punctuation">.</span><span class="token function">startForegroundService</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> intent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">HeapAnalyzerService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">HeapAnalyzerService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">.</span>string<span class="token punctuation">.</span>leak_canary_notification_analysing<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span> <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onHandleIntentInForeground</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Intent</span> intent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>intent <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">CanaryLog</span><span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"HeapAnalyzerService received a null intent, ignoring."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">String</span> listenerClassName <span class="token operator">=</span> intent<span class="token punctuation">.</span><span class="token function">getStringExtra</span><span class="token punctuation">(</span>LISTENER_CLASS_EXTRA<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HeapDump</span> heapDump <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HeapDump</span><span class="token punctuation">)</span> intent<span class="token punctuation">.</span><span class="token function">getSerializableExtra</span><span class="token punctuation">(</span>HEAPDUMP_EXTRA<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HeapAnalyzer</span> heapAnalyzer <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">HeapAnalyzer</span><span class="token punctuation">(</span>heapDump<span class="token punctuation">.</span>excludedRefs<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> heapDump<span class="token punctuation">.</span>reachabilityInspectorClasses<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">AnalysisResult</span> result <span class="token operator">=</span> heapAnalyzer<span class="token punctuation">.</span><span class="token function">checkForLeak</span><span class="token punctuation">(</span>heapDump<span class="token punctuation">.</span>heapDumpFile<span class="token punctuation">,</span> heapDump<span class="token punctuation">.</span>referenceKey<span class="token punctuation">,</span>        heapDump<span class="token punctuation">.</span>computeRetainedHeapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">AbstractAnalysisResultService</span><span class="token punctuation">.</span><span class="token function">sendResultToListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> listenerClassName<span class="token punctuation">,</span> heapDump<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onProgressUpdate</span><span class="token punctuation">(</span><span class="token class-name">Step</span> step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> percent <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">100f</span> <span class="token operator">*</span> step<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token class-name">Step</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">CanaryLog</span><span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"Analysis in progress, working on: %s"</span><span class="token punctuation">,</span> step<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> lowercase <span class="token operator">=</span> step<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> lowercase<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> lowercase<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">showForegroundNotification</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> percent<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个是一个 IntentService 抛开细节它开启这个服务 执行代码在onHandleIntentInForeground 这个方法中 我们看到 执行了heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,<br>heapDump.computeRetainedHeapSize); 这个方法</p><p>checkForLeak方法是整个项目最关键的方法 真正去判断是否存在泄露</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">AnalysisResult</span> <span class="token function">checkForLeak</span><span class="token punctuation">(</span><span class="token class-name">File</span> heapDumpFile<span class="token punctuation">,</span> <span class="token class-name">String</span> referenceKey<span class="token punctuation">,</span>    <span class="token keyword">boolean</span> computeRetainedSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">long</span> analysisStartNanoTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>heapDumpFile<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Exception</span> exception <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"File does not exist: "</span> <span class="token operator">+</span> heapDumpFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">failure</span><span class="token punctuation">(</span>exception<span class="token punctuation">,</span> <span class="token function">since</span><span class="token punctuation">(</span>analysisStartNanoTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    listener<span class="token punctuation">.</span><span class="token function">onProgressUpdate</span><span class="token punctuation">(</span>READING_HEAP_DUMP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HprofBuffer</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MemoryMappedFileBuffer</span><span class="token punctuation">(</span>heapDumpFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">HprofParser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HprofParser</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    listener<span class="token punctuation">.</span><span class="token function">onProgressUpdate</span><span class="token punctuation">(</span>PARSING_HEAP_DUMP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Snapshot</span> snapshot <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    listener<span class="token punctuation">.</span><span class="token function">onProgressUpdate</span><span class="token punctuation">(</span>DEDUPLICATING_GC_ROOTS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">deduplicateGcRoots</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>    listener<span class="token punctuation">.</span><span class="token function">onProgressUpdate</span><span class="token punctuation">(</span>FINDING_LEAKING_REF<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Instance</span> leakingRef <span class="token operator">=</span> <span class="token function">findLeakingReference</span><span class="token punctuation">(</span>referenceKey<span class="token punctuation">,</span> snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// False alarm, weak reference was cleared in between key check and heap dump.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leakingRef <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">noLeak</span><span class="token punctuation">(</span><span class="token function">since</span><span class="token punctuation">(</span>analysisStartNanoTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">findLeakTrace</span><span class="token punctuation">(</span>analysisStartNanoTime<span class="token punctuation">,</span> snapshot<span class="token punctuation">,</span> leakingRef<span class="token punctuation">,</span> computeRetainedSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">failure</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token function">since</span><span class="token punctuation">(</span>analysisStartNanoTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果找到findLeakingReference 那么就是内存泄露 findLeakTrace  如果没有找到那么就没有内存泄露</p><p>他是怎么找的呢 是通过对镜像文件里面的类进行遍历，然后将之前在镜像队列里面塞进去的key进行比较，如果存在且有没有被gc掉就认为是内存泄露</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Instance</span> <span class="token function">findLeakingReference</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Snapshot</span> snapshot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">ClassObj</span> refClass <span class="token operator">=</span> snapshot<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">KeyedWeakReference</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>refClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>          <span class="token string">"Could not find the "</span> <span class="token operator">+</span> <span class="token class-name">KeyedWeakReference</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" class in the heap dump."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> keysFound <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Instance</span> instance <span class="token operator">:</span> refClass<span class="token punctuation">.</span><span class="token function">getInstancesList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ClassInstance<span class="token punctuation">.</span>FieldValue</span><span class="token punctuation">></span></span> values <span class="token operator">=</span> <span class="token function">classInstanceValues</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">Object</span> keyFieldValue <span class="token operator">=</span> <span class="token function">fieldValue</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> <span class="token string">"key"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>keyFieldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        keysFound<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token class-name">String</span> keyCandidate <span class="token operator">=</span> <span class="token function">asString</span><span class="token punctuation">(</span>keyFieldValue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>keyCandidate<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">fieldValue</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> <span class="token string">"referent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      keysFound<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>keyCandidate<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>        <span class="token string">"Could not find weak reference with key "</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">" in "</span> <span class="token operator">+</span> keysFound<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LeakCanary 采用的就是 监听Activity的OnDestroy方法，如果调用了就搞成一个弱引用，然后放入队列中，并做上标记，通过GC后去获取这个弱引用看是否还存在，如果存在就那么就存在内存泄露，如果不存在那么说明能被GC回收不存在内存泄露</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;LeakCanary 是一种方便的内存泄露检查工具，与相对于用dump 内存 然后用MAT工具去分析，要简单便捷很多，我们需要了解如何使用这</summary>
      
    
    
    
    <category term="Android框架源码" scheme="http://example.com/categories/Android%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Android框架源码" scheme="http://example.com/tags/Android%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-Builder模式</title>
    <link href="http://example.com/2021/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-19T16:00:00.000Z</published>
    <updated>2021-10-31T07:26:47.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示；</p><h2 id="二、-举个例子"><a href="#二、-举个例子" class="headerlink" title="二、 举个例子"></a>二、 举个例子</h2><p>我们通过一个例子来引出Builder模式。假设有一个Person类，我们通过该Person类来构建一大批人，这个Person类里有很多属性，最常见的比如name，age，weight，height等等，并且我们允许这些值不被设置，也就是允许为null，该类的定义如下。</p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> height<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> height<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token keyword">double</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWeight</span><span class="token punctuation">(</span><span class="token keyword">double</span> weight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们为了方便可能会定义一个构造方法：</p><p>public Person(String name, int age, double height, double weight) { this.name = name; this.age = age; this.height = height; this.weight = weight; }</p><p>或许为了方便new对象，你还会定义一个空的构造方法</p><p>但是有时候你很懒，只想传部分参数，你还会定义如下类似的构造方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">double</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是你就可以这样创建各个需要的对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p4<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p5<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"赵六"</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">170</span><span class="token punctuation">,</span><span class="token number">65.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以想象一下这样创建的坏处，最直观的就是四个参数的构造函数的最后面的两个参数到底是什么意思，可读性不怎么好，如果不点击看源码，鬼知道哪个是weight哪个是height。还有一个问题就是当有很多参数时，编写这个构造函数就会显得异常麻烦，这时候如果换一个角度，试试Builder模式，你会发现代码的可读性一下子就上去了。</p><p>我们给Person增加一个静态内部类Builder类，并修改Person类的构造函数，代码如下。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> height<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>     <span class="token function">privatePerson</span><span class="token punctuation">(</span><span class="token class-name">Builder</span> builder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>builder<span class="token punctuation">.</span>name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>builder<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token operator">=</span>builder<span class="token punctuation">.</span>height<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>builder<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> height<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHeight</span><span class="token punctuation">(</span><span class="token keyword">double</span> height<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWeight</span><span class="token punctuation">(</span><span class="token keyword">double</span> weight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">double</span> height<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">age</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token keyword">double</span> height<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token operator">=</span>height<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">public</span> <span class="token class-name">Builder</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token keyword">double</span> weight<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>weight<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码中我们可以看到，我们在Builder类里定义了一份与Person类一模一样的变量，通过一系列的成员函数进行设置属性值，但是返回值都是this，也就是都是Builder对象，最后提供了一个build函数用于创建Person对象，返回的是Person对象，对应的构造函数在Person类中进行定义，也就是构造函数的入参是Builder对象，然后依次对自己的成员变量进行赋值，对应的值都是Builder对象中的值。此外Builder类中的成员函数返回Builder对象自身的另一个作用就是让它支持链式调用，使代码可读性大大增强<br>于是我们就可以这样创建Person类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person<span class="token punctuation">.</span>Builder</span> builder<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> person<span class="token operator">=</span>builder        <span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token number">178.5</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token number">67.4</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有没有觉得创建过程一下子就变得那么清晰了。对应的值是什么属性一目了然，可读性大大增强。</p><p>其实在Android中， Builder模式也是被大量的运用。比如常见的对话框的创建</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span> builder<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">AlertDialog<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">AlertDialog</span> dialog<span class="token operator">=</span>builder<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span><span class="token string">"标题"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">android<span class="token punctuation">.</span></span>R</span><span class="token punctuation">.</span>drawable<span class="token punctuation">.</span>ic_dialog_alert<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">setView</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>layout<span class="token punctuation">.</span>myview<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">setPositiveButton</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>string<span class="token punctuation">.</span>positive<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token class-name">DialogInterface</span> dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">setNegativeButton</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>string<span class="token punctuation">.</span>negative<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DialogInterface<span class="token punctuation">.</span>OnClickListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token class-name">DialogInterface</span> dialog<span class="token punctuation">,</span> <span class="token keyword">int</span> which<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dialog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各大框架中大量的运用了Builder模式。最后总结一下</p><p>定义一个静态内部类Builder，内部的成员变量和外部类一样<br>Builder类通过一系列的方法用于成员变量的赋值，并返回当前对象本身（this）<br>Builder类提供一个build方法或者create方法用于创建对应的外部类，该方法内部调用了外部类的一个私有构造函数，该构造函数的参数就是内部类Builder<br>外部类提供一个私有构造函数供内部类调用，在该构造函数中完成成员变量的赋值，取值为Builder对象中对应的值</p><p>四、优缺点比较<br>优点<br>良好的封装性，使用建造者模式，可以使客户端不用知道产品的内部实现，更容易扩展</p><p>缺点<br>会产生多余的Builder对象以及Director对象，消耗内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示；&lt;/p&gt;
&lt;h2 id=&quot;二、-举个例子&quot;&gt;&lt;a href=&quot;#二</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://example.com/2021/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-09T16:00:00.000Z</published>
    <updated>2021-10-31T07:08:11.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>工厂模式一个用于创建对象的接口，让子类来决定需要生产什么，可以隐藏生产的细节</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/images/factory.png" alt="类图"></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>代码实现方式可以很多，但是我比较喜欢的是客户端可以动态生成的方式，也更加动态</p><p>工厂的核心类，根据传入的类型生产确定的产品</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Prodouct</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">createFactory</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> clz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们定义两个链条 大概是根据逻辑判断是自己要处理还是交给其他人处理，如果自己处理就自己处理掉 如果别人处理是别人处理掉</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">RealFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span><span class="token punctuation">&#123;</span>   <span class="token keyword">public</span>  <span class="token class-name">RealFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">&#125;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Prodouct</span><span class="token punctuation">></span></span> <span class="token class-name">T</span> <span class="token function">createFactory</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> clz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>clz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">String</span> condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//可以是你要处理的方法</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandle2 handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>soccessor <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                soccessor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product1</span> <span class="token keyword">extends</span> <span class="token class-name">Prodouct</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product1</span> <span class="token keyword">extends</span> <span class="token class-name">Prodouct</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token class-name">RealFactory</span> realFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Product1</span> factory <span class="token operator">=</span> realFactory<span class="token punctuation">.</span><span class="token function">createFactory</span><span class="token punctuation">(</span><span class="token class-name">Product1</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、总结</p><p>工厂生产模式可以对外隐藏实现细节，生产大量的对象，优点较多，对于抽象工厂就不再深究，因为抽象工厂就是把工厂也抽象了，不同的工厂专门生产某种产品，这样会导致工厂类的爆炸，这边就不再多说，工作中这种比较动态的工厂模式是比较好用的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;工厂模式一个用于创建对象的接口，让子类来决定需要生产什么，可以隐藏生产的细节&lt;/p&gt;
&lt;h2 id=&quot;UML图&quot;&gt;&lt;a href=&quot;#UML</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式模式</title>
    <link href="http://example.com/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-07T16:00:00.000Z</published>
    <updated>2021-10-31T06:31:41.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式是一个比较实用的设计模式，在开发的时候经常遇到一种情况就是实现一个功能有多种方式，，我们可以根据不同的情况去选择不同的策略完成这个功能，当前你可以写在一个类中，加入大量的if else去判断，但是这就属于硬编码了，每次改动都会修改，不符合开闭原则，因此我们需要使用策略模式去根据不同的场景有不同的实现方案</p><h2 id="二、-责任链模式的使用场景"><a href="#二、-责任链模式的使用场景" class="headerlink" title="二、 责任链模式的使用场景"></a>二、 责任链模式的使用场景</h2><p>1.针对一类问题，有多种处理方式，但是仅仅具体行为有差异的时候<br>2.出现一类抽象类有多个子类，需要if else来选择某个子类</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/images/stragety.png" alt="类图"></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>leak<span class="token punctuation">.</span></span><span class="token class-name">Stragety</span><span class="token punctuation">;</span><span class="token keyword">interface</span>  <span class="token class-name">CalculateStragety</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusCalculateStragety</span> <span class="token keyword">implements</span> <span class="token class-name">CalculateStragety</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//开始大巴的算费标准 比如上车两块去哪里都一样</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaxiCalculateStragety</span> <span class="token keyword">implements</span> <span class="token class-name">CalculateStragety</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//开始计程车的收费标准 按公里数计算</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Calcutate</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">CalculateStragety</span> mCalculateStragety<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCalculateStragety</span><span class="token punctuation">(</span><span class="token class-name">CalculateStragety</span> calculateStragety<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        mCalculateStragety<span class="token operator">=</span>calculateStragety<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        mCalculateStragety<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">startCalculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TaxiCalculateStragety</span> taxiCalculateStragety <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaxiCalculateStragety</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//        BusCalculateStragety busCalculateStragety = new BusCalculateStragety();</span>        <span class="token class-name">Calcutate</span> calcutate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Calcutate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        calcutate<span class="token punctuation">.</span><span class="token function">setCalculateStragety</span><span class="token punctuation">(</span>taxiCalculateStragety<span class="token punctuation">)</span><span class="token punctuation">;</span>        calcutate<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们以交通费计算为例子，不同的交通方式可能收费不一样 ，如果策略模式就可以定一个抽象接口，子类有不同的实现，再定义一个计算的类，可以通过外边不同的传参数进行不同的计算策略</p><p>四、优缺点<br>1.优势<br>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。<br>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。<br>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。<br>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。<br>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离</p><p>缺点<br>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类<br>策略模式造成很多的策略类</p><p>六 状态模式与策略模式的差异<br>状态模式结构上跟策略模式非常接近 写法基本相同<br>但是状态模式更像是要去根据某种状态去做不同的事情 比如根据不同的状态去做是否可以转发数据，还是跳转到登录页面，因为要记录不同的状态所以很可能是单例，因为传入数据的地方可能不止一处地方。<br>策略模式更像是根据不同的情况去做一样的事情比如根据不同的车计算路费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;策略模式是一个比较实用的设计模式，在开发的时候经常遇到一种情况就是实现一个功能有多种方式，，我们可以根据不同的情况去选择不同的策略完成这个功</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-责任链模式</title>
    <link href="http://example.com/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-07T16:00:00.000Z</published>
    <updated>2021-10-31T05:48:56.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系</p><h2 id="二、-责任链模式的使用场景"><a href="#二、-责任链模式的使用场景" class="headerlink" title="二、 责任链模式的使用场景"></a>二、 责任链模式的使用场景</h2><p>多个对象可以请求同一请求，但具体由哪个对象处理则在运行时候动态决定<br>在请求处理者不明确的情况下向多个对象中的一个提交一个请求<br>需要动态指定一组对象处理请求</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/images/zerenlian.png" alt="类图"></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>定一个抽象的处理类 关键在与持有一个内部的自己引用</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Handler</span> soccessor<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">String</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们定义两个链条 大概是根据逻辑判断是自己要处理还是交给其他人处理，如果自己处理就自己处理掉 如果别人处理是别人处理掉</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">String</span> condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//可以是你要处理的方法</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler1 handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>soccessor <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                soccessor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token class-name">String</span> condition<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//可以是你要处理的方法</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandle2 handler"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>soccessor <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                soccessor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看在客户端 把所有链条都生产出来 然后给链条指定后前后关系，然后就在开始的链条上开始请求，因为如果有没有处理会进行下一环节，如果有处理那么就交给当前去处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span>     <span class="token annotation punctuation">@TestOnly</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ConcreteHandler1</span> concreteHandler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ConcreteHandler2</span> concreteHandler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteHandler1<span class="token punctuation">.</span>soccessor <span class="token operator">=</span> concreteHandler2<span class="token punctuation">;</span>        concreteHandler1<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、优缺点<br>优点<br>降低耦合度。它将请求的发送者和接收者解耦<br>简化了对象，使得对象不需要知道链的结构<br>增强给对象指派职责的灵活性，允许动态地新增或者删除责任链<br>增加新的请求处理类方便</p><p>缺点<br>不能保证请求一定被接收；<br>系统性能将受到一定影响，调试时不方便，可能会造成循环调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系&lt;/p&gt;
&lt;h2 id=&quot;二、-责任链模式的使用场景&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://example.com/2021/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-10-31T05:32:48.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，所有依赖与他的状态都会被通知到。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Subject 抽象的主题，也就是被观察者的角色，抽象主题角色把所有观察者对象的引用存在一个集合中，每个主题都可以有任意数量的观察者，抽象主题提供接口，可以增加删除观察者对象。</p><p>ConcreteSubject 具体，该角色将有关状态存在具体观察者对象，具体内部发生变化的时候，给所有注册过的通知者发出通知，具体主题角色又叫做具体被观察者</p><p>Observer 抽象观察者，该角色是观察者的抽象类，它定义了一个更新接口，使得在得到主题的更改通知的时候更新自己</p><p>ConCreteObserver 具体的观察者，该角色实现抽象观察者实现的接口，以便在主题变化的时候更新自身状态</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/images/observer.png" alt="观察者模式类图"></p><h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>最简单的例子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coder</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token class-name">Coder</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Observable</span> o<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到通知"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DevTechFrontier</span> <span class="token keyword">extends</span> <span class="token class-name">Observable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postNewTouchPublication</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ExampleUnitTest</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Test</span>    fun <span class="token function">addition_isCorrect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val devTechFrontier <span class="token operator">=</span> <span class="token class-name">DevTechFrontier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        val coder <span class="token operator">=</span> <span class="token class-name">Coder</span><span class="token punctuation">(</span><span class="token string">"coder1"</span><span class="token punctuation">)</span>        devTechFrontier<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>coder<span class="token punctuation">)</span>        devTechFrontier<span class="token punctuation">.</span><span class="token function">postNewTouchPublication</span><span class="token punctuation">(</span><span class="token string">"新的技术周刊发布"</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用的例子<br>因为Observable和Observer 是内嵌入JDK中的所以可以直接可以用到，后续一般情况下可以比如Observer 这个接口放在 Observable的一个map或者list之中，在需要通知的时候遍历这个集合回调即可，当然 需要给出的是一个注册和取消注册的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">WeatherObserver</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">notifyWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeiJingWeather</span> <span class="token keyword">implements</span> <span class="token class-name">WeatherObserver</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"notifyWeather:这里是北京，收到通知 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public class GuangDongWeather implements WeatherObserver &#123;    @Override    public void notifyWeather() &#123;        System.out.println(&quot;notifyWeather:这里是广东，收到通知 &quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>leak<span class="token punctuation">.</span>observer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeatherObservable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WeatherObserver</span><span class="token punctuation">></span></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resiter</span><span class="token punctuation">(</span><span class="token class-name">WeatherObserver</span> observer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unresiter</span><span class="token punctuation">(</span><span class="token class-name">WeatherObserver</span> observer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyAllWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">notifyWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种自己实现的观察者模式才是比较常见能解耦两个模块</p><p>优缺点<br>1.观察者模式和被观察者之间是抽象耦合，应对业务变化<br>2.增强系统灵活性，可扩展性</p><p>缺点<br>在应用观察者模式时，需要考虑一下开发效率和运行效率问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，所有依赖与他的状态都会被通知到。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-备忘录模式</title>
    <link href="http://example.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/04/%E8%AE%BE%E8%AE%A1%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-03T16:00:00.000Z</published>
    <updated>2021-10-31T05:32:05.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后可以将对象恢复到原先保存的状态。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要保存一个对象在某个时刻的某种状态或部分状态。<br>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节，并破坏对象的封装性，一个对象不希望外界直接访问内部状态，通过中间对象可以间接访问其内部状态。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>Originator负责创建一个备忘录，可以记录，恢复自身内部状态，同时可以根据需要决定存储自身的哪些内部状态</p><p>Memoto 备忘录角色，用于存储Originator的内部状态，并且可以防止Originator以外的访问</p><p>Caretaker 负责存储备忘录,不能对备忘录的内容进行操作和访问，只能将备忘录传递给其他对象，如果里面加个index 和一个集合就能做到撤回和重做之类的操作了</p><p><img src="/images/meoto.png" alt="类图"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Memoto</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> mCheckpoint<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> mLifeValue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> mWeapon<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caretaker</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Memoto</span> memoto<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">archive</span><span class="token punctuation">(</span><span class="token class-name">Memoto</span> memoto<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>memoto <span class="token operator">=</span> memoto<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Memoto</span> <span class="token function">getMemoto</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> memoto<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>leak<span class="token punctuation">.</span>memoto</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallOfDuty</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mCheckPinot <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mLifeValue <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> mWeapon <span class="token operator">=</span> <span class="token string">"沙漠之鹰"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始玩游戏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mLifeValue <span class="token operator">-=</span> <span class="token number">10</span><span class="token punctuation">;</span>        mCheckPinot<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"退出游戏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Memoto</span> <span class="token function">createMemoto</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Memoto</span> memoto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Memoto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        memoto<span class="token punctuation">.</span>mCheckpoint <span class="token operator">=</span> mCheckPinot<span class="token punctuation">;</span>        memoto<span class="token punctuation">.</span>mLifeValue <span class="token operator">=</span> mLifeValue<span class="token punctuation">;</span>        memoto<span class="token punctuation">.</span>mWeapon <span class="token operator">=</span> mWeapon<span class="token punctuation">;</span>        <span class="token keyword">return</span> memoto<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">restore</span><span class="token punctuation">(</span><span class="token class-name">Memoto</span> memoto<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mCheckPinot <span class="token operator">=</span> memoto<span class="token punctuation">.</span>mCheckpoint<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mLifeValue <span class="token operator">=</span> memoto<span class="token punctuation">.</span>mLifeValue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mWeapon <span class="token operator">=</span> memoto<span class="token punctuation">.</span>mWeapon<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>leak<span class="token punctuation">.</span>memoto</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">CallOfDuty</span> game <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallOfDuty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        game<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Caretaker</span> caretaker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caretaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        caretaker<span class="token punctuation">.</span><span class="token function">archive</span><span class="token punctuation">(</span>game<span class="token punctuation">.</span><span class="token function">createMemoto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        game<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">CallOfDuty</span> newGame <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallOfDuty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        newGame<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span>caretaker<span class="token punctuation">.</span><span class="token function">getMemoto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CallOfDuty 这里就是Originator 他这里是具体也业务逻辑 Caretaker是对备忘录的对象进行存储，业务需要把对象存储到这个Caretaker备忘录之中</p><p>备忘录是在不破坏封装的条件下，通过备忘录对象储存另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来的状态的状态。<br>优点：<br>给用户提供了一种可以恢复状态的机制，可以使用户能比较方便地回到某个历史状态<br>实现信息的封装，使得用户不需要关心状态的保存细节。<br>缺点<br>消耗资源，如果类的成员变量过多，势必会占用较大的资源，而且每一次的保存都会消耗一定的内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后可以将对象恢复到原先保存的状态。&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式</title>
    <link href="http://example.com/2021/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-02-02T16:00:00.000Z</published>
    <updated>2021-10-31T05:32:58.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个操作中的算法框架，而将一些步骤延迟到子类中吗，让子类可以不改变算法的结构的既可以重定义该算法的特定步骤</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1.一个子类有共有的方法，并且逻辑基本相同<br>2.重要，复杂的算法可以把核心算法设计为一个模板方法，周边的相关细节功能由各个子类去实现<br>3.重构的时候，模板方法模式是一个经常使用的模式，吧相同的代码抽取到父类中，然后通过钩子函数约束行为</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p><img src="/images/template.png" alt="类图"></p><p>AbsTemplate定义了一个算法框架<br>ConcreteImplA 具体实现类A<br>ConcreteImplB 具体实现类B</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractComputer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">powerOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开启电源"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">checkHardware</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"硬件检查"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">loadOs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"载入操作系统"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小白的计算机，不需要密码直接进入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">startUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开机 start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">powerOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkHardware</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">loadOs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开机结束 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CoderComputer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractComputer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序员只需要进行用户和密码验证就可以了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MilitartyComputer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractComputer</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进行指纹识别等复杂的用户验证"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">checkHardware</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">checkHardware</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"检查硬件的防火墙"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模板方法模式用四个字概括就是：流程封装，也就是把某个固定的流程封装到一个final方法，并且让子类能定制这个流程中的某些方法或者步骤，这就要求提取公共的代码，提升代码的复用率，同事也带来更好的可扩展性。</p><p>优点<br>封装部分不变的，扩展可变的，提取公共的部分代码，便于维护</p><p>缺点<br>模板方法会带来代码的阅读性的难度，会让用户觉得难以理解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;定义一个操作中的算法框架，而将一些步骤延迟到子类中吗，让子类可以不改变算法的结构的既可以重定义该算法的特定步骤&lt;/p&gt;
&lt;h2 id=&quot;使用</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式模式</title>
    <link href="http://example.com/2021/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/02/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2021-10-30T09:48:06.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>为其他对象提供一种代理以控制对这个对象的访问。在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦,或者想在访问一个类时做一些控制，返回前后做一些事情都是可以，我们可以在访问此对象时加上一个对此对象的访问层,</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>有个人想打官司 ，他可以自己打官司也可以请律师帮忙打官司，律师就是他们的代理人<br>定义一个接口来定行为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ILawsuit</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//提交举证</span>    <span class="token keyword">boolean</span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//进行举证</span>    <span class="token keyword">boolean</span> <span class="token function">burden</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开始辩护</span>    <span class="token keyword">boolean</span> <span class="token function">defend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//诉讼完成</span>    <span class="token keyword">boolean</span> <span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小明去打官司</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> xiaoming <span class="token keyword">implements</span> <span class="token class-name">ILawsuit</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始提交"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">burden</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始举证"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">defend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始辩护"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代理律师 帮助小明打官司 ，只需要小明传入材料</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticProxy</span> <span class="token keyword">implements</span> <span class="token class-name">ILawsuit</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">ILawsuit</span> mILawsuit<span class="token punctuation">;</span>    <span class="token class-name">StaticProxy</span><span class="token punctuation">(</span><span class="token class-name">ILawsuit</span> iLawsuit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        mILawsuit <span class="token operator">=</span> iLawsuit<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mILawsuit<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">burden</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mILawsuit<span class="token punctuation">.</span><span class="token function">burden</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">defend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mILawsuit<span class="token punctuation">.</span><span class="token function">defend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mILawsuit<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代理关系建立</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">xiaoming xiaoming1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">xiaoming</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">StaticProxy</span> staticProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticProxy</span><span class="token punctuation">(</span>xiaoming1<span class="token punctuation">)</span><span class="token punctuation">;</span> staticProxy<span class="token punctuation">.</span><span class="token function">burden</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> staticProxy<span class="token punctuation">.</span><span class="token function">defend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> staticProxy<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> staticProxy<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面使用到的是静态代理</p><p>我更喜欢动态代理，因为动态代理可以动态帮所有人做任何事情，你也可以在invoke方法做事情的时候添加你想做的事情</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> obj<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        obj <span class="token operator">=</span> object<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行"</span><span class="token operator">+</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束执行"</span><span class="token operator">+</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过动态代理就可以拿到代理接口的代理类 做到一个动态代理的效果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DynamicProxy</span> dynamicProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span>xiaoming<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">ClassLoader</span> classLoader <span class="token operator">=</span> xiaoming<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">ILawsuit</span> lawsuit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ILawsuit</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token class-name">ILawsuit</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> dynamicProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>      lawsuit<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      lawsuit<span class="token punctuation">.</span><span class="token function">burden</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      lawsuit<span class="token punctuation">.</span><span class="token function">defend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      lawsuit<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优缺点<br>优点： 1、职责清晰。 2、高扩展性。 3、智能化。<br>缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
