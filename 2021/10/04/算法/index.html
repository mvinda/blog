<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="常用算法规整, Vinda">
    <meta name="description" content="慢就是快,快就是慢">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>常用算法规整 | Vinda</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Vinda" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Vinda</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Vinda</div>
        <div class="logo-desc">
            
            慢就是快,快就是慢
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/mvinda" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/mvinda" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">常用算法规整</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-category">
                                算法总结
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-04
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="常用的算法总结"><a href="#常用的算法总结" class="headerlink" title="常用的算法总结"></a>常用的算法总结</h1><h2 id="数组-模块"><a href="#数组-模块" class="headerlink" title="数组 模块"></a>数组 模块</h2><p>两数之和</p>
<p>1 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]</p>
<p>示例 2：</p>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p>
<p>示例 3：</p>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
            HashMap map&#x3D; new HashMap&lt;Integer,Integer&gt;();
            int[] arr&#x3D;new int[2];
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                map.put(nums[i],i);
            &#125;

            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                int targetNum&#x3D; target-nums[i];
                if(map.get(targetNum)!&#x3D;null&amp;&amp;(int)map.get(targetNum)!&#x3D;0)&#123;
                    if(i!&#x3D;(int)map.get(targetNum))&#123;
                    arr[0]&#x3D;i;
                    arr[1]&#x3D;(int)map.get(targetNum);
                    break;
                    &#125;
                &#125;]
            &#125;
        return arr;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>盛最多水的容器<br>2 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>示例 1</p>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例 2：</p>
<p>输入：height = [1,1]<br>输出：1</p>
<p>示例 3：</p>
<p>输入：height = [4,3,2,1,4]<br>输出：16</p>
<p>示例 4：<br>输入：height = [1,2,1]<br>输出：2</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int maxArea(int[] height) &#123;
        int start&#x3D;0;
        int end&#x3D;height.length-1;
        int maxArea&#x3D;0;
        while(start&lt;end)&#123;

            if(height[start]&lt;height[end])&#123;
              int max&#x3D;  (end-start)*height[start];
                if(maxArea&lt;max)&#123;
                    maxArea&#x3D;max;
                &#125;
                start++;
            &#125;else&#123;
                int max&#x3D;  (end-start)*height[end];
                if(maxArea&lt;max)&#123;
                    maxArea&#x3D;max;
                &#125; 
                end--;
            &#125;
        &#125;

        return maxArea;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>三数之和</p>
<p>3 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组</p>
<p>示例 1：</p>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p>
<p>示例 2：</p>
<p>输入：nums = []<br>输出：[]</p>
<p>示例 3：</p>
<p>输入：nums = [0]<br>输出：[]</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;
           ArrayList&lt;List&lt;Integer&gt;&gt; integers &#x3D; new ArrayList&lt;&gt;();
        if (nums &#x3D;&#x3D; null || nums.length &lt; 3) &#123;
            return integers;
        &#125;

        Arrays.sort(nums);

        for (int i &#x3D; 0; i &lt; nums.length - 2; i++) &#123;
            if (nums[i] &gt; 0) &#123;
                break;
            &#125;

            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue; &#x2F;&#x2F;去掉重复的情况 因为前面排序了 隔壁一样就是一样重复的

            int target &#x3D; -nums[i];
            int left &#x3D; i + 1, right &#x3D; nums.length - 1;

            while (left &lt; right) &#123;
                if (nums[left] + nums[right] &#x3D;&#x3D; target) &#123;
                    integers.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[left], nums[right])));
                    left++;
                    right--;
                    while (left&lt;right&amp;&amp;nums[left]&#x3D;&#x3D;nums[left-1])&#123;
                        left++;
                    &#125;
                    while (left&lt;right&amp;&amp;nums[right]&#x3D;&#x3D;nums[right+1])&#123;
                        right--;
                    &#125;

                &#125; else if (nums[left] + nums[right] &lt; target) &#123;
                    left++;
                &#125; else &#123;
                    right--;
                &#125;
            &#125;

        &#125;
        return integers;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p> 组合总和<br>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>示例 1：</p>
<p>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。</p>
<p>示例 2：</p>
<p>输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p>
<p>示例 3：</p>
<p>输入: candidates = [2], target = 1<br>输出: []</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
        List&lt;List&lt;Integer&gt;&gt; res;

    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;
         res&#x3D;new ArrayList&lt;&gt;();
         Arrays.sort(candidates);
       ArrayList&lt;Integer&gt; path &#x3D;new ArrayList();
        backTrace(candidates,target,path,0); &#x2F;&#x2F;采用回溯递归的方式
         return res;
    &#125;

    private void backTrace(int[] candidates,int target,ArrayList&lt;Integer&gt; path, int start )&#123;

            if(target&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果等于0 那么这个组合就是满足条件的 可以加入
                res.add(new ArrayList(path));
                return; 
            &#125;

            for(int i&#x3D;start;i&lt;candidates.length;i++)&#123;&#x2F;&#x2F;对根树来说的
                    if(candidates[i]&gt;target)&#123; &#x2F;&#x2F;如果当前都大于目标 那么就说明没有这个组合了因为 target会累加
                        return;
                    &#125;
                    path.add(candidates[i]);&#x2F;&#x2F;将这个路径放进去
                    backTrace(candidates,target-candidates[i],path,i);&#x2F;&#x2F;判断这个路径相减  然后要注意i是起始的意思  有这个start的话可以做到不考虑前面的数组,注意 因为是递归也就是从树的根部开始算起的，根节点触发的才不能用前面的树 也就是说第一轮for遍历是对根数组来说的，剩下的是底部数组
                
                    path.remove(path.size()-1);&#x2F;&#x2F;删除的是顶部的那个，这样才会回溯的效果 类似于最底部的删除重新尝试

            &#125;
    &#125;



&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>螺旋矩阵</p>
<p>4 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;
        int  left&#x3D;0;
        int  right&#x3D;matrix[0].length-1;
        int top&#x3D;0;
        int bottom&#x3D;matrix.length-1;
        List&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();


        while(right&gt;left&amp;&amp;bottom&gt;top)&#123;

         for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;
                list.add(matrix[top][i]);
        &#125;

          top++;  

        for(int i&#x3D;top;i&lt;&#x3D;bottom;i++)&#123;
            list.add(matrix[i][right]);
        &#125;
        right--;

        for(int i&#x3D;right;i&gt;&#x3D;left;i--)&#123;
            list.add(matrix[bottom][i]);
        &#125;    
        bottom--;

        for(int i&#x3D;bottom;i&gt;&#x3D;top;i--)&#123;
            list.add(matrix[i][left]);
        &#125;
        left++;

        &#125;
        if(left&lt;right&amp;&amp;top&#x3D;&#x3D;bottom)&#123;
            for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;
                list.add(matrix[top][i]);
            &#125;
        &#125;

        if(top&lt;bottom&amp;&amp;left&#x3D;&#x3D;right)&#123;
            for(int i&#x3D;top;i&lt;&#x3D;bottom;i++)&#123;
                list.add(matrix[i][left]);
            &#125;
        &#125;
        if(left&#x3D;&#x3D;right&amp;&amp;top&#x3D;&#x3D;bottom)&#123;
            list.add(matrix[top][left]);
        &#125;

        return list;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>合并区间</p>
<p>5 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>示例 1：</p>
<p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<p>示例 2：</p>
<p>输入：intervals = [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int[][] merge(int[][] intervals) &#123;
            Arrays.sort(intervals,new Comparator&lt;int[]&gt;()&#123;
                public int compare(int[] interval1,int[] interval2)&#123;
                    return interval1[0]-interval2[0];
                &#125;
            &#125;);

            ArrayList&lt;int[]&gt; list&#x3D;new ArrayList&lt;int[]&gt;();

            for(int i&#x3D;0;i&lt;intervals.length;i++)&#123;
                int L&#x3D;intervals[i][0];
                int R&#x3D;intervals[i][1];
                if(list.size()&#x3D;&#x3D;0||list.get(list.size()-1)[1]&lt;L)&#123;
                    list.add(new int[]&#123;L,R&#125;);
                &#125;else&#123;
                 
                    list.get(list.size()-1)[1]&#x3D;Math.max(list.get(list.size()-1)[1],R);   
                &#125;

            &#125;

            return list.toArray(new int[list.size()][]);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>最小路径和</p>
<p>6 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p>
<p>输入：grid = [[1,2,3],[4,5,6]]<br>输出：12</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int minPathSum(int[][] grid) &#123;
        int m&#x3D;grid.length;
        int n&#x3D;grid[0].length;


        int[][] arr&#x3D;new int[m][n];

        arr[0][0]&#x3D;grid[0][0];
        for(int i&#x3D;1;i&lt;n;i++)&#123;
            arr[0][i]&#x3D;arr[0][i-1]+grid[0][i];
        &#125;

        for(int i&#x3D;1;i&lt;m;i++)&#123;
            arr[i][0]&#x3D;arr[i-1][0]+grid[i][0];
        &#125;


        for(int i&#x3D;1;i&lt;m;i++)&#123;
            for(int j&#x3D;1;j&lt;n;j++)&#123;
                arr[i][j]&#x3D;Math.min(arr[i-1][j],arr[i][j-1])+grid[i][j];
            &#125;
        &#125;

        return arr[m-1][n-1];

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 子集</p>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
<p>示例 2：</p>
<p>输入：nums = [0]<br>输出：[[],[0]]</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;

       List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList&lt;&gt;();
        res.add(new ArrayList());
        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
            int all &#x3D;res.size();
             System.out.print(all);

            for(int j&#x3D;0;j&lt;all;j++)&#123;
                    List&lt;Integer&gt; tmp&#x3D;new ArrayList&lt;&gt;(res.get(j));
                        tmp.add(nums[i]);
                        res.add(tmp);
            &#125;
        &#125;
        return res;

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>合并两个有序数组</p>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</p>
<p>示例 2：<br>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。</p>
<p>示例 3：</p>
<p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;
            if(n&#x3D;&#x3D;0)&#123;
                return;
            &#125;

           if(m&#x3D;&#x3D;0)&#123;
                for(int i&#x3D;0;i&lt;n;i++)&#123;
                    nums1[i]&#x3D;nums2[i];
                &#125;
            &#125;

            for(int i&#x3D;m;i&lt;m+n;i++)&#123;
                nums1[i]&#x3D;nums2[i-m];
            &#125;
        
            
            Arrays.sort(nums1);
    

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将有序数组转换为二叉搜索树</p>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p>输入：nums = [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p>
<p>输入：nums = [1,3]<br>输出：[3,1]<br>解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树</p>
<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public TreeNode sortedArrayToBST(int[] nums) &#123;
            if(nums&#x3D;&#x3D;null)&#123;
                return null;
            &#125;

          return  getMidTree(nums,0,nums.length-1);

    &#125;

    public TreeNode getMidTree(int[] nums,int left,int right)&#123;
        if(left&gt;right)&#123;
            return null;
        &#125;
        int mid&#x3D;left+(right-left)&#x2F;2;
        System.out.print(&quot;mid:&quot;+nums[mid]);
       TreeNode tree&#x3D; new TreeNode(nums[mid]);

       tree.left&#x3D;getMidTree(nums,left,mid-1);
       tree.right&#x3D;getMidTree(nums,mid+1,right);

        return tree;
    &#125;

 
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>买卖股票的最佳时机</p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<p>示例 2：</p>
<p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int maxProfit(int[] prices) &#123;
            int maxValue&#x3D;0;
            int min&#x3D;Integer.MAX_VALUE;

            for(int i&#x3D;0;i&lt;prices.length;i++)&#123;
                min&#x3D;Math.min(min,prices[i]);
                int tempValue&#x3D; prices[i]-min;
                maxValue&#x3D;Math.max(maxValue,tempValue);                
            &#125;
            return maxValue;
            
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>买卖股票的最佳时机 II</p>
<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>
<p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。<br>返回 你能获得的 最大 利润 。</p>
<p>示例 1:</p>
<p>输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 </p>
<p>示例 2:</p>
<p>输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3:</p>
<p>输入: prices = [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int maxProfit(int[] prices) &#123;
        int maxValue&#x3D;0;
        for(int i&#x3D;prices.length-1;i&gt;0;i--)&#123;
            if(prices[i]&gt;prices[i-1])&#123;
                maxValue+&#x3D;prices[i]-prices[i-1];
            &#125;
        &#125;
        return maxValue;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最长连续序列</p>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p>示例 1：<br>输入：nums = [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
<p>示例 2：</p>
<p>输入：nums = [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p>
<pre class="line-numbers language-none"><code class="language-none">

class Solution &#123;
    public int longestConsecutive(int[] nums) &#123;
            if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;
                return 0;
            &#125;

            Arrays.sort(nums);

            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                System.out.print(nums[i]);
            &#125;
        
            int maxLength&#x3D;1;
            int finalMax&#x3D;1;

            for(int i&#x3D;0;i&lt;nums.length-1;i++)&#123;
                if(nums[i+1] - nums[i]&#x3D;&#x3D;1)&#123;
                    maxLength++;
                &#125;else if(nums[i+1]-nums[i]&#x3D;&#x3D;0)&#123;
                    continue;
                &#125;else&#123;
                    finalMax&#x3D; Math.max(maxLength,finalMax);
                    maxLength&#x3D;1;
                &#125;
            &#125;
            finalMax&#x3D; Math.max(maxLength,finalMax);

            return finalMax;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>只出现一次的数字</p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int singleNumber(int[] nums) &#123;
        HashMap map&#x3D;new HashMap&lt;Integer,Integer&gt;();

        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                if(map.get(nums[i])!&#x3D;null)&#123;
                    map.put(nums[i],(int)map.get(nums[i])+1);
                &#125;else&#123;
                    map.put(nums[i],1);
                &#125;
        &#125;
       Set&lt;Integer&gt; sets&#x3D; map.keySet();
        for(Integer key: sets)&#123;
            if((int)map.get(key)&#x3D;&#x3D;1)&#123;
                return key;
            &#125;
        &#125;

            return -1;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>只出现一次的数字 II</p>
<p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [2,2,3,2]<br>输出：3<br>示例 2：</p>
<p>输入：nums = [0,1,0,1,0,1,99]<br>输出：99
 </p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 3 * 104<br>-231 &lt;= nums[i] &lt;= 231 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int singleNumber(int[] nums) &#123;
        &#x2F;&#x2F;搞一个集合来存储
        HashMap map&#x3D;new HashMap&lt;Integer,Integer&gt;();


        &#x2F;&#x2F;遍历将数据存进去 map
        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
            if(map.get(nums[i])&#x3D;&#x3D;null)&#123;
                map.put(nums[i],1);
            &#125;else&#123;
                map.put(nums[i],(int)map.get(nums[i])+1);
            &#125;
        &#125;
&#x2F;&#x2F;      遍历map 如果存在一个值为1的话 那么就返回
        Set&lt;Integer&gt; sets&#x3D;map.keySet();
        for(Integer key:sets)&#123;
            if((int)map.get(key)&#x3D;&#x3D;1)&#123;
                return key;
            &#125;
        &#125;


        return 0;

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>乘积最大子数组</p>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int maxProduct(int[] nums) &#123;
        if(nums&#x3D;&#x3D;null)&#123;
            return 0;
        &#125;
        if(nums.length&#x3D;&#x3D;0)&#123;
            return nums[0];
        &#125;

        int max&#x3D;Integer.MIN_VALUE;
        int  imax&#x3D;1;
        int  imin&#x3D;1;
    


        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
            if(nums[i]&lt;0)&#123;
                int tmp&#x3D;imax;
                imax&#x3D;imin;
                imin&#x3D;tmp;
            &#125;

            imax&#x3D;Math.max(imax*nums[i],nums[i]);
            imin&#x3D;Math.min(imin*nums[i],nums[i]);
            max&#x3D;Math.max(max,imax);
        &#125;
        return max;

    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br>示例 2：</p>
<p>输入：nums = [1,2,1,3,5,6,4]<br>输出：1 或 5<br>解释：你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int findPeakElement(int[] nums) &#123;
        if(nums.length&#x3D;&#x3D;1||nums.length&#x3D;&#x3D;0)&#123;
            return 0;
        &#125;

        if(nums.length&#x3D;&#x3D;2)&#123;
            if(nums[0]&gt;nums[1])&#123;
                return 0;
            &#125;else&#123;
                return  1;
            &#125;
        &#125;


            

            for(int i&#x3D;1;i&lt;nums.length-1;i++)&#123;
                if(nums[i]&gt;nums[i-1]&amp;&amp;nums[i]&gt;nums[i+1])&#123;
                    return i;
                &#125;
            &#125;

             if(nums[nums.length-1]&gt;nums[nums.length-2])&#123;
                    return nums.length-1;
                &#125;




        return 0;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>轮转数组</p>
<p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入：nums = [-1,-100,3,99], k = 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public void rotate(int[] nums, int k) &#123;
        
            &#x2F;&#x2F;求余数为了避免k大于nums
            k&#x3D;k%nums.length;


            &#x2F;&#x2F;这个是为了放在前面
           ArrayList&lt;Integer&gt; firstList&#x3D; new ArrayList&lt;Integer&gt;();    
           &#x2F;&#x2F;这个是为了放在后面
           ArrayList&lt;Integer&gt; secondList&#x3D; new ArrayList&lt;Integer&gt;();    

            &#x2F;&#x2F;这个把后面的切割下来
            for(int i&#x3D;nums.length-1;i&gt;&#x3D;nums.length-k;i--)&#123;
                firstList.add(nums[i]);
            &#125;


            &#x2F;&#x2F; 这个添加到后面
            for(int i&#x3D;0;i&lt;nums.length-k;i++)&#123;
                secondList.add(nums[i]);
            &#125;
            
            for(int i&#x3D;0;i&lt;firstList.size();i++)&#123;
                nums[i]&#x3D;firstList.get(firstList.size()-i-1);
            &#125;

            for(int i&#x3D;0;i&lt;secondList.size();i++)&#123;
                nums[i+firstList.size()]&#x3D;secondList.get(i);
            &#125;

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>岛屿数量</p>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p>
<p>输入：grid = [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3
 </p>
<p>提示：</p>
<p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m, n &lt;= 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    int  count&#x3D;0;
    public int numIslands(char[][] grid) &#123;
        &#x2F;&#x2F;判空
        if(grid[0].length&#x3D;&#x3D;0||grid.length&#x3D;&#x3D;0)&#123;
            return 0;
        &#125;
        &#x2F;&#x2F;拿出这个矩阵的横和列
        int right&#x3D;grid[0].length;
        int bottom&#x3D;grid.length;
        &#x2F;&#x2F;
        for(int i&#x3D;0;i&lt;bottom;i++)&#123;
            for(int j&#x3D;0;j&lt;right;j++)&#123;
                &#x2F;&#x2F;遍历整个矩阵 如果发现有一个是1的开启深度搜索 找到后给这个计数器加一
                if(grid[i][j]&#x3D;&#x3D;&#39;1&#39;)&#123;
                    dfs(grid,i,j);
                    count++;
                &#125;
            &#125;
        &#125;
        return count;
    &#125;
    &#x2F;&#x2F;深度邮箱搜索
    public void dfs(char[][] grid,int i,int j)&#123;
        &#x2F;&#x2F;关键就是这个判断标准，超出不可以 为0不可以
        if(i&lt;0||i&gt;grid.length-1||j&lt;0||j&gt;grid[0].length-1||grid[i][j]&#x3D;&#x3D;&#39;0&#39;)&#123;
            return;
        &#125;
        &#x2F;&#x2F;递归调用了上下左右，这个方法结束的时候就一个岛屿
        grid[i][j]&#x3D;&#39;0&#39;;
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>最大正方形</p>
<p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<p> </p>
<p>示例 1：<br>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],[“1”,”0”,”1”,”1”,”1”],[“1”,”1”,”1”,”1”,”1”],[“1”,”0”,”0”,”1”,”0”]]<br>输出：4</p>
<p>示例 2：</p>
<p>输入：matrix = [[“0”,”1”],[“1”,”0”]]<br>输出：1</p>
<p>示例 3：<br>输入：matrix = [[“0”]]<br>输出：0</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int maximalSquare(char[][] matrix) &#123;
        int maxSide &#x3D; 0;
        if (matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0) &#123;
            return maxSide;
        &#125;
        int rows &#x3D; matrix.length, columns &#x3D; matrix[0].length;
        for (int i &#x3D; 0; i &lt; rows; i++) &#123;
            for (int j &#x3D; 0; j &lt; columns; j++) &#123;
                if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;
                    &#x2F;&#x2F; 遇到一个 1 作为正方形的左上角
                    maxSide &#x3D; Math.max(maxSide, 1);
                    &#x2F;&#x2F; 计算可能的最大正方形边长
                    int currentMaxSide &#x3D; Math.min(rows - i, columns - j);
                    for (int k &#x3D; 1; k &lt; currentMaxSide; k++) &#123;
                        &#x2F;&#x2F; 判断新增的一行一列是否均为 1
                        boolean flag &#x3D; true;
                        if (matrix[i + k][j + k] &#x3D;&#x3D; &#39;0&#39;) &#123;
                            break;
                        &#125;
                        for (int m &#x3D; 0; m &lt; k; m++) &#123;
                            if (matrix[i + k][j + m] &#x3D;&#x3D; &#39;0&#39; || matrix[i + m][j + k] &#x3D;&#x3D; &#39;0&#39;) &#123;
                                flag &#x3D; false;
                                break;
                            &#125;
                        &#125;
                        if (flag) &#123;
                            maxSide &#x3D; Math.max(maxSide, k + 1);
                        &#125; else &#123;
                            break;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        int maxSquare &#x3D; maxSide * maxSide;
        return maxSquare;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>最长递增子序列</p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p> <br>示例 1：</p>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums = [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 2500<br>-104 &lt;= nums[i] &lt;= 104</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int lengthOfLIS(int[] nums) &#123;
           if(nums.length&lt;&#x3D;1)&#123;
               return nums.length;
           &#125;
           int n&#x3D;nums.length;
            int arr[]&#x3D;new int[n];
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                arr[i]&#x3D;1;
            &#125;

            int result&#x3D;1;
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                    for(int j&#x3D;0;j&lt;i;j++)&#123;
                        if(nums[i]&gt;nums[j])&#123;
                        arr[i]&#x3D;Math.max(arr[i],arr[j]+1);
                        &#125;
                    &#125;
                   result&#x3D;Math.max(arr[i],result); 
            &#125;

            return result;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>零钱兑换</p>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</p>
<p>示例 2：</p>
<p>输入：coins = [2], amount = 3<br>输出：-1</p>
<p>示例 3：</p>
<p>输入：coins = [1], amount = 0<br>输出：0</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int coinChange(int[] coins, int amount) &#123;
        int max &#x3D; Integer.MAX_VALUE;
        int[] dp &#x3D; new int[amount + 1];
        &#x2F;&#x2F;初始化dp数组为最大值
        for (int j &#x3D; 0; j &lt; dp.length; j++) &#123;
            dp[j] &#x3D; max;
        &#125;
        &#x2F;&#x2F;当金额为0时需要的硬币数目为0
        dp[0] &#x3D; 0;
        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;
            &#x2F;&#x2F;正序遍历：完全背包每个硬币可以选择多次
            for (int j &#x3D; coins[i]; j &lt;&#x3D; amount; j++) &#123;
                &#x2F;&#x2F;只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要
                if (dp[j - coins[i]] !&#x3D; max) &#123;
                    &#x2F;&#x2F;选择硬币数目最小的情况
                    dp[j] &#x3D; Math.min(dp[j], dp[j - coins[i]] + 1);
                &#125;
            &#125;
        &#125;
        return dp[amount] &#x3D;&#x3D; max ? -1 : dp[amount];
        &#x2F;&#x2F;这道题还不是很懂
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
 </p>
<p>前 K 个高频元素</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]
 </p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int[] topKFrequent(int[] nums, int k) &#123;
        HashMap&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;Integer,Integer&gt;();
        &#x2F;&#x2F;遍历将出现的次数和值放到一个map中
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                if(map.get(nums[i])&#x3D;&#x3D;null)&#123;
                    map.put(nums[i],1);
                &#125;else&#123;
                    map.put(nums[i],(int)map.get(nums[i])+1);
                &#125;
            &#125;

         
            &#x2F;&#x2F;这个是一个关键 对一个包着map的list进行排序
              List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; list&#x3D;new ArrayList&lt;&gt;(map.entrySet());
            &#x2F;&#x2F; 如果b值大于a值那么就排前面
                Collections.sort(list,(a,b)-&gt;&#123;
                    return b.getValue()-a.getValue();
                &#125;);

            &#x2F;&#x2F;最后遍历 就拿前面k个值
                int[] arr&#x3D;new int[k];
                for(int i&#x3D;0;i&lt;k;i++)&#123;
                    arr[i]&#x3D;(int)list.get(i).getKey();
                &#125;
        return arr;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>三个数的最大乘积</p>
<p>给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]<br>输出：6<br>示例 2：</p>
<p>输入：nums = [1,2,3,4]<br>输出：24<br>示例 3：</p>
<p>输入：nums = [-1,-2,-3]<br>输出：-6</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int maximumProduct(int[] nums) &#123;
            int max&#x3D;Integer.MIN_VALUE;
            if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;
                return 0;
            &#125;
            if(nums.length&#x3D;&#x3D;1)&#123;
                return nums[0];
            &#125;
            if(nums.length&#x3D;&#x3D;2)&#123;
                return nums[1]*nums[0];
            &#125;

            Arrays.sort(nums);

            for(int i&#x3D;0;i&lt;nums.length-2;i++)&#123;
                int tempMax&#x3D;nums[i]*nums[i+1]*nums[i+2];
                max&#x3D;Math.max(max,tempMax);
            &#125;
            int n&#x3D;nums.length;
            int  sum&#x3D;  Math.max(nums[0]*nums[1]*nums[n-1],nums[n-1]*nums[n-2]*nums[n-3]);
            max&#x3D;Math.max(max,sum);

            return max;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>二分查找</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p>
<p>示例 2:<br>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int search(int[] nums, int target) &#123;
            int left&#x3D;0;
            int right&#x3D;nums.length-1;
            int mid&#x3D;0;
            while(left&lt;&#x3D;right)&#123;
                mid&#x3D;left+(right-left)&#x2F;2;
                if(nums[mid]&#x3D;&#x3D;target)&#123;
                    return mid;
                &#125;else if(nums[mid]&gt;target)&#123;
                        right&#x3D;mid-1;    
                &#125;else &#123;
                    left&#x3D;mid+1;
                &#125;
            &#125;
            return -1;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二维数组中的查找</p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;
        &#x2F;&#x2F;判空操作
            if(matrix&#x3D;&#x3D;null)&#123;
                return false;
            &#125;
            if(matrix.length&#x3D;&#x3D;0)&#123;
                return false;
            &#125;
            &#x2F;&#x2F;right top 是右上角 为什么选右上角 因为右上角 往左边永远是减往下面永远是加
                int right&#x3D;matrix[0].length-1;
                int top&#x3D;0;
                &#x2F;&#x2F;当top不大于最低 right 不小于0 那么找到就是true 找不到判断大小继续找大了就往左边挪  小了往下边加
                while(right&gt;&#x3D;0&amp;&amp;top&lt;matrix.length)&#123;
                    if(matrix[top][right]&#x3D;&#x3D;target)&#123;
                        return true;
                    &#125;else if(matrix[top][right]&gt;target)&#123;
                        right--;
                    &#125;else if(matrix[top][right]&lt;target)&#123;
                        top++;
                    &#125;
                &#125;

                return false;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>剑指 Offer 07. 重建二叉树</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p> </p>
<p>示例 1:</p>
<p>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>Input: preorder = [-1], inorder = [-1]<br>Output: [-1]</p>
<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;
        int n&#x3D;preorder.length;
        &#x2F;&#x2F;判空
        if(n&#x3D;&#x3D;0)&#123;
            return null;
        &#125;
        &#x2F;&#x2F;先找出 这个前序根在中序的那个位置
        int rootValue&#x3D;preorder[0];
        int rootIndex&#x3D;0;
        TreeNode rootTree &#x3D; new TreeNode(rootValue);
        for(int i&#x3D;0;i&lt;n;i++)&#123;
            if(inorder[i]&#x3D;&#x3D;rootValue)&#123;
                rootIndex&#x3D;i;
            &#125;
        &#125; 
        &#x2F;&#x2F;左子树就是前序
        rootTree.left&#x3D;buildTree(Arrays.copyOfRange(preorder,1,1+rootIndex),Arrays.copyOfRange(inorder,0,0+rootIndex));
        rootTree.right&#x3D;buildTree(Arrays.copyOfRange(preorder,1+rootIndex,n)
        ,Arrays.copyOfRange(inorder,rootIndex+1,n));


        return rootTree;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>旋转数组的最小数字</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int minArray(int[] numbers) &#123;
        Arrays.sort(numbers);

        return numbers[0];

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>调整数组顺序使奇数位于偶数前面</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p> </p>
<p>示例：</p>
<p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int[] exchange(int[] nums) &#123;
        ArrayList firstList&#x3D;new ArrayList&lt;Integer&gt;();
        ArrayList secondList&#x3D;new ArrayList&lt;Integer&gt;();

        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
            if(nums[i]%2&#x3D;&#x3D;0)&#123;
                secondList.add(nums[i]);
            &#125;else&#123;
                firstList.add(nums[i]);
            &#125;
        &#125;

        for(int i&#x3D;0;i&lt;firstList.size();i++)&#123;
            System.out.print(firstList.get(i));
            nums[i]&#x3D;(int)firstList.get(i);
        &#125;

        for(int i&#x3D;0;i&lt;secondList.size();i++)&#123;
                System.out.print(secondList.get(i));
               nums[firstList.size()+i]&#x3D;(int)secondList.get(i); 
        &#125;
        return nums;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>顺时针打印矩阵</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 </p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int[] spiralOrder(int[][] matrix) &#123;
            &#x2F;&#x2F;如果为空或者集合就一个 那么返回一个
            if(matrix&#x3D;&#x3D;null||matrix.length&#x3D;&#x3D;0||matrix[0].length&#x3D;&#x3D;0)&#123;
                int [] arr&#x3D;new int[0];
                return  arr;
            &#125;

            &#x2F;&#x2F;左边
            int left&#x3D;0;
            &#x2F;&#x2F;右边
            int right&#x3D;matrix[0].length-1;
            &#x2F;&#x2F;上边
            int top&#x3D;0;
            &#x2F;&#x2F;下边
            int botton&#x3D;matrix.length-1;
            &#x2F;&#x2F;存储集合的边界
            ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();
        &#x2F;&#x2F;如果左边小于右边 或者下边大于上边
           while(left&lt;&#x3D;right&amp;&amp;botton&gt;&#x3D;top)&#123;
            &#x2F;&#x2F;先从左到右加入
            for(int i&#x3D;left;i&lt;&#x3D;right;i++)&#123;
                list.add(matrix[top][i]);
            &#125;
            &#x2F;&#x2F;从上到下加入
            for(int i&#x3D;top+1;i&lt;&#x3D;botton;i++)&#123;
                list.add(matrix[i][right]);
            &#125;
            &#x2F;&#x2F;从右到左加入  但是要求上下不能相等 不然会给上面重复计算
            for(int i&#x3D;right-1;i&gt;&#x3D;left&amp;&amp;botton!&#x3D;top;i--)&#123;
                list.add(matrix[botton][i]);
            &#125;
            &#x2F;&#x2F;从下到上，但是要求左和右不能相等
            for(int i&#x3D;botton-1;i&gt;&#x3D;top+1&amp;&amp;left!&#x3D;right;i--)&#123;
                list.add(matrix[i][left]);
            &#125;
            top++;
            right--;
            botton--;
            left++;
            &#125;
            int [] arr&#x3D;new int[list.size()];

            for(int i&#x3D;0;i&lt;list.size();i++)&#123;
                arr[i]&#x3D;list.get(i);
            &#125;
            return arr;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>数组中出现次数超过一半的数字</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p> </p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2
 </p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int majorityElement(int[] nums) &#123;
            HashMap map&#x3D;new HashMap&lt;Integer,Integer&gt;();
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                    if(map.get(nums[i])!&#x3D;null)&#123;
                         map.put(nums[i],(int)map.get(nums[i])+1);   
                    &#125;else&#123;
                        map.put(nums[i],1);
                    &#125;
            &#125;
            Set&lt;Integer&gt; sets &#x3D;map.keySet();
            for(Integer value : sets )&#123;
                System.out.println(&quot;key&quot;+value);
                System.out.println(&quot;value&quot;+map.get(value));

                if((int)map.get(value)&gt;nums.length&#x2F;2)&#123;
                    return value;
                &#125;

            &#125;

            return -1;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>最小的k个数</p>
<p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]<br>示例 2：</p>
<p>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int[] getLeastNumbers(int[] arr, int k) &#123;

        Arrays.sort(arr);
        int[] result&#x3D;new int[k];
        for(int i&#x3D;0;i&lt;k;i++)&#123;
            result[i]&#x3D;arr[i];
        &#125;
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>连续子数组的最大和</p>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p> </p>
<p>示例1:</p>
<p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int maxSubArray(int[] nums) &#123;
            if(nums.length&#x3D;&#x3D;1)&#123;
                return nums[0];
            &#125;

        &#x2F;&#x2F;这个是最后的值大小
        int max&#x3D;nums[0];
        &#x2F;&#x2F;这个是临时的一个最大值 因为是连续的一个最大值 所以需要这个临时的，
        int tempMax&#x3D;nums[0];

        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;
            &#x2F;&#x2F;这个最大值就是之前积累的加上这个值大 还是单个这个大
            tempMax&#x3D;Math.max(nums[i],tempMax+nums[i]);
            &#x2F;&#x2F;把连续加上的判断的值和之前积累的最大值做 最大留存就得出了
            max&#x3D;Math.max(max,tempMax); 
        &#125;


        return max;

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>在排序数组中查找数字 I</p>
<p>统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2<br>示例 2:</p>
<p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int search(int[] nums, int target) &#123;
           HashMap map&#x3D; new HashMap&lt;Integer,Integer&gt;();

        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
            if(map.get(nums[i])&#x3D;&#x3D;null)&#123;
                 map.put(nums[i],1);
            &#125;else&#123;
                int temp&#x3D;(int)map.get(nums[i]);
                map.put(nums[i],temp+1);
            &#125;
      &#125;

         if(map.get(target)&#x3D;&#x3D;null)&#123;
             return 0;
         &#125;else&#123;
            return (int)map.get(target);
         &#125;


    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p> 0～n-1中缺失的数字</p>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int missingNumber(int[] nums) &#123;

       
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                if(nums[i]!&#x3D;i)&#123;
                    return i;
                &#125;
            &#125;

            return nums[nums.length-1]+1;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>扑克牌中的顺子</p>
<p>从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5]<br>输出: True
 </p>
<p>示例 2:</p>
<p>输入: [0,0,1,2,5]<br>输出: True</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public boolean isStraight(int[] nums) &#123;
            &#x2F;&#x2F;先排序一下
            Arrays.sort(nums);
            &#x2F;&#x2F;搞
            int zoreNumber&#x3D;0;

            for(int i&#x3D;0;i&lt;nums.length-1;i++)&#123;
                if(nums[i]&#x3D;&#x3D;0)&#123;
                    zoreNumber++;
                    continue;
                &#125;

                if(nums[i+1]&#x3D;&#x3D;nums[i])&#123;
                    return false;
                &#125;

                zoreNumber&#x3D;zoreNumber-(nums[i+1]-nums[i]-1);
            &#125;
            System.out.print(&quot;zoreNumber&quot;+zoreNumber);
            if(zoreNumber&gt;&#x3D;0)&#123;
                return true;
            &#125;else&#123;
                return false;
            &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>股票的最大利润</p>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br>示例 2:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int maxProfit(int[] prices) &#123;

        int minValue&#x3D;Integer.MAX_VALUE;
        int maxResult&#x3D;0;
        for(int i&#x3D;0;i&lt;prices.length;i++)&#123;
            minValue &#x3D;Math.min(minValue,prices[i]);
            int tempResult &#x3D;prices[i]-minValue;

            maxResult&#x3D;Math.max(maxResult,tempResult);
        &#125;
        return maxResult;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p> 数组中和为 0 的三个数</p>
<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>示例 2：</p>
<p>输入：nums = []<br>输出：[]<br>示例 3：</p>
<p>输入：nums = [0]<br>输出：[]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;
            Arrays.sort(nums);
          ArrayList&lt;List&lt;Integer&gt;&gt; result&#x3D;  new ArrayList&lt;List&lt;Integer&gt;&gt;();
          ArrayList&lt;Integer&gt; arrList&#x3D; new ArrayList&lt;Integer&gt;();
         
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                int target&#x3D;-nums[i];
                int start&#x3D;i+1;
                int end&#x3D;nums.length-1;

                while(start&lt;end&amp;&amp;start&lt;&#x3D;nums.length-1&amp;&amp;end&lt;&#x3D;nums.length-1)&#123;
                    if(nums[start]+nums[end]&#x3D;&#x3D;target)&#123;
                        ArrayList&lt;Integer&gt; list&#x3D;new ArrayList();
                        list.add(nums[start]);
                        list.add(nums[end]);
                        list.add(nums[i]);
                        if(!result.contains(list))&#123;
                            result.add(list);
                        &#125;
                        start++;
                        end--;
                    &#125;else if(nums[start]+nums[end]&lt;target)&#123;
                        start++;
                    &#125;else&#123;
                        end--;
                    &#125;
                &#125;
            &#125;
        return result;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>合并排序的数组</p>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<p>示例:</p>
<p>输入:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public void merge(int[] A, int m, int[] B, int n) &#123;

       

        for(int i&#x3D;m;i&lt;m+n;i++)&#123;
            A[i]&#x3D;B[i-m];
        &#125;

        Arrays.sort(A);

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>搜索旋转数组</p>
<p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>
<p>示例1:</p>
<p> 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5<br> 输出: 8（元素5在该数组中的索引）<br>示例2:</p>
<p> 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11<br> 输出：-1 （没有找到）</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int search(int[] arr, int target) &#123;

        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;
                if(arr[i]&#x3D;&#x3D;target)&#123;
                    return i;
                &#125;
        &#125; 
        return -1;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>排序矩阵查找</p>
<p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        if(matrix&#x3D;&#x3D;null||matrix.length&#x3D;&#x3D;0)&#123;
            return false;
        &#125;

        &#x2F;&#x2F;  遍历的做法
        &#x2F;&#x2F;   int colume&#x3D;-1;
        &#x2F;&#x2F;   int m&#x3D;matrix.length;
        &#x2F;&#x2F;   int n&#x3D;matrix[0].length;
        &#x2F;&#x2F;  for(int i&#x3D;0;i&lt;m;i++)&#123;
        &#x2F;&#x2F;      for(int j&#x3D;0;j&lt;n;j++)&#123;
        &#x2F;&#x2F;          if(matrix[i][j]&#x3D;&#x3D;target)&#123;
        &#x2F;&#x2F;              return true;
        &#x2F;&#x2F;          &#125;
                 
        &#x2F;&#x2F;      &#125;
        &#x2F;&#x2F;  &#125;

            int m&#x3D;0;
            int n&#x3D;matrix[0].length-1;
            while(m&lt;matrix.length&amp;&amp;n&gt;&#x3D;0)&#123;
                if(matrix[m][n]&#x3D;&#x3D;target)&#123;
                    return true;
                &#125;else if(matrix[m][n]&gt;target)&#123;
                    n--;
                &#125;else&#123;
                    m++;
                &#125;
            &#125;
         return false;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>连续数列</p>
<p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p>
<p>示例：</p>
<p>输入： [-2,1,-3,4,-1,2,1,-5,4]<br>输出： 6<br>解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶：</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int maxSubArray(int[] nums) &#123;
        if(nums&#x3D;&#x3D;null||nums.length&#x3D;&#x3D;0)&#123;

            return -1;
        &#125;

        int max&#x3D;nums[0];
        int current&#x3D;nums[0];
        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;

            if(current+nums[i]&gt;nums[i])&#123;
                current&#x3D;current+nums[i];
            &#125;else&#123;
                current&#x3D;nums[i];
            &#125;
            max&#x3D;Math.max(current,max);
        &#125;
            return max;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>无重复字符的最长子串</p>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>示例 4:</p>
<p>输入: s = “”<br>输出: 0</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
            char chars[]&#x3D; s.toCharArray();
            int max&#x3D;0;
            ArrayList&lt;Character&gt; list&#x3D; new  ArrayList();

            if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0)&#123;
                return 0;
            &#125;

            for(int i&#x3D;0;i&lt;chars.length;i++)&#123;
                  Character character&#x3D;  new Character(chars[i]);
                    if(list.contains(character))&#123;
                        int index&#x3D;list.indexOf(character);

                        for(int j&#x3D;index;j&gt;&#x3D;0;j--)&#123;
                            list.remove(j);
                        &#125;
                        if(!list.contains(character))&#123;
                            list.add(character);
                        &#125;
                    &#125;else&#123;
                        list.add(character);
                        max&#x3D;Math.max(max,list.size());
                    &#125;
            &#125;
            return max;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>最长回文子串</p>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p>
<p>输入：s = “cbbd”<br>输出：”bb”<br>示例 3：</p>
<p>输入：s = “a”<br>输出：”a”<br>示例 4：</p>
<p>输入：s = “ac”<br>输出：”a”</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public String longestPalindrome(String s) &#123;

        char chars[]&#x3D;s.toCharArray();
        int length&#x3D;s.length();
        if(length&lt;2)&#123;
            return s;
        &#125;
        Boolean arr[][]&#x3D;new Boolean[length][length];

        for(int i&#x3D;0;i&lt;length;i++)&#123;
            arr[i][i]&#x3D;true;
        &#125;

        int maxhublength&#x3D;1;
        int start&#x3D;0;


        for(int j&#x3D;1;j&lt;length;j++)&#123;
            for(int i&#x3D;0;i&lt;j;i++)&#123;
                if(chars[j]!&#x3D;chars[i])&#123;
                        arr[i][j]&#x3D;false;
                &#125;else&#123;
                    if(j-i&lt;3)&#123;
                        arr[i][j]&#x3D;true;
                    &#125;else&#123;
                         arr[i][j]&#x3D;arr[i+1][j-1];
                    &#125;
                &#125;
                if(((j-i+1)&gt;maxhublength)&amp;&amp;arr[i][j])&#123;
                    maxhublength&#x3D;j-i+1;
                    start&#x3D;i;
                &#125;
            &#125;
        &#125;

      &#x2F;&#x2F;不会

        String result&#x3D;s.substring(start,start+maxhublength);        

        return  result;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>最长公共前缀</p>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：</p>
<p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public String longestCommonPrefix(String[] strs) &#123;
        &#x2F;&#x2F;先判空一下
        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0)&#123;
            return &quot;&quot;;
        &#125;
        &#x2F;&#x2F; 拿第一个为基准
        String firstString&#x3D;strs[0];
        &#x2F;&#x2F;这个是一个字符串的建造器
        StringBuilder build&#x3D; new StringBuilder();
        &#x2F;&#x2F;遍历第一个字符串的字符
        for(int i&#x3D;0;i&lt;firstString.length();i++)&#123;
            char c&#x3D;firstString.charAt(i);
            &#x2F;&#x2F;如果某一个字符串的字符没有对应字符就会被return  因为是要连续一样的字符串
            for(int j&#x3D;1;j&lt;strs.length;j++)&#123;
                if(strs[j].length()&lt;&#x3D;i||c!&#x3D;strs[j].charAt(i))&#123;
                   return build.toString();
                &#125;
            &#125;
            build.append(c);
        &#125;
        return build.toString();
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p> 有效的括号</p>
<p> 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。
 </p>
<p>示例 1：</p>
<p>输入：s = “()”<br>输出：true<br>示例 2：</p>
<p>输入：s = “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s = “(]”<br>输出：false<br>示例 4：</p>
<p>输入：s = “([)]”<br>输出：false<br>示例 5：</p>
<p>输入：s = “{[]}”<br>输出：true</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public boolean isValid(String s) &#123;
    &#x2F;&#x2F;搞一个栈
      Stack&lt;Character&gt; stack&#x3D;  new Stack&lt;&gt;();
    &#x2F;&#x2F;遍历这个字符串
      for(int i&#x3D;0;i&lt;s.length();i++)&#123;
          &#x2F;&#x2F;因为只有三种类型，看到某一个就放入相反的即可
          char c&#x3D;s.charAt(i);
          if(c&#x3D;&#x3D;&#39;(&#39;)&#123;
              stack.push(&#39;)&#39;);
          &#125;else if(c&#x3D;&#x3D;&#39;&#123;&#39;)&#123;
              stack.push(&#39;&#125;&#39;);
          &#125;else if(c&#x3D;&#x3D;&#39;[&#39;)&#123;
              stack.push(&#39;]&#39;);
              &#x2F;&#x2F;如果遍历还没有为空  或者弹出来的字符跟放进去的不一样 那么就返回false
          &#125;else if (stack.isEmpty()||c!&#x3D;stack.pop())&#123;
              return false;
          &#125;
      &#125;
      return stack.isEmpty();
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> </p>
<p>括号生成</p>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 </p>
<p>示例 1：</p>
<p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p>
<p>输入：n = 1<br>输出：[“()”]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public List&lt;String&gt; generateParenthesis(int n) &#123;
     List&lt;String&gt; res&#x3D;new ArrayList&lt;String&gt;();
        generate(res,&quot;&quot;,0,0,n);
        return res;
    &#125;

    public void generate(List&lt;String&gt; res,String ans,int count1,int count2,int n)&#123;
             if(count1&gt;n||count2&gt;n)&#123;
                return;
            &#125;

            if(count2&#x3D;&#x3D;n&amp;&amp;count1&#x3D;&#x3D;n)&#123;
                res.add(ans);
            &#125;

             if(count1&gt;&#x3D;count2)&#123;
               String ans1 &#x3D; new String(ans);
             generate(res, ans+&quot;(&quot;, count1+1, count2, n);
                 generate(res, ans1+&quot;)&quot;, count1, count2+1, n);
            &#125;
        &#x2F;&#x2F;不是很懂

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>字符串相乘</p>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: num1 = “2”, num2 = “3”<br>输出: “6”<br>示例 2:</p>
<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”
 </p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public String multiply(String num1, String num2) &#123;
        if (num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)) &#123;
            return &quot;0&quot;;
        &#125;
        String ans &#x3D; &quot;0&quot;;
        int m &#x3D; num1.length(), n &#x3D; num2.length();
        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;
            StringBuffer curr &#x3D; new StringBuffer();
            int add &#x3D; 0;
            for (int j &#x3D; n - 1; j &gt; i; j--) &#123;
                curr.append(0);
            &#125;
            int y &#x3D; num2.charAt(i) - &#39;0&#39;;
            for (int j &#x3D; m - 1; j &gt;&#x3D; 0; j--) &#123;
                int x &#x3D; num1.charAt(j) - &#39;0&#39;;
                int product &#x3D; x * y + add;
                curr.append(product % 10);
                add &#x3D; product &#x2F; 10;
            &#125;
            if (add !&#x3D; 0) &#123;
                curr.append(add % 10);
            &#125;
            ans &#x3D; addStrings(ans, curr.reverse().toString());
        &#125;
        return ans;
    &#125;

    public String addStrings(String num1, String num2) &#123;
        int i &#x3D; num1.length() - 1, j &#x3D; num2.length() - 1, add &#x3D; 0;
        StringBuffer ans &#x3D; new StringBuffer();
        while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0 || add !&#x3D; 0) &#123;
            int x &#x3D; i &gt;&#x3D; 0 ? num1.charAt(i) - &#39;0&#39; : 0;
            int y &#x3D; j &gt;&#x3D; 0 ? num2.charAt(j) - &#39;0&#39; : 0;
            int result &#x3D; x + y + add;
            ans.append(result % 10);
            add &#x3D; result &#x2F; 10;
            i--;
            j--;
        &#125;
        ans.reverse();
        return ans.toString();
        &#x2F;&#x2F;这个题不会 想不明白
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>复原 IP 地址</p>
<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#49;&#54;&#x38;&#x40;&#49;&#x2e;&#x31;">&#x31;&#x39;&#50;&#46;&#49;&#54;&#x38;&#x40;&#49;&#x2e;&#x31;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]<br>示例 2：</p>
<p>输入：s = “0000”<br>输出：[“0.0.0.0”]<br>示例 3：</p>
<p>输入：s = “1111”<br>输出：[“1.1.1.1”]<br>示例 4：</p>
<p>输入：s = “010010”<br>输出：[“0.10.0.10”,”0.100.1.0”]<br>示例 5：</p>
<p>输入：s = “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public List&lt;String&gt; restoreIpAddresses(String s) &#123;
  ArrayList&lt;String&gt; strings &#x3D; new ArrayList&lt;&gt;();

        for (int i &#x3D; 1; i &lt; 4; i++) &#123;
            for (int j &#x3D; 1; j &lt; 4; j++) &#123;
                for (int k &#x3D; 1; k &lt; 4; k++) &#123;
                    for (int l &#x3D; 0; l &lt; 4; l++) &#123;
                        if (i + j + k + l &#x3D;&#x3D; s.length()) &#123;
                            String s1 &#x3D; s.substring(0, i);
                            String s2 &#x3D; s.substring(i, i+j);
                            String s3 &#x3D; s.substring(i + j, i + j + k);
                            String s4 &#x3D; s.substring(i + j + k, i + j + k + l);
                            if (checkout(s1) &amp;&amp; checkout(s2) &amp;&amp; checkout(s3) &amp;&amp; checkout(s4)) &#123;
                                StringBuilder builder &#x3D; new StringBuilder();
                                String ip &#x3D; builder.append(s1).append(&quot;.&quot;).append(s2).append(&quot;.&quot;).append(s3).append(&quot;.&quot;).append(s4).toString();
                                strings.add(ip);
                            &#125;
                        &#125;
                    &#125;
                &#125;
            &#125;

        &#125;
        return strings;
    &#125;
    
    
      public boolean checkout(String s) &#123;
        if (s.equals(&quot;&quot;))&#123;
            return false;
        &#125;

        if (s.charAt(0) &#x3D;&#x3D; &#39;0&#39; &amp;&amp; s.length() !&#x3D; 1) &#123;
            return false;
        &#125; else if (s.charAt(0) &#x3D;&#x3D; &#39;0&#39; &amp;&amp; s.length() &#x3D;&#x3D; 1) &#123;
            return true;
        &#125;

        try &#123;
            if (Integer.valueOf(s) &lt;&#x3D; 255) &#123;
                if (s.charAt(0) !&#x3D; &#39;0&#39;) &#123;
                    return true;
                &#125; else &#123;
                    return false;
                &#125;
            &#125;
        &#125; catch (Exception e) &#123;
            return false;
        &#125;
        return false;
    &#125;
    &#x2F;&#x2F;这个题也是不太会的
    
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> </p>
<p>验证回文串</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public boolean isPalindrome(String s) &#123;
            if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0)&#123;
                return false;
            &#125;
            &#x2F;&#x2F;先把它搞成小写的字母
            s&#x3D;s.toLowerCase();
            &#x2F;&#x2F;搞一个列表存储
            ArrayList&lt;Character&gt; list&#x3D;new ArrayList&lt;Character&gt;();
            &#x2F;&#x2F;遍历 判断是否是空和字母 数字 只加字母和数字
            for(int i&#x3D;0;i&lt;s.length();i++)&#123;
                char c&#x3D;s.charAt(i);
                if(c!&#x3D;&#39; &#39;&amp;&amp;c-&#39;a&#39;&lt;26&amp;&amp;c-&#39;a&#39;&gt;&#x3D;0)&#123;
                    list.add(c);
                &#125;
                if(c&gt;&#x3D;&#39;0&#39;&amp;&amp;c&lt;&#x3D;&#39;9&#39;)&#123;
                    list.add(c);
                &#125;
            &#125;
            &#x2F;&#x2F;判断头尾是否相等就可以了
        for(int i&#x3D;0;i&lt;(list.size()&#x2F;2);i++)&#123;
            if(list.get(i)!&#x3D;list.get(list.size()-i-1))&#123;
                return false;
            &#125;
        &#125;

            return  true;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>比较版本号</p>
<p>给你两个版本号 version1 和 version2 ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<p>返回规则如下：</p>
<p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。
 </p>
<p>示例 1：</p>
<p>输入：version1 = “1.01”, version2 = “1.001”<br>输出：0<br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”<br>示例 2：</p>
<p>输入：version1 = “1.0”, version2 = “1.0.0”<br>输出：0<br>解释：version1 没有指定下标为 2 的修订号，即视为 “0”<br>示例 3：</p>
<p>输入：version1 = “0.1”, version2 = “1.1”<br>输出：-1<br>解释：version1 中下标为 0 的修订号是 “0”，version2 中下标为 0 的修订号是 “1” 。0 &lt; 1，所以 version1 &lt; version2</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int compareVersion(String version1, String version2) &#123;
        &#x2F;&#x2F;先根据. 切割字符
          String [] a1 &#x3D;  version1.split(&quot;\\.&quot;);
          String [] a2 &#x3D;  version2.split(&quot;\\.&quot;);
        &#x2F;&#x2F;例子1 需要把前面的0给删除但是 Integer.valueOf 已经能满足这一点
        &#x2F;&#x2F;例子2 需要缺少下标的时候把值默认为0
        &#x2F;&#x2F;这个题就是题目太难理解了
          for(int n&#x3D;0;n&lt;Math.max(a1.length,a2.length);n++)&#123;
              int i&#x3D;(n&lt;a1.length?Integer.valueOf(a1[n]):0);
              int j&#x3D;(n&lt;a2.length?Integer.valueOf(a2[n]):0);
              if(i&lt;j)&#123;
                  return -1;
              &#125;else if(i&gt;j)&#123;
                   return 1;
              &#125;
          &#125;
          return 0;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最大数</p>
<p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums = [10,2]<br>输出：”210”<br>示例 2：</p>
<p>输入：nums = [3,30,34,5,9]<br>输出：”9534330”<br>示例 3：</p>
<p>输入：nums = [1]<br>输出：”1”<br>示例 4：</p>
<p>输入：nums = [10]<br>输出：”10”</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public String largestNumber(int[] nums) &#123;
            &#x2F;&#x2F;进行冒泡排序 排序的核心是 将两个字符加起来，然后进行排序大的排前面 小的排后面
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                for(int j&#x3D;i+1;i&lt;nums.length;j++)&#123;
                    if(i&gt;&#x3D;nums.length||j&gt;&#x3D;nums.length)&#123;
                        break;
                    &#125;
                    String temp1&#x3D;nums[i]+&quot;&quot;+nums[j];
                    String temp2&#x3D;nums[j]+&quot;&quot;+nums[i];
                    if(Long.parseLong(temp1)&lt;Long.parseLong(temp2))&#123;
                            int temp&#x3D;nums[i];
                             nums[i]&#x3D;nums[j];
                             nums[j]&#x3D;temp;
                    &#125;
                &#125;
            &#125;

            &#x2F;&#x2F;排完序的数组进行拼接 最后完成
          StringBuilder build&#x3D; new StringBuilder();
            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;
                if(&quot;0&quot;.equals(build.toString())&amp;&amp;nums[i]&#x3D;&#x3D;0)&#123;
                        continue;
                &#125;
               build.append(nums[i]);
            &#125;

            return build.toString();
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>反转字符串</p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public void reverseString(char[] s) &#123;

        &#x2F;&#x2F; 遍历列表 将最后一个和第一个取出来 然后进行调换就可以了
        for(int i&#x3D;0;i&lt;s.length&#x2F;2;i++)&#123;
            char first&#x3D;s[i];
            char last&#x3D;s[s.length-1-i];
            char temp &#x3D;first;
            first&#x3D;last;
            last&#x3D;temp;
            s[i]&#x3D;first;
            s[s.length-1-i]&#x3D;last;
        &#125;



    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>字符串相加</p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：num1 = “11”, num2 = “123”<br>输出：”134”<br>示例 2：</p>
<p>输入：num1 = “456”, num2 = “77”<br>输出：”533”<br>示例 3：</p>
<p>输入：num1 = “0”, num2 = “0”<br>输出：”0”</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public String addStrings(String num1, String num2) &#123;
        &#x2F;&#x2F;将字符串长度
        int l1&#x3D;num1.length()-1;
        int l2&#x3D;num2.length()-1;
        &#x2F;&#x2F;标志是否进位了
        int add&#x3D;0;
        &#x2F;&#x2F;字符串建造者
        StringBuilder build&#x3D;new StringBuilder();
        &#x2F;&#x2F;
        while(add!&#x3D;0||l1&gt;&#x3D;0||l2&gt;&#x3D;0)&#123;
            &#x2F;&#x2F;获取最低位然后减去’0‘拿到数值 如果长度低于0了 那么就返回0
             int x&#x3D;l1&gt;&#x3D;0?num1.charAt(l1)-&#39;0&#39;:0;   
             int y&#x3D;l2&gt;&#x3D;0?num2.charAt(l2)-&#39;0&#39;:0;
             System.out.print(&quot;x&quot;+x);      
             System.out.print(&quot;y&quot;+y);      
            &#x2F;&#x2F;两个数相加 然后加上进位的那个数
             int sum&#x3D;x+y+add;
            &#x2F;&#x2F;这个数取模
             int result&#x3D;sum%10; 
             &#x2F;&#x2F;除以10 看是否有进位
            add&#x3D;sum&#x2F;10; 
            &#x2F;&#x2F;将这个进位放到字符串数组中，但是这个是一个反序的
            build.append(result);
            &#x2F;&#x2F;当然要长度同时减1
            --l1;
            --l2;
        &#125;
        &#x2F;&#x2F;将字符串反转
        return build.reverse().toString();
      

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<p>验证IP地址</p>
<p>编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。</p>
<p>如果是有效的 IPv4 地址，返回 “IPv4” ；<br>如果是有效的 IPv6 地址，返回 “IPv6” ；<br>如果不是上述类型的 IP 地址，返回 “Neither” 。<br>IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(“.”)分割。比如，172.16.254.1；</p>
<p>同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。</p>
<p>IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (“:”)分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。</p>
<p>然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。</p>
<p>同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：IP = “172.16.254.1”<br>输出：”IPv4”<br>解释：有效的 IPv4 地址，返回 “IPv4”<br>示例 2：</p>
<p>输入：IP = “2001:0db8:85a3:0:0:8A2E:0370:7334”<br>输出：”IPv6”<br>解释：有效的 IPv6 地址，返回 “IPv6”<br>示例 3：</p>
<p>输入：IP = “256.256.256.256”<br>输出：”Neither”<br>解释：既不是 IPv4 地址，又不是 IPv6 地址<br>示例 4：</p>
<p>输入：IP = “2001:0db8:85a3:0:0:8A2E:0370:7334:”<br>输出：”Neither”<br>示例 5：</p>
<p>输入：IP = “1e1.4.5.6”<br>输出：”Neither”</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public String validIPAddress(String ip) &#123;
        &#x2F;&#x2F;先将ip进行切割
            String[] ipv4&#x3D;ip.split(&quot;\\.&quot;);
            String[] ipv6&#x3D;ip.split(&quot;:&quot;);
        &#x2F;&#x2F;按正常的规则
            if(ipv4.length&#x3D;&#x3D;4&amp;&amp;ip.charAt(0)!&#x3D;&#39;.&#39;&amp;&amp;ip.charAt(ip.length()-1)!&#x3D;&#39;.&#39;)&#123;
                &#x2F;&#x2F;遍历ip
                for(String s : ipv4)&#123;
                    if(s.length()&#x3D;&#x3D;0||s.length()&gt;&#x3D;4||(s.charAt(0)&#x3D;&#x3D;&#39;0&#39;&amp;&amp;s.length()&gt;1))&#123;
                        return &quot;Neither&quot;;
                    &#125;
                    int num&#x3D;0;
                    &#x2F;&#x2F;遍历数组下面的规则 每个小数组 只能是数字 且数字相加不能超过256
                    for(int i&#x3D;0;i&lt;s.length();i++)&#123;
                        char ch&#x3D;s.charAt(i);
                        if(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)&#123;
                            return &quot;Neither&quot;;
                        &#125;else&#123;
                            num&#x3D;num*10+(ch-&#39;0&#39;);
                        &#125;
                        System.out.print(&quot;num&quot;+num);
                        if(num&gt;&#x3D;256)&#123;
                            return &quot;Neither&quot;;
                        &#125;
                    &#125;

                &#125;
                return &quot;IPv4&quot;;
            &#125;

        &#x2F;&#x2F;ipv6 数组长度不能超过8  全部能不能超过16 不能 :开头或者结尾
  if (ipv6.length &#x3D;&#x3D; 8 &amp;&amp; ip.length() &gt;&#x3D; 15 &amp;&amp; ip.charAt(0) !&#x3D; &#39;:&#39; 
        &amp;&amp; ip.charAt(ip.length() - 1) !&#x3D; &#39;:&#39;) &#123;
            for (String s : ipv6) &#123;
                if (s.length() &#x3D;&#x3D; 0 || s.length() &gt; 4) return &quot;Neither&quot;;
                for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;
                    char ch &#x3D; s.charAt(i);
                    System.out.print(ch);
                    if (!(ch &gt;&#x3D; &#39;0&#39;  &amp;&amp; ch &lt;&#x3D; &#39;9&#39; || ch &gt;&#x3D; &#39;A&#39; &amp;&amp; ch &lt;&#x3D; &#39;F&#39; 
                    || ch &gt;&#x3D; &#39;a&#39; &amp;&amp; ch &lt;&#x3D; &#39;f&#39;)) return &quot;Neither&quot;;
                &#125;
            &#125;
            return &quot;IPv6&quot;;
        &#125;
        return &quot;Neither&quot;;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>最长回文子序列</p>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = “bbbab”<br>输出：4<br>解释：一个可能的最长回文子序列为 “bbbb” 。<br>示例 2：</p>
<p>输入：s = “cbbd”<br>输出：2<br>解释：一个可能的最长回文子序列为 “bb” 。
 </p>
 <pre class="line-numbers language-none"><code class="language-none"> class Solution &#123;
    public int longestPalindromeSubseq(String s) &#123;
            int n&#x3D;s.length();
            int [][] dp&#x3D;new int[n][n];

            for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;
                dp[i][i]&#x3D;1;
                char c1&#x3D;s.charAt(i);
                for(int j&#x3D;i+1;j&lt;n;j++)&#123;
                    char c2&#x3D;s.charAt(j);
                    if(c1&#x3D;&#x3D;c2)&#123;
                        dp[i][j]&#x3D;dp[i+1][j-1]+2;
                    &#125;else&#123;
                        dp[i][j]&#x3D;Math.max(dp[i+1][j],dp[i][j-1]);
                    &#125;
                &#125;
            &#125;
            &#x2F;&#x2F;不太会
        return dp[0][n-1];
    &#125;
&#125;
 
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最长公共子序列</p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br>示例 2：</p>
<p>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。<br>示例 3：</p>
<p>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int longestCommonSubsequence(String text1, String text2) &#123;
            int m&#x3D;text1.length();
            int n&#x3D;text2.length();

&#x2F;&#x2F; 为了把第一行和第一列给空出来
            int[][] arr&#x3D;new int [m+1][n+1];

      &#x2F;&#x2F; 从1行开始 第一列开始
            for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;
                for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;
                    &#x2F;&#x2F;如果相等那么就是大家的上一个加1也就是左上角
                    char c1&#x3D; text1.charAt(i-1);
                    char c2&#x3D;text2.charAt(j-1);
                    if(c1&#x3D;&#x3D;c2)&#123;
                        arr[i][j]&#x3D;arr[i-1][j-1]+1;
                    &#125;else&#123;
                        &#x2F;&#x2F;如果不相等，那么就取上面和左边的最大值，也就是两个长度的数组的最大值
                        arr[i][j]&#x3D;Math.max(arr[i-1][j],arr[i][j-1]);
                    &#125;

                &#125;
            &#125;
                return arr[m][n];
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>字符串的排列</p>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p> </p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p> </p>
<p>示例:</p>
<p>输入：s = “abc”<br>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]
 </p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public String[] permutation(String s) &#123;
     Set&lt;String&gt; list&#x3D;new HashSet&lt;&gt;();
        char[]arr&#x3D;s.toCharArray();
        StringBuilder sb &#x3D;new StringBuilder();
        boolean[] visited&#x3D;new boolean[arr.length];
        dfs(arr,&quot;&quot;,visited,list);
        return list.toArray(new String[0]);
    &#125;

    public void dfs(char[] arr,String s,boolean[] visited,Set&lt;String&gt; list)&#123;
            if(s.length()&#x3D;&#x3D;arr.length)&#123;
                list.add(s);
                return;
            &#125;

            for(int i&#x3D;0;i&lt;arr.length;i++)&#123;
                if(visited[i])&#123;
                    continue;
                &#125;
                visited[i]&#x3D;true;
                dfs(arr,s+String.valueOf(arr[i]),visited,list);
                visited[i]&#x3D;false;
            &#125;
        &#x2F;&#x2F;不太会

    &#125;
    
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”
 </p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int translateNum(int num) &#123;
        &#x2F;&#x2F;因为问的是个数
        &#x2F;&#x2F;如果小于9 那么就只有一种可能
            if(num&lt;&#x3D;9)&#123;
                return 1;
            &#125;
            &#x2F;&#x2F;先拿最后两位出来
            int ba&#x3D;num%100;
            if(ba&gt;&#x3D;26||ba&lt;&#x3D;9)&#123;
                &#x2F;&#x2F;如果小于9且大于26 那么切割一次
               return translateNum(num&#x2F;10);      
            &#125;else&#123;
                &#x2F;&#x2F;如果在26和9之间的那么有两种可能 一种是切一次 种是切两次
                return translateNum(num&#x2F;10)+translateNum(num&#x2F;100);
            &#125;
       

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p> 第一个只出现一次的字符</p>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例 1:</p>
<p>输入：s = “abaccdeff”<br>输出：’b’<br>示例 2:</p>
<p>输入：s = “”<br>输出：’ ‘</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public char firstUniqChar(String s) &#123;
        char result&#x3D;&#39; &#39;;
        &#x2F;&#x2F;存储字符和对应的次数
      HashMap&lt;Character,Integer&gt; map&#x3D; new HashMap&lt;Character,Integer&gt;();
      &#x2F;&#x2F;将字符串和次数整理到map中
        for(int i&#x3D;0;i&lt;s.length();i++)&#123;
           char at&#x3D; s.charAt(i);
            if(map.get(at)&#x3D;&#x3D;null)&#123;
                map.put(at,1);
            &#125;else&#123;
               int value&#x3D; (int)map.get(at);
               map.put(at,value+1);
            &#125;
        &#125;
        &#x2F;&#x2F;遍历map找出次数为1的
       Set&lt;Character&gt; sets&#x3D; map.keySet();

      ArrayList&lt;Character&gt; list&#x3D;  new ArrayList&lt;Character&gt;();

       for(Character c:sets)&#123;
           if((int)map.get(c)&#x3D;&#x3D;1)&#123;
              list.add(c);
           &#125;
       &#125;
       &#x2F;&#x2F;通过字符串遍历 如果存在次数为1的返回，可以完成第一次的设定
       for(int i&#x3D;0;i&lt;s.length();i++)&#123;
            if(list.contains(s.charAt(i)))&#123;
                return s.charAt(i);
            &#125;
       &#125;
        return result;
    &#125;

 
&#125;



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>翻转单词顺序</p>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public String reverseWords(String s) &#123;
        if(s&#x3D;&#x3D;null||s.length()&#x3D;&#x3D;0)&#123;
            return &quot;&quot;;
        &#125;
        &#x2F;&#x2F;先把字符串的前面和后面空格去掉
        s&#x3D;s.trim();
        String result&#x3D;&quot;&quot;;
        &#x2F;&#x2F;将字符串按空格切割
        String [] strArr&#x3D;s.split(&quot; &quot;);
        &#x2F;&#x2F;将数组的前面和后面进行调转
        for(int i&#x3D;0;i&lt;strArr.length&#x2F;2;i++)&#123;
            String firstStr&#x3D;strArr[i];
            String secondStr&#x3D;strArr[strArr.length-1-i];
            String tempStr&#x3D;firstStr;
             firstStr&#x3D;secondStr;
             secondStr&#x3D;tempStr;
            strArr[i]&#x3D;firstStr;
            strArr[strArr.length-1-i]&#x3D;secondStr;
        &#125;
        &#x2F;&#x2F;最后拼接回来
        for(int i&#x3D;0;i&lt;strArr.length;i++)&#123;
            result&#x3D;result.trim()+&quot; &quot;+strArr[i];
        &#125;


        return result.trim();

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>把字符串转换成整数</p>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p> </p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例 1:</p>
<p>输入: “42”<br>输出: 42<br>示例 2:</p>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br>示例 3:</p>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。<br>示例 4:</p>
<p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br>示例 5:</p>
<p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。<br>     因此返回 INT_MIN (−231) 。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int strToInt(String str) &#123;
            &#x2F;&#x2F;字符串先去空格
            str&#x3D;str.trim();
            int result&#x3D;0;
            &#x2F;&#x2F;标志是否应该取反
            boolean reverse&#x3D;false;
            &#x2F;&#x2F;字符串为空 或者长度为0
            if(str&#x3D;&#x3D;null||str.length()&#x3D;&#x3D;0)&#123;
                return 0;
            &#125;
            &#x2F;&#x2F;看第一位是不是负数
            if(str.charAt(0)&#x3D;&#x3D;&#39;-&#39;)&#123;
                reverse&#x3D;true;
                str&#x3D;str.substring(1,str.length());
            &#125;else if(str.charAt(0)&#x3D;&#x3D;&#39;+&#39;)&#123;
                reverse&#x3D;false;
                str&#x3D;str.substring(1,str.length());
            &#125;

            &#x2F;&#x2F;将字符串切割开然后放进去 字符串建造器
            StringBuilder build&#x3D;new StringBuilder();
            for(int i&#x3D;0;i&lt;str.length();i++)&#123;
              char at&#x3D;str.charAt(i);
                if(at-&#39;0&#39;&lt;&#x3D;9&amp;&amp;at-&#39;0&#39;&gt;&#x3D;0)&#123;
                    build.append(at);
                &#125;else&#123;
                    break;
                &#125;
            &#125;
            &#x2F;&#x2F;如果长度为0 那么
            if(build.length()&#x3D;&#x3D;0)&#123;
                return result;
            &#125;
            &#x2F;&#x2F;如果数值大于int的最大值
            long tempResult&#x3D;0;
            &#x2F;&#x2F;如果超过了返回integer最大值
            for(int i&#x3D;0;i&lt;build.length();i++)&#123;
                tempResult&#x3D;tempResult*10+Integer.valueOf(build.charAt(i)-&#39;0&#39;);
                if(tempResult&gt;Integer.MAX_VALUE)&#123;
                    if(reverse)&#123;
                        return Integer.MIN_VALUE;
                    &#125;else&#123;
                        return Integer.MAX_VALUE;
                    &#125;
                &#125;
            &#125;     
            &#x2F;&#x2F;将long转成int 然后取反 返回
            result&#x3D;(int)tempResult;
            if(reverse)&#123;
                result&#x3D;-result;
            &#125;
            return result;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>字符串轮转</p>
<p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p>
<p>示例1:</p>
<p> 输入：s1 = “waterbottle”, s2 = “erbottlewat”<br> 输出：True<br>示例2:</p>
<p> 输入：s1 = “aa”, s2 = “aba”<br> 输出：False</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public boolean isFlipedString(String s1, String s2) &#123;
        &#x2F;&#x2F;如果有一个空 那么就返回false
        if(s1&#x3D;&#x3D;null||s2&#x3D;&#x3D;null)&#123;
            return false;
        &#125;
        &#x2F;&#x2F;如果长度不相等
        if(s1.length()!&#x3D;s2.length())&#123;
                return false;
        &#125;
        &#x2F;&#x2F;将两个 s2进行拼接 因为无论怎么转 只要一拼接 那么就会有出现 一样的
        String ss&#x3D;s2+s2;
        &#x2F;&#x2F; 看有没有包含住就可以了
        return ss.contains(s1);

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>无重复字符串的排列组合</p>
<p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p>
<p>示例1:</p>
<p> 输入：S = “qwe”<br> 输出：[“qwe”, “qew”, “wqe”, “weq”, “ewq”, “eqw”]<br>示例2:</p>
<p> 输入：S = “ab”<br> 输出：[“ab”, “ba”]</p>
 <pre class="line-numbers language-none"><code class="language-none"> 
 
 class Solution &#123;
     List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();
     StringBuffer s&#x3D;new StringBuffer();
        
    public String[] permutation(String S) &#123;
        dfs(S,list,s);
        return list.toArray(new String[list.size()]);
    &#125;


    public void dfs(String S,List&lt;String&gt; list,StringBuffer s)&#123;
        if(s.length() &#x3D;&#x3D; S.length())&#123;
            list.add(new String(s));
            return;
        &#125;
        for(int i&#x3D;0;i&lt;S.length();i++)&#123;
            String zz&#x3D;new String(s);
            if(zz.contains(S.charAt(i)+&quot;&quot;))&#123;
                continue;
            &#125;
            s.append(S.charAt(i));
            dfs(S,list,s);
            s.deleteCharAt(s.length()-1);
        &#125;
        &#x2F;&#x2F;没有看懂
    &#125;
&#125;
 
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 有重复字符串的排列组合</p>
<p> 有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>
<p>示例1:</p>
<p> 输入：S = “qqe”<br> 输出：[“eqq”,”qeq”,”qqe”]<br>示例2:</p>
<p> 输入：S = “ab”<br> 输出：[“ab”, “ba”]</p>
 <pre class="line-numbers language-none"><code class="language-none"> class Solution &#123;

    LinkedList&lt;String&gt; list&#x3D; new LinkedList&lt;String&gt;();
    public String[] permutation(String S) &#123;
        dfs(S.toCharArray(),0);
        return list.toArray(new String[0]);
    &#125;


     public void  dfs(char[] c,int k)&#123;
        if(k&#x3D;&#x3D;c.length)&#123;
            list.add(new String(c));
            return;
        &#125;
        HashSet&lt;Character&gt; set&#x3D; new HashSet&lt;&gt;();
        for(int i&#x3D;k;i&lt;c.length;i++)&#123;
            if(!set.contains(c[i]))&#123;
                set.add(c[i]);
                swap(c,i,k);
                dfs(c,k+1);
                swap(c,i,k);
            &#125;
        &#125;
        &#x2F;&#x2F;这个题还没有
    &#125;


    public void swap(char[] c,int x,int y)&#123;
        char  temp&#x3D;c[x];
        c[x]&#x3D;c[y];
        c[y]&#x3D;temp;
    &#125;
&#125;
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p> 二叉树的中序遍历</p>
<p> 给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：root = []<br>输出：[]<br>示例 3：</p>
<p>输入：root = [1]<br>输出：[1]<br>示例 4：</p>
<p>输入：root = [1,2]<br>输出：[2,1]<br>示例 5：</p>
<p>输入：root = [1,null,2]<br>输出：[1,2]</p>
<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        &#x2F;&#x2F;搞个列表
         ArrayList&lt;Integer&gt; list &#x3D;new  ArrayList&lt;Integer&gt;();

         &#x2F;&#x2F;如果为空就返回空
         if(root&#x3D;&#x3D;null)&#123;
             return list;
         &#125;
        rebuildTree(root,list);
        return list;
    &#125;

    public void rebuildTree(TreeNode root,ArrayList&lt;Integer&gt; list)&#123;
        &#x2F;&#x2F;如果为空就是返回这个是定递归的退出条件
        if(root&#x3D;&#x3D;null)&#123;
           return;
        &#125;
        &#x2F;&#x2F;如果左子树不为空 那么就将左子树放进去
        if(root.left!&#x3D;null)&#123;
        rebuildTree(root.left,list);
        &#125;
        &#x2F;&#x2F;放一个根节点
        list.add(root.val);
        &#x2F;&#x2F;如果右子树不为空 那么就将右子树放进去
        if(root.right!&#x3D;null)&#123;
        rebuildTree(root.right,list);
        &#125;



    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>验证二叉搜索树</p>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。
 </p>
<p>示例 1：</p>
<p>输入：root = [2,1,3]<br>输出：true<br>示例 2：</p>
<p>输入：root = [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 </p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public boolean isValidBST(TreeNode root) &#123;
        &#x2F;&#x2F;递归  传一个最小和一个最大
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    &#125;

    public boolean isValidBST(TreeNode node, long lower, long upper) &#123;
        &#x2F;&#x2F;如果为空返回true
        if (node &#x3D;&#x3D; null) &#123;
            return true;
        &#125;
    &#x2F;&#x2F;这个值小于下界 或者这个值大于上界就返回false
        if (node.val &lt;&#x3D; lower || node.val &gt;&#x3D; upper) &#123;
            return false;
        &#125;
        &#x2F;&#x2F;继续分隔两边的根进行
        return isValidBST(node.left, lower, node.val) &amp;&amp; isValidBST(node.right, node.val, upper);
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二叉树的层序遍历</p>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p>
<p>输入：root = [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root = []<br>输出：[]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
     ArrayList&lt;List&lt;Integer&gt;&gt; list&#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();
            &#x2F;&#x2F; 如果为空 返回空
            if(root&#x3D;&#x3D;null)&#123;
                return list;
            &#125;
        &#x2F;&#x2F;队列
        LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();
        &#x2F;&#x2F;先加一个根进去
        queue.add(root);
        &#x2F;&#x2F;当根不为空的时候
        while(!queue.isEmpty())&#123;
            ArrayList&lt;Integer&gt; tempList&#x3D;new ArrayList&lt;Integer&gt;();
            &#x2F;&#x2F;先拿出目前长度
            int size&#x3D;queue.size();
            &#x2F;&#x2F;长度大于0的时候
            while(size&gt;0)&#123;
                &#x2F;&#x2F;从队列中拉一个出来
            TreeNode node&#x3D;queue.poll();
            &#x2F;&#x2F;放进去列表中
            tempList.add(node.val);
            &#x2F;&#x2F;队列的左边不为空 加入
            if(node.left!&#x3D;null)&#123;
                queue.add(node.left);
            &#125;
            &#x2F;&#x2F;队列的右边不为空 加入
            if(node.right!&#x3D;null)&#123;
                queue.add(node.right);
            &#125;
            &#x2F;&#x2F;长度一直在递减
              --size;
            &#125;
            &#x2F;&#x2F;列表加入这个字符串
            list.add(tempList);
        &#125;
        &#x2F;&#x2F;列表返回
        return list;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>平衡二叉树</p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：true<br>示例 2：</p>
<p>输入：root = [1,2,2,3,3,null,null,4,4]<br>输出：false<br>示例 3：</p>
<p>输入：root = []<br>输出：true</p>
<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        &#x2F;&#x2F;如果为空那么可以
            if(root&#x3D;&#x3D;null)&#123;
                return true;
            &#125;

        &#x2F;&#x2F;左右子树的深度
            int left&#x3D;depth(root.left);
            int right&#x3D;depth(root.right);
            &#x2F;&#x2F;还有子树的左右子树也需要是平衡树
            return Math.abs(left-right)&lt;&#x3D;1&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);
    &#125;

&#x2F;&#x2F;算出以一个树为基础的深度为多少
    public int depth(TreeNode root)&#123;
            if(root&#x3D;&#x3D;null)&#123;
                return 0;
            &#125;

            return Math.max(depth(root.left),depth(root.right))+1;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>求根节点到叶节点数字之和</p>
<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>
<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>
<p>叶节点 是指没有子节点的节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 = 12 + 13 = 25<br>示例 2：</p>
<p>输入：root = [4,9,0,5,1]<br>输出：1026<br>解释：<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>从根到叶子节点路径 4-&gt;0 代表数字 40<br>因此，数字总和 = 495 + 491 + 40 = 1026</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int sumNumbers(TreeNode root) &#123;
            return count(root,0);
    &#125;

    &#x2F;&#x2F;递归调用左边和右边相加
    int count(TreeNode root,int sum)&#123;
            if(root&#x3D;&#x3D;null)&#123;
                return 0;
            &#125;else if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)&#123;
                return sum*10+root.val;
            &#125;else&#123;
                return count(root.left,sum*10+root.val)+count(root.right,sum*10+root.val);
            &#125;
        
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二叉树的前序遍历</p>
<p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p>
<p>输入：root = []<br>输出：[]<br>示例 3：</p>
<p>输入：root = [1]<br>输出：[1]<br>示例 4：</p>
<p>输入：root = [1,2]<br>输出：[1,2]<br>示例 5：</p>
<p>输入：root = [1,null,2]<br>输出：[1,2]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        &#x2F;&#x2F;搞个列表
        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();
        &#x2F;&#x2F;如果为空就直接返回
        if(root&#x3D;&#x3D;null)&#123;
            return list;
        &#125;
        &#x2F;&#x2F;递归
        createTree(root,list);
        return list;
    &#125;


    public void  createTree(TreeNode root, ArrayList list)&#123;
            if(root&#x3D;&#x3D;null)&#123;
                return;
            &#125;
            &#x2F;&#x2F;注意顺序 先序就把根放前面
            list.add(root.val);
            &#x2F;&#x2F;如果左子树不为空 递归左子树
            if(root.left!&#x3D;null)&#123;
                createTree(root.left,list);
            &#125;
            &#x2F;&#x2F;如果右子树不为空 递归右子树
            if(root.right!&#x3D;null)&#123;
                createTree(root.right,list);
            &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二叉树的后序遍历</p>
<p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 </p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,3]<br>输出：[3,2,1]</p>
<p>示例 2：</p>
<p>输入：root = []<br>输出：[]<br>示例 3：</p>
<p>输入：root = [1]<br>输出：[1]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;这个题跟前序遍历 和中序遍历原理一模一样
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
            ArrayList&lt;Integer&gt; list&#x3D; new ArrayList&lt;Integer&gt;();
            if(root&#x3D;&#x3D;null)&#123;
                return list;
            &#125;
            createTree(root,list);

            return list;
    &#125;

    public void createTree(TreeNode root,ArrayList list)&#123;
        if(root&#x3D;&#x3D;null)&#123;
            return ;
        &#125;
        if(root.left!&#x3D;null)&#123;
            createTree(root.left,list);
        &#125;
        if(root.right!&#x3D;null)&#123;
            createTree(root.right,list);
        &#125;

        list.add(root.val);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>二叉树的右视图</p>
<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br>示例 2:</p>
<p>输入: [1,null,3]<br>输出: [1,3]<br>示例 3:</p>
<p>输入: []<br>输出: []</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;
    &#x2F;&#x2F;搞一个作为结果
     ArrayList&lt;Integer&gt; result&#x3D;new ArrayList&lt;Integer&gt;();
     if(root&#x3D;&#x3D;null)&#123;
         return result;
     &#125;
     &#x2F;&#x2F;搞个列表存储
     ArrayList&lt;List&lt;Integer&gt;&gt; list&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;();
    &#x2F;&#x2F;搞个队列
     LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D; new LinkedBlockingQueue&lt;TreeNode&gt;();
     &#x2F;&#x2F;队列接入一个根
     queue.add(root);
     &#x2F;&#x2F;根不为空的时候  这个模型就是把树转成了列表
     while(!queue.isEmpty())&#123;
         int size&#x3D;queue.size();
        ArrayList&lt;Integer&gt; tempList&#x3D; new ArrayList&lt;Integer&gt;();
         while(size&gt;0)&#123;
            TreeNode tree&#x3D;queue.poll();
            if(tree.left!&#x3D;null)&#123;
                queue.add(tree.left);
            &#125;
            if(tree.right!&#x3D;null)&#123;
                queue.add(tree.right);
            &#125;
            tempList.add(tree.val);
             size--;
         &#125;
         list.add(tempList);
     &#125;


        &#x2F;&#x2F;把列表的最后一个放进另外一个列表即可
     for(int i&#x3D;0;i&lt;list.size();i++)&#123;
        List&lt;Integer&gt; tempList&#x3D;list.get(i);
         result.add(tempList.get(tempList.size()-1));
      &#125;
          return result;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>完全二叉树的节点个数</p>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,2,3,4,5,6]<br>输出：6<br>示例 2：</p>
<p>输入：root = []<br>输出：0<br>示例 3：</p>
<p>输入：root = [1]<br>输出：1</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int countNodes(TreeNode root) &#123;
        &#x2F;&#x2F;如果为空 那么返回0
        if(root&#x3D;&#x3D;null)&#123;
            return 0;
        &#125;
    &#x2F;&#x2F;搞一个队列
     LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();
    &#x2F;&#x2F;队列加入一个根节点
    queue.add(root);
    &#x2F;&#x2F;列表
     ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();
     &#x2F;&#x2F;当队列不为空的时候
        while(!queue.isEmpty())&#123;
            &#x2F;&#x2F;队列长度
            int size&#x3D;queue.size();
            &#x2F;&#x2F;当大小大于0
            while(size&gt;0)&#123;
               TreeNode tree&#x3D;queue.poll();
               &#x2F;&#x2F;将左右子树加入
                if(tree.left!&#x3D;null)&#123;
                    queue.add(tree.left);
                &#125;
                if(tree.right!&#x3D;null)&#123;
                    queue.add(tree.right);
                &#125;
                &#x2F;&#x2F;列表加入
                list.add(tree.val);
                size--;
            &#125;
        &#125;
        &#x2F;&#x2F;这个数字就是节点的数字
            return list.size();
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二叉搜索树中第K小的元素</p>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,1,4,null,2], k = 1<br>输出：1<br>示例 2：</p>
<p>输入：root = [5,3,6,2,4,null,null,1], k = 3<br>输出：3</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int kthSmallest(TreeNode root, int k) &#123;
         ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();
        if(root&#x3D;&#x3D;null)&#123;
            return 0;
        &#125;
        &#x2F;&#x2F;这个还是那个层次遍历的模型 然后搞成一个列表 然后搞成一个数组，然后对数组进行排序 然后 就可以看到第k小的数字了
        LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();
        queue.add(root);
        while(!queue.isEmpty())&#123;
            int size&#x3D;queue.size();
             while(size&gt;0)&#123;
                TreeNode tree&#x3D; queue.poll();
            
                if(tree.left!&#x3D;null)&#123;
                    queue.add(tree.left);
                &#125;

                if(tree.right!&#x3D;null)&#123;
                    queue.add(tree.right);
                &#125;
                 list.add(tree.val);
                --size;
            &#125;
        &#125;
        int[] arr&#x3D;new int[list.size()];

        for(int i&#x3D;0;i&lt;list.size();i++)&#123;
            arr[i]&#x3D;list.get(i);
        &#125;

        Arrays.sort(arr);


        return arr[k-1];
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二叉树的最近公共祖先</p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p>
<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p>
<p>输入：root = [1,2], p = 1, q = 2<br>输出：1</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
     HashMap&lt;Integer, TreeNode&gt; parent &#x3D; new HashMap&lt;&gt;();
    HashSet&lt;Integer&gt; visited &#x3D; new HashSet&lt;&gt;();
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        dfs(root);

        while (p !&#x3D; null) &#123;
            visited.add(p.val);
            p &#x3D; parent.get(p.val);
        &#125;

        while (q !&#x3D; null) &#123;
            if (visited.contains(q.val)) &#123;
                return q;
            &#125;
            &#x2F;&#x2F;从下往上访问父节点  map存的是父节点
            q &#x3D; parent.get(q.val);
        &#125;
        return null;
    &#125;
    
      public void dfs(TreeNode root) &#123;
        if (root.left !&#x3D; null) &#123;
            parent.put(root.left.val, root);
            dfs(root.left);
        &#125;
        if (root.right !&#x3D; null) &#123;
            parent.put(root.right.val, root);
            dfs(root.right);
        &#125;
        &#x2F;&#x2F;没看懂
    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>二叉树的直径</p>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p> </p>
<p>示例 :<br>给定二叉树</p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    
</code></pre>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    int ans;
    public int diameterOfBinaryTree(TreeNode root) &#123;
        ans &#x3D; 1;
        depth(root);
        return ans - 1;
    &#125;
    public int depth(TreeNode node) &#123;
        if (node &#x3D;&#x3D; null) &#123;
            return 0; &#x2F;&#x2F; 访问到空节点了，返回0
        &#125;
        int L &#x3D; depth(node.left); &#x2F;&#x2F; 左儿子为根的子树的深度
        int R &#x3D; depth(node.right); &#x2F;&#x2F; 右儿子为根的子树的深度
        ans &#x3D; Math.max(ans, L+R+1); &#x2F;&#x2F; 计算d_node即L+R+1 并更新ans
        return Math.max(L, R) + 1; &#x2F;&#x2F; 返回该节点为根的子树的深度
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<p>合并二叉树</p>
<p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<br>示例 2：</p>
<p>输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
        &#x2F;&#x2F;如果2为空 返回1
        if(root2&#x3D;&#x3D;null)&#123;
               return root1;
        &#125;
        &#x2F;&#x2F;如果1位空 返回2
        if(root1&#x3D;&#x3D;null)&#123;
               return root2;
        &#125;
        &#x2F;&#x2F;如果都不会空 相加
        root1.val&#x3D;root1.val+root2.val;

        &#x2F;&#x2F;递归 左边和左边
        root1.left&#x3D;mergeTrees(root1.left,root2.left);
        &#x2F;&#x2F;递归 右边和右边
        root1.right&#x3D;mergeTrees(root1.right,root2.right);
        return root1;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二叉树的镜像</p>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<p>     4<br>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：</p>
<p>     4<br>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public TreeNode mirrorTree(TreeNode root) &#123;
        &#x2F;&#x2F;如果为空那么返回为空
         if(root&#x3D;&#x3D;null)&#123;
            return null;
          &#125;
            &#x2F;&#x2F;这个本质上是调换两个子树
            TreeNode leftTree&#x3D; root.left;
            TreeNode temp&#x3D;leftTree;
            root.left&#x3D; root.right;
            root.right&#x3D;temp;
            &#x2F;&#x2F;然后递归继续去换子树
            mirrorTree(root.left);
            mirrorTree(root.right);

        return root;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>对称的二叉树</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<p>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p>    1<br>   / <br>  2   2<br>   \   <br>   3    3</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p>
<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public boolean isSymmetric(TreeNode root) &#123;
        &#x2F;&#x2F;如果为空也是一个镜像函数
          if(root&#x3D;&#x3D;null)&#123;
              return true;
          &#125;
    
        &#x2F;&#x2F;判断是否镜像
        return isSame(root,root);

    &#125;

    public boolean isSame(TreeNode root,TreeNode monitorTree)&#123;
        &#x2F;&#x2F;如果为空可以
       if(root&#x3D;&#x3D;null&amp;&amp;monitorTree&#x3D;&#x3D;null)&#123;
           return true;
       &#125;
        &#x2F;&#x2F;如果有一个不为空 一个为空不行
       if(root&#x3D;&#x3D;null||monitorTree&#x3D;&#x3D;null)&#123;
           return false;
       &#125;

        &#x2F;&#x2F;如果值相等 那么  对应镜像的值去匹配  左子树的跟另外一个右子树比 右子树的跟左子树比
        if(root.val&#x3D;&#x3D;monitorTree.val)&#123;
            return isSame(root.left,monitorTree.right)&amp;&amp;isSame(root.right,monitorTree.left);
        &#125;else&#123;
            return false;
        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>从上到下打印二叉树 II</p>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p> </p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        &#x2F;&#x2F;存储结果的列表
       ArrayList&lt;List&lt;Integer&gt;&gt;  result&#x3D;    new ArrayList&lt;List&lt;Integer&gt;&gt;();
       &#x2F;&#x2F;如果为空的话 直接返回
       if(root&#x3D;&#x3D;null)&#123;
           return result;
       &#125;



        LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D; new LinkedBlockingQueue&lt;TreeNode&gt;();
        &#x2F;&#x2F;队列中放进一个根的数值
        queue.add(root);
        &#x2F;&#x2F;如果不为空那么就继续
        while(!queue.isEmpty())&#123;
            &#x2F;&#x2F;先取出当期的队列长度
            int size &#x3D;queue.size();
            &#x2F;&#x2F;搞一个列表
            ArrayList&lt;Integer&gt; tempList&#x3D;new ArrayList&lt;Integer&gt;();
            &#x2F;&#x2F;如果队列长度大于0
            while(size&gt;0)&#123; 
                &#x2F;&#x2F;从队列中搞一个出来
                TreeNode tree&#x3D;queue.poll();
                &#x2F;&#x2F;如果左子树不为空就放进去
                if(tree.left!&#x3D;null)&#123;
                    queue.add(tree.left);
                &#125;
                &#x2F;&#x2F;如果右子树不为空也放进去
                if(tree.right!&#x3D;null)&#123;
                    queue.add(tree.right);
                &#125;
                &#x2F;&#x2F;把值放到一个列表之中
                tempList.add(tree.val);
                &#x2F;&#x2F;大小减一   
                --size;
            &#125;
            &#x2F;&#x2F;将结果返回回去
            result.add(tempList);
        &#125;
        return result;
    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<p>从上到下打印二叉树 III</p>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p> </p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        &#x2F;&#x2F;搞一个结果的列表
       ArrayList&lt;List&lt;Integer&gt;&gt;  result&#x3D;new ArrayList&lt;List&lt;Integer&gt;&gt;();
       &#x2F;&#x2F;如果为空返回
        if(root&#x3D;&#x3D;null)&#123;
            return result;
        &#125;
        &#x2F;&#x2F;这个是要不要反转的标志
        boolean flag&#x3D;false;
        &#x2F;&#x2F;队列
      LinkedBlockingQueue&lt;TreeNode&gt; queue &#x3D; new LinkedBlockingQueue&lt;TreeNode&gt;();
      &#x2F;&#x2F;先放一个根目录
      queue.add(root);
        &#x2F;&#x2F;当队列不为空的时候
        while(!queue.isEmpty())&#123;
            &#x2F;&#x2F;队列长度
            int size&#x3D;queue.size();
            &#x2F;&#x2F;临时的数组长度
        ArrayList&lt;Integer&gt; list&#x3D;new  ArrayList&lt;Integer&gt;();
            while(size&gt;0)&#123;
                &#x2F;&#x2F;从队列拿出第一个
                TreeNode tree&#x3D;queue.poll();
                &#x2F;&#x2F;如果存在左右子树就放进去
                if(tree.left!&#x3D;null)&#123;
                    queue.add(tree.left);
                &#125;
                if(tree.right!&#x3D;null)&#123;
                    queue.add(tree.right);
                &#125;
                &#x2F;&#x2F;列表放这个数的值
                list.add(tree.val);
                &#x2F;&#x2F;
                --size;
            &#125;
            &#x2F;&#x2F;控制是否需要反转
          if(flag)&#123;
            Collections.reverse(list);
          &#125;
          &#x2F;&#x2F;标志位取反
          flag&#x3D;!flag;
          &#x2F;&#x2F;将结果加进去
           result.add(list);
        &#125;

        return result;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>二叉树中和为某一值的路径</p>
<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p>
<p>输入：root = [1,2,3], targetSum = 5<br>输出：[]<br>示例 3：</p>
<p>输入：root = [1,2], targetSum = 0<br>输出：[]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() &#123;&#125;
 *     TreeNode(int val) &#123; this.val &#x3D; val; &#125;
 *     TreeNode(int val, TreeNode left, TreeNode right) &#123;
 *         this.val &#x3D; val;
 *         this.left &#x3D; left;
 *         this.right &#x3D; right;
 *     &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;搞个结果的容器
    List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123;
        &#x2F;&#x2F;深度优先
        dfs(root,target,new ArrayList());
        return result;
    &#125;

    public void dfs(TreeNode root, int target,List list)&#123;
        &#x2F;&#x2F;如果为空的话就返回
            if(root&#x3D;&#x3D;null)&#123;
                return ;
            &#125;
            &#x2F;&#x2F;列表加入根的值
            list.add(root.val);
            &#x2F;&#x2F;如果这个值是跟目标匹配
            if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null&amp;&amp;root.val&#x3D;&#x3D;target)&#123;
                result.add(new ArrayList&lt;&gt;(list));
            &#125;
            &#x2F;&#x2F;进行左边和右边目标值
            dfs(root.left,target-root.val,list);
            dfs(root.right,target-root.val,list);
            &#x2F;&#x2F;列表删除前面那个
            list.remove(list.size()-1);

    &#125;



&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>二叉树的深度</p>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
    &#x2F;&#x2F;搞一个队列来存树
    LinkedBlockingQueue&lt;TreeNode&gt; queue&#x3D;new LinkedBlockingQueue&lt;TreeNode&gt;();
    if(root&#x3D;&#x3D;null)&#123;
        return 0;
    &#125;
    &#x2F;&#x2F;先加一个根进去
    queue.add(root);
    &#x2F;&#x2F;深度为0
    int depth&#x3D;0;

    &#x2F;&#x2F;当队列不为空的时候继续搞
    while(!queue.isEmpty())&#123;
        int size &#x3D; queue.size();
        &#x2F;&#x2F;当队列长度大于0的时候
        while(size&gt;0)&#123;
            &#x2F;&#x2F;队列搞一个出来
           TreeNode tree&#x3D; queue.poll();
           &#x2F;&#x2F;当队列不为空  队列加入
            if(tree.left!&#x3D;null)&#123;
                queue.add(tree.left);
            &#125;
            &#x2F;&#x2F;当队列不为空 队列加入
            if(tree.right!&#x3D;null)&#123;
                queue.add(tree.right);
            &#125;
            &#x2F;&#x2F;队列递减
            size--;
        &#125;
        &#x2F;&#x2F;当走出一个循环的时候 深度会加1
        depth++;
    &#125;
    return depth;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>平衡二叉树</p>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p> </p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<pre><code>3
</code></pre>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>   1
  / \
 2   2
/ \
</code></pre>
<p>   3   3<br>  / <br> 4   4<br>返回 false 。</p>
<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        if(root&#x3D;&#x3D;null)&#123;
            return true;
        &#125;
        &#x2F;&#x2F; 
        &#x2F;&#x2F;左树的最大深度
        int left&#x3D;depth(root.left);
        &#x2F;&#x2F;右子树的最大深度
        int right&#x3D;depth(root.right);
        &#x2F;&#x2F;其实就是一直找 以这个根为节点的左右最大深度
        return Math.abs(left-right)&lt;&#x3D;1&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);
    &#125;

        &#x2F;&#x2F;这个功能主要是以某一个根为节点的最大深度
    public int depth(TreeNode root)&#123;
            if(root&#x3D;&#x3D;null)&#123;
                return 0;
            &#125;
            return Math.max(depth(root.left),depth(root.right))+1;
    &#125;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>求和路径</p>
<p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre>
<p>返回:</p>
<p>3<br>解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for a binary tree node.
 * public class TreeNode &#123;
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    List&lt;List&lt;Integer&gt;&gt; result&#x3D;new ArrayList&lt;&gt;();
    public int pathSum(TreeNode root, int sum) &#123;
        &#x2F;&#x2F;当根为空的时候 返回0
        if(root&#x3D;&#x3D;null)&#123;
            return 0;
        &#125;
        &#x2F;&#x2F;深度优先
        dfs(root,sum,new ArrayList()); 
        &#x2F;&#x2F;而且要递归根的左边和右边
        pathSum(root.left,sum);
        &#x2F;&#x2F;递归根的左边和右边
        pathSum(root.right,sum);
        return result.size();
    &#125;



    &#x2F;&#x2F;深度优先的套路 这个模型主要是用来解决路径的值等于某一个值的
    public void dfs(TreeNode root,int target,ArrayList list)&#123;
        &#x2F;&#x2F;如果为空返回
        if(root&#x3D;&#x3D;null)&#123;
            return;
        &#125;
        &#x2F;&#x2F;列表加入一个值
        list.add(root.val);   
        &#x2F;&#x2F;深度递归 将目标值改成目标值减去树的根值
        dfs(root.left,target-root.val,list);
        dfs(root.right,target-root.val,list);
        &#x2F;&#x2F;如果目标等于跟的值 那么这个结果加入列表
        if(target&#x3D;&#x3D;root.val)&#123;
            result.add(new ArrayList(list));
        &#125;
        &#x2F;&#x2F;将值减去1 达到一个回溯的效果
        list.remove(list.size()-1);
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head = [1], n = 1<br>输出：[]<br>示例 3：</p>
<p>输入：head = [1,2], n = 1<br>输出：[1]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode removeNthFromEnd(ListNode head, int n) &#123;
        &#x2F;&#x2F;基本的思路就是把链表转成数组 然后删掉倒数几个 然后再把数组还原回去
          ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();

         while(head!&#x3D;null)&#123;
             list.add(head.val);
             head&#x3D;head.next;
         &#125;

        list.remove(list.size()-n);           
        if(list.size()&lt;&#x3D;0)&#123;
            return null;
        &#125;        

        ListNode root&#x3D;new  ListNode(list.get(0));
        ListNode index&#x3D;root;
        for(int i&#x3D;1;i&lt;list.size();i++)&#123;
            System.out.print(list.get(i));
            ListNode  temp &#x3D;  new ListNode(list.get(i));
            index.next&#x3D;temp;
            index&#x3D;temp;
        &#125;
        return root;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>合并两个有序链表</p>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p> </p>
<p>示例 1：</p>
<p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p>
<p>输入：l1 = [], l2 = []<br>输出：[]<br>示例 3：</p>
<p>输入：l1 = [], l2 = [0]<br>输出：[0]</p>
<pre class="line-numbers language-none"><code class="language-none">
&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;
        &#x2F;&#x2F;如果list2 为空 返回list1
        if(list2&#x3D;&#x3D;null)&#123;
            return list1;
        &#125;
        &#x2F;&#x2F;如果list1为空返回list2
        if(list1&#x3D;&#x3D;null)&#123;
            return list2;
        &#125;
        &#x2F;&#x2F;搞两个数组存储
       ArrayList&lt;Integer&gt; arrayList1&#x3D; new ArrayList&lt;Integer&gt;();
       ArrayList&lt;Integer&gt; arrayList2&#x3D; new ArrayList&lt;Integer&gt;();
        &#x2F;&#x2F;当列表不为空的时候 装进去数组
        while(list1!&#x3D;null)&#123;
               arrayList1.add(list1.val);
               list1&#x3D;list1.next; 
        &#125;  
        &#x2F;&#x2F;当列表2不为空的时候装进去数组
        while(list2!&#x3D;null)&#123;
            arrayList2.add(list2.val);
            list2&#x3D;list2.next;
        &#125;

        int length&#x3D;arrayList1.size()+arrayList2.size();

        int[] arr&#x3D;new int[length];
        &#x2F;&#x2F;搞一个可以容纳这么多的数组
        for(int i&#x3D;0;i&lt;arrayList1.size();i++)&#123;
            arr[i]&#x3D;arrayList1.get(i);
        &#125;
        &#x2F;&#x2F;都装进去
        for(int i&#x3D;arrayList1.size();i&lt;(arrayList1.size()+arrayList2.size());i++)&#123;
            arr[i]&#x3D;arrayList2.get(i-arrayList1.size());
        &#125;
        &#x2F;&#x2F;对数组进行排序
        Arrays.sort(arr);

       ListNode root&#x3D; new ListNode(arr[0]);
       ListNode tempNode&#x3D;root;
        &#x2F;&#x2F;将 数组按列表复原
        for(int i&#x3D;1;i&lt;arr.length;i++)&#123;
        ListNode node&#x3D; new ListNode(arr[i]);
        tempNode.next&#x3D;node;
        tempNode&#x3D;node;
        &#125;
        return root;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>合并K个升序链表</p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p>
<p>输入：lists = []<br>输出：[]<br>示例 3：</p>
<p>输入：lists = [[]]<br>输出：[]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    &#x2F;&#x2F;思路还是将 链表转成了所有数组 然后组装回去一个链表
    public ListNode mergeKLists(ListNode[] lists) &#123;
        if(lists&#x3D;&#x3D;null||lists.length&#x3D;&#x3D;0||(lists.length&#x3D;&#x3D;1&amp;&amp;lists[0]&#x3D;&#x3D;null))&#123;
            return null;
        &#125;
      ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();
      for(int i&#x3D;0;i&lt;lists.length;i++)&#123;
        ListNode node&#x3D;  lists[i];
        while(node!&#x3D;null)&#123;
            list.add(node.val);
            node&#x3D;node.next;
        &#125;
      &#125;
        int length&#x3D;list.size();
        if(length&lt;&#x3D;0)&#123;
            return null;
        &#125;

        int[] arr &#x3D; new int[length];

        for(int i&#x3D;0;i&lt;list.size();i++)&#123;
            arr[i]&#x3D;list.get(i);
        &#125;
        Arrays.sort(arr);

   

      ListNode root&#x3D; new ListNode(arr[0]);
      ListNode index&#x3D;root;


      for(int i&#x3D;1;i&lt;arr.length;i++)&#123;
          System.out.print(arr[i]);
         ListNode node&#x3D; new ListNode(arr[i]);
         index.next&#x3D;node;
         index&#x3D;node;
      &#125;


        return root;

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>删除排序链表中的重复元素 II</p>
<p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head = [1,2,3,3,4,4,5]<br>输出：[1,2,5]<br>示例 2：</p>
<p>输入：head = [1,1,1,2,3]<br>输出：[2,3]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode deleteDuplicates(ListNode head) &#123;

        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null)&#123;
            return head;
        &#125;

        HashMap&lt;Integer,Integer&gt; map&#x3D; new HashMap&lt;Integer,Integer&gt;();
        ArrayList&lt;Integer&gt;  list&#x3D; new ArrayList&lt;&gt;();

        while(head!&#x3D;null)&#123;
            if(!list.contains(head.val))&#123;
                list.add(head.val);
            &#125;

            if(map.get(head.val)&#x3D;&#x3D;null)&#123;
                map.put(head.val,1);
            &#125;else&#123;
                map.put(head.val,map.get(head.val)+1);
            &#125;
            head&#x3D;head.next;
        &#125;


        &#x2F;&#x2F; for(int i&#x3D;0;i&lt;list.size();i++)&#123;
        &#x2F;&#x2F;     System.out.print(list.get(i));
        &#x2F;&#x2F;     System.out.print(map.get(list.get(i)));
        &#x2F;&#x2F; &#125;
        ListNode result&#x3D;null;
        ListNode index&#x3D;null;

        for(int i&#x3D;0;i&lt;list.size();i++)&#123;
             if(map.get(list.get(i))&#x3D;&#x3D;1)&#123;
                if(result&#x3D;&#x3D;null)&#123;
                    result&#x3D; new ListNode(list.get(i));
                    index&#x3D;result;
                &#125;else&#123;
                    System.out.print(list.get(i));
                     ListNode temp&#x3D; new ListNode(list.get(i));
                     index.next&#x3D;temp;
                     index&#x3D;index.next;
                &#125;             
             &#125;
        &#125;
        &#x2F;&#x2F;暂时没有时间看看
        return result;

    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>删除排序链表中的重复元素</p>
<p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head = [1,1,2]<br>输出：[1,2]<br>示例 2：</p>
<p>输入：head = [1,1,2,3,3]<br>输出：[1,2,3]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
     public ListNode deleteDuplicates(ListNode head) &#123;
        if(head&#x3D;&#x3D;null)&#123;
            return null;
        &#125;
        &#x2F;&#x2F;当node不为空的时候就会往下移动，但是只有当下一个不等于当前这个的时候才会移动
           ListNode temp&#x3D;head;
           while(temp!&#x3D;null)&#123;
               if(temp.next!&#x3D;null)&#123;
                   if(temp.val&#x3D;&#x3D;temp.next.val)&#123;
                       temp.next&#x3D;temp.next.next;
                   &#125;
               &#125;
               if(temp.next&#x3D;&#x3D;null||temp.next.val!&#x3D;temp.val)&#123;
                    temp&#x3D;temp.next;
               &#125;                                   
           &#125;
        return head;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>反转链表 II</p>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
 </p>
<p>示例 1：</p>
<p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]<br>示例 2：</p>
<p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode reverseBetween(ListNode head, int left, int right) &#123;

        ArrayList&lt;Integer&gt; list&#x3D;new ArrayList&lt;Integer&gt;();
        ListNode temp&#x3D;head;

        while(temp!&#x3D;null)&#123;
            list.add(temp.val);
            temp&#x3D;temp.next;
        &#125;

        int[] arr&#x3D;new int[list.size()];

       for(int i&#x3D;0;i&lt;list.size();i++)&#123;
            arr[i]&#x3D;list.get(i);
        &#125;


 
      

       for(int i&#x3D;0;i&lt;(right-left+1)&#x2F;2;i++)&#123;
          int tempValue&#x3D;arr[left+i-1];
          arr[left+i-1]&#x3D;arr[right-i-1];
          arr[right-i-1]&#x3D;tempValue;
       &#125;

        for(int i&#x3D;0;i&lt;list.size();i++)&#123;
             System.out.print(arr[i]);
        &#125;
       

        ListNode result&#x3D;null;
        ListNode index&#x3D;null;

        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;
                if(result&#x3D;&#x3D;null)&#123;
                    result&#x3D; new ListNode(arr[i]);
                    index&#x3D;result;
                &#125;else&#123;
                    index.next&#x3D;new ListNode(arr[i]);
                    index&#x3D;index.next;
                &#125;
        &#125;
        &#x2F;&#x2F;没有看懂
       



        return result;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>环形链表</p>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123;
 *         val &#x3D; x;
 *         next &#x3D; null;
 *     &#125;
 * &#125;
 *&#x2F;
public class Solution &#123;
    public boolean hasCycle(ListNode head) &#123;
      &#x2F;&#x2F;如果为空那就返回
      if(head&#x3D;&#x3D;null)&#123;
          return false;
      &#125;
     ListNode temp;
     &#x2F;&#x2F;将链表放在中间
      temp&#x3D;head;
      &#x2F;&#x2F;搞两个中间件
      ListNode temp1&#x3D;temp;
      ListNode temp2&#x3D;temp;
      &#x2F;&#x2F;当这个不为空或者下一个不为空
      while(temp2!&#x3D;null&amp;&amp;temp2.next!&#x3D;null)&#123;
          temp1&#x3D;temp1.next;
          temp2&#x3D;temp2.next.next;
          &#x2F;&#x2F;如果是环形的话他们就一定会重复 如果不是环形的 那么跑一次就没有了
          if(temp1&#x3D;&#x3D;temp2)&#123;
              return true;
          &#125;
      &#125;
      return  false;
    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>LRU 缓存</p>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p> </p>
<p>示例：</p>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p>
<p>解释<br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p>
<pre class="line-numbers language-none"><code class="language-none">
class LRUCache &#123;
    &#x2F;&#x2F;要搞这个LUR需要搞一个map加一个双向链表
    private int capacity;
    &#x2F;&#x2F;容量大小
    private int size &#x3D; 0;
    &#x2F;&#x2F;map
    private Map&lt;Integer, Entry&gt; cache &#x3D; new HashMap&lt;Integer, Entry&gt;();
    &#x2F;&#x2F;这个是双向链表的头和尾
    private Entry head, tail;

    public LRUCache(int capacity) &#123;
        this.capacity &#x3D; capacity;
        this.size &#x3D; 0;
        head &#x3D; new Entry();
        tail &#x3D; new Entry();
        head.next &#x3D; tail;
        tail.prev &#x3D; head;
    &#125;
&#x2F;&#x2F;  获取的时候从map取出来 发现为空就返回 不为空就插入到头那边
    public int get(int key) &#123;
        Entry node &#x3D; cache.get(key);
        if (node &#x3D;&#x3D; null) &#123;
            return -1;
        &#125;
        moveToHead(node);
        return node.value;
    &#125;

    &#x2F;&#x2F;插入到头那边就是先从尾巴删掉 然后加入到头那边
    private void moveToHead(Entry node) &#123;
        removeNode(node);
        addToHead(node);
    &#125;
    &#x2F;&#x2F;加入到头那边  添加节点就是 这个节点的前一个为头，节点的下一个是头的下一个  头的前一个为这个  头的下一个为这个
    private void addToHead(Entry node) &#123;
        node.prev &#x3D; head;
        node.next &#x3D; head.next;
        head.next.prev &#x3D; node;
        head.next &#x3D; node;
    &#125;
    &#x2F;&#x2F;删除这个节点   删除节点就是 这个节点的前面的下一个变成这的下一个    这个节点的下一个的前一个变成节点的前一个
    private void removeNode(Entry node) &#123;
        node.prev.next &#x3D; node.next;
        node.next.prev &#x3D; node.prev;
    &#125;

    &#x2F;&#x2F;放进去的话 从map拿出来 如果存在就刷新  如果不存在的话 就加入 加入的时候如果发现已经超过了最大的话那么就删掉最后一个
    public void put(int key, int value) &#123;
        Entry node &#x3D; cache.get(key);
        if (node &#x3D;&#x3D; null) &#123;
            &#x2F;&#x2F; 如果 key 不存在，创建一个新的节点
            Entry newNode &#x3D; new Entry(key, value);
            &#x2F;&#x2F; 添加进哈希表
            cache.put(key, newNode);
            &#x2F;&#x2F; 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size &gt; capacity) &#123;
                &#x2F;&#x2F; 如果超出容量，删除双向链表的尾部节点
                Entry tail &#x3D; removeTail();
                &#x2F;&#x2F; 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            &#125;
        &#125; else &#123;
            &#x2F;&#x2F; 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value &#x3D; value;
            moveToHead(node);
        &#125;
    &#125;
    &#x2F;&#x2F;删掉最后一个就是双向链表的尾结点的前一个
    private Entry removeTail() &#123;
        Entry res &#x3D; tail.prev;
        removeNode(res);
        return res;
    &#125;


    class Entry &#123;
        int key;
        int value;

        Entry prev;
        Entry next;

        public Entry(int key, int value) &#123;
            this.key &#x3D; key;
            this.value &#x3D; value;
        &#125;

        public Entry() &#123;

        &#125;

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>排序链表</p>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head = [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p>
<p>输入：head = [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p>
<p>输入：head = []<br>输出：[]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode sortList(ListNode head) &#123;
        if(head&#x3D;&#x3D;null)&#123;
            return null; 
            &#125;
    &#x2F;&#x2F;这个思路是把链表搞成数组 然后数组排序 然后再组装成链表
      ArrayList&lt;Integer&gt; list&#x3D;  new ArrayList&lt;Integer&gt;();

         while(head!&#x3D;null)&#123;
             list.add(head.val);
             head&#x3D;head.next;
           &#125;

            int[] arr&#x3D; new  int[list.size()];
           
           for(int i&#x3D;0;i&lt;list.size();i++)&#123;
              arr[i]&#x3D;list.get(i);  
           &#125;
           
           Arrays.sort(arr);
        ListNode root&#x3D;new ListNode(arr[0]);
        ListNode index&#x3D;root;

        for(int i&#x3D;1;i&lt;arr.length;i++)&#123;
            System.out.print(arr[i]);

             ListNode node&#x3D;   new ListNode(arr[i]);
             index.next&#x3D;node;
             index&#x3D;node;
        &#125;

        return root;

    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>奇偶链表</p>
<p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>
<p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>
<p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: head = [1,2,3,4,5]<br>输出: [1,3,5,2,4]<br>示例 2:</p>
<p>输入: head = [2,1,3,5,6,4,7]<br>输出: [2,3,6,7,1,5,4]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode oddEvenList(ListNode head) &#123;
        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null)&#123;
            return head;
        &#125;

        ListNode l1&#x3D;new ListNode(0);
        ListNode l2&#x3D;new ListNode(0);
        ListNode tempHead&#x3D;head;
        ListNode temp1&#x3D;l1;
        ListNode temp2&#x3D;l2;
        boolean isOdd&#x3D;true;
        
        while(tempHead!&#x3D;null)&#123;
        if(isOdd)&#123;
                l1.next&#x3D;tempHead;
                l1&#x3D;l1.next;
            &#125;else&#123;
                l2.next&#x3D;tempHead;
                l2&#x3D;l2.next;
            &#125; 
            isOdd&#x3D;!isOdd;
            tempHead&#x3D;tempHead.next;
        &#125;
           if(l1.next!&#x3D;null)&#123;
                l1.next&#x3D;null;
            &#125;
            if(l2.next!&#x3D;null)&#123;
                l2.next&#x3D;null;
            &#125;
            l1.next&#x3D;temp2.next;
            return temp1.next;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>两数相加 II</p>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p> </p>
<p>示例1：</p>
<p>输入：l1 = [7,2,4,3], l2 = [5,6,4]<br>输出：[7,8,0,7]<br>示例2：</p>
<p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[8,0,7]<br>示例3：</p>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;
        &#x2F;&#x2F;搞两个栈来存储 因为刚好满足这个特性
         Stack&lt;Integer&gt;  stack1&#x3D;    new Stack&lt;Integer&gt;();
            Stack&lt;Integer&gt;  stack2&#x3D;    new Stack&lt;Integer&gt;();
            while(l1!&#x3D;null)&#123;
                stack1.push(l1.val);
                l1&#x3D;l1.next;
            &#125;

            while(l2!&#x3D;null)&#123;
                stack2.push(l2.val);
                l2&#x3D;l2.next;
            &#125;
            &#x2F;&#x2F;进位的标志
            int carry&#x3D;0;
            &#x2F;&#x2F;根
            ListNode head&#x3D;null;

            while(!stack1.isEmpty()||!stack2.isEmpty()||carry&gt;0)&#123;
                &#x2F;&#x2F;进位的
                int sum&#x3D;carry;
                &#x2F;&#x2F;从栈弹一个出来
                sum+&#x3D;stack1.isEmpty()?0:stack1.pop();
                &#x2F;&#x2F;从栈弹一个出来
                sum+&#x3D; stack2.isEmpty()?0:stack2.pop();
                &#x2F;&#x2F;只取一位
                 ListNode node&#x3D;new ListNode(sum%10);
                 &#x2F;&#x2F;下一位指向头
                 node.next&#x3D;head;
                 &#x2F;&#x2F;下一个
                 head&#x3D;node;
                 &#x2F;&#x2F;除以时
                 carry&#x3D;sum&#x2F;10;
            &#125;
                &#x2F;&#x2F;返回这个头
                return head;
    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>链表中倒数第k个节点</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode getKthFromEnd(ListNode head, int k) &#123;
    &#x2F;&#x2F;先把链表放到列表中
      ArrayList&lt;ListNode&gt; list&#x3D;  new ArrayList&lt;ListNode&gt;();
      while(head!&#x3D;null)&#123;
          list.add(head);
          head&#x3D;head.next;
      &#125;
      &#x2F;&#x2F;然后从列表中拿出倒数第几个元素
     return  list.get(list.size()-k);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>反转链表</p>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p> </p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123; val &#x3D; x; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
    if(head&#x3D;&#x3D;null)&#123;
        return head;
    &#125;
    &#x2F;&#x2F;先搞一个列表 将链表按值放进去
     ArrayList&lt;Integer&gt; list&#x3D; new ArrayList&lt;Integer&gt;();
        while(head!&#x3D;null)&#123;
            list.add(head.val);
            head&#x3D;head.next;
        &#125;
        &#x2F;&#x2F;对列表进行排序
        Collections.reverse(list);
        &#x2F;&#x2F; 把列表按链表的方式排序回来
       ListNode root&#x3D; new ListNode(list.get(0));
       ListNode index&#x3D;root;
        for(int i&#x3D;1;i&lt;list.size();i++)&#123;
            int temp&#x3D;list.get(i);
            ListNode tree &#x3D;new ListNode(temp);
            index.next&#x3D;tree;
            index&#x3D;tree;
        &#125;
        return root;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表：</p>
<p>在节点 c1 开始相交。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 </p>
<p>示例 2：</p>
<p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
 </p>
<p>示例 3：</p>
<p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123;
 *         val &#x3D; x;
 *         next &#x3D; null;
 *     &#125;
 * &#125;
 *&#x2F;
public class Solution &#123;
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
        &#x2F;&#x2F;链表a 链表b
            ListNode  headATemp&#x3D;headA;
            ListNode  headBTemp&#x3D;headB;
            &#x2F;&#x2F;当A 不为空的时候 取出一个A 遍历b 如果遍历到的了话 那么就返回回去
            while(headATemp!&#x3D;null)&#123;
                    while(headBTemp!&#x3D;null)&#123;
                        if(headATemp&#x3D;&#x3D;headBTemp)&#123;
                            return headATemp;
                        &#125;
                        headBTemp&#x3D;headBTemp.next;
                    &#125;

                    headBTemp&#x3D;headB;

                headATemp&#x3D;headATemp.next;
            &#125;

            return null;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>链表中环的入口节点</p>
<p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123;
 *         val &#x3D; x;
 *         next &#x3D; null;
 *     &#125;
 * &#125;
 *&#x2F;
public class Solution &#123;
       public ListNode detectCycle(ListNode head) &#123;
        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null)&#123;
            return null;
        &#125;

        ListNode fastNode&#x3D;head;
        ListNode slowNode&#x3D;head;

        while(fastNode !&#x3D; null &amp;&amp; fastNode.next !&#x3D; null)&#123;
            fastNode&#x3D;fastNode.next.next;
            slowNode&#x3D;slowNode.next;
            if(fastNode&#x3D;&#x3D;slowNode)&#123;
                 fastNode &#x3D; head;
                while(slowNode !&#x3D; fastNode)&#123;
                    slowNode &#x3D; slowNode.next;
                    fastNode &#x3D; fastNode.next;
                &#125;
                return slowNode;
            &#125;
         
      
        &#125;
        &#x2F;&#x2F;环在第一个

        return null;

        
    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<p>回文链表</p>
<p>给定一个链表的 头节点 head ，请判断其是否为回文链表。</p>
<p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: head = [1,2,3,3,2,1]<br>输出: true<br>示例 2：</p>
<p>输入: head = [1,2]<br>输出: false</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val &#x3D; val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val &#x3D; val; this.next &#x3D; next; &#125;
 * &#125;
 *&#x2F;
class Solution &#123;
    public boolean isPalindrome(ListNode head) &#123;
        &#x2F;&#x2F;如果列表为空 返回false
        if(head&#x3D;&#x3D;null)&#123;
            return false;
        &#125;
        &#x2F;&#x2F;搞一个列表长度
        ArrayList&lt;ListNode&gt; arr&#x3D;new ArrayList&lt;ListNode&gt;();
        &#x2F;&#x2F;把链表搞成列表
        while(head!&#x3D;null)&#123;
            arr.add(head);
            head&#x3D;head.next;
        &#125;

        &#x2F;&#x2F;看一下列表是不是一个回文树
        for(int i&#x3D;0;i&lt;arr.size()&#x2F;2;i++)&#123;
            if(arr.get(i).val!&#x3D;arr.get(arr.size()-1-i).val)&#123;
                    return false;
            &#125;
        &#125;
        return true;

    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>整数反转</p>
<p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。
 </p>
<p>示例 1：</p>
<p>输入：x = 123<br>输出：321<br>示例 2：</p>
<p>输入：x = -123<br>输出：-321<br>示例 3：</p>
<p>输入：x = 120<br>输出：21<br>示例 4：</p>
<p>输入：x = 0<br>输出：0</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int reverse(int x) &#123;
        if(x&#x3D;&#x3D;0)&#123;
            return 0;
        &#125;
        &#x2F;&#x2F;这个flag是用来标志负
        boolean flag&#x3D;false;
        &#x2F;&#x2F;如果小于0 就取反 标记这个负
        if(x&lt;0)&#123;
            flag&#x3D;true;
            x&#x3D;-x;
        &#125;
        &#x2F;&#x2F;搞一个列表
        ArrayList&lt;Integer&gt; list&#x3D; new ArrayList&lt;Integer&gt;();
        &#x2F;&#x2F;把数字切割然后放到列表
            while(x&gt;0)&#123;
                int last&#x3D;x%10;
                list.add(last);    
                x&#x3D;x&#x2F;10;
            &#125;
            &#x2F;&#x2F;把列表还原 主要要判断如果大小大于integer 的最大值 那么久返回0
            long result&#x3D;0;
            for(int i&#x3D;0;i&lt;list.size();i++)&#123;
                   if(result*10+list.get(i)&gt;Integer.MAX_VALUE)&#123;
                       return 0;
                   &#125;else&#123;
                      result&#x3D;result*10+list.get(i); 

                   &#125;
            &#125;
            if(flag)&#123;
                result&#x3D;-result;
            &#125;

        return (int)result;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>回文数</p>
<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x = 121<br>输出：true<br>示例 2：</p>
<p>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3：</p>
<p>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。<br>示例 4：</p>
<p>输入：x = -101<br>输出：false</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public boolean isPalindrome(int x) &#123;
        &#x2F;&#x2F;如果数值小于0那么返回false
        if(x&lt;0)&#123;
            return false;
        &#125;

        &#x2F;&#x2F;搞个列表
      ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();
        &#x2F;&#x2F;当数值大于0的时候 取余10  然后加入列表 然后除以10
      while(x&gt;0)&#123;
          int last&#x3D;x%10;
          list.add(last);
          x&#x3D;x&#x2F;10;
      &#125;
        &#x2F;&#x2F;然后就直接对比
      for(int i&#x3D;0;i&lt;list.size()&#x2F;2;i++)&#123;
          if(list.get(i)!&#x3D;list.get(list.size()-1-i))&#123;
              return false;
          &#125;
      &#125;
    return true;
    &#125;
&#125;




<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p> x 的平方根 </p>
<p> 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x = 4<br>输出：2<br>示例 2：</p>
<p>输入：x = 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int mySqrt(int x) &#123;
        &#x2F;&#x2F;二分查找的思路  
        &#x2F;&#x2F;左边
        int left&#x3D;0;
        &#x2F;&#x2F;右边
        int right&#x3D;x;
        &#x2F;&#x2F;用来返回结果
        int index&#x3D;0;
        &#x2F;&#x2F;当左边小于右边的时候
        while(left&lt;&#x3D;right)&#123;
            &#x2F;&#x2F;获取中间的那一个
            int mid&#x3D;left+(right-left)&#x2F;2;
            &#x2F;&#x2F;中间的数平方 如果小于 从中间的左边算起 如果大于从中间右边算起
            if((long)mid*mid&lt;&#x3D;x)&#123;
                index&#x3D;mid;
                left&#x3D;mid+1;
            &#125;else&#123;
                right&#x3D;mid-1;
            &#125;
        &#125;
        &#x2F;&#x2F;返回下标
        return index;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>阶乘后的零</p>
<p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p>
<p>提示 n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 3<br>输出：0<br>解释：3! = 6 ，不含尾随 0<br>示例 2：</p>
<p>输入：n = 5<br>输出：1<br>解释：5! = 120 ，有一个尾随 0<br>示例 3：</p>
<p>输入：n = 0<br>输出：0</p>
<pre class="line-numbers language-none"><code class="language-none">

class Solution &#123;
    public int trailingZeroes(int n) &#123;

        &#x2F;&#x2F;其实就是算5的个数
             int zoreCount&#x3D;0;
         while(n &gt;&#x3D; 5) &#123;
            zoreCount +&#x3D; n &#x2F; 5;
            n &#x2F;&#x3D; 5;
          &#125;

        return zoreCount;
    
    
    &#125;

 
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>K 进制表示下的各位数字总和</p>
<p>给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。</p>
<p>转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 34, k = 6<br>输出：9<br>解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。<br>示例 2：</p>
<p>输入：n = 10, k = 10<br>输出：1<br>解释：n 本身就是 10 进制。 1 + 0 = 1 。</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int sumBase(int n, int k) &#123;
        &#x2F;&#x2F;搞一个结果
            int result&#x3D;0;
            &#x2F;&#x2F;当n不等于0的时候
            while(n!&#x3D;0)&#123;
                &#x2F;&#x2F;结果等于结果加上n 余上k进制
                result&#x3D;result+(n%k);
                &#x2F;&#x2F;这个数出于k
                n&#x3D;n&#x2F;k;
            &#125;

            return result;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>用两个栈实现队列</p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p> </p>
<p>示例 1：</p>
<p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p>
<p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p>
<pre class="line-numbers language-none"><code class="language-none">
class CQueue &#123;
    &#x2F;&#x2F;用两个栈来实现一个队列 就是先把栈的数据导出来 然后 弹出一个 然后在倒回去
      Stack&lt;Integer&gt; firstStack&#x3D; new Stack&lt;Integer&gt;();
        Stack&lt;Integer&gt; secondStack&#x3D; new Stack&lt;Integer&gt;();


    public CQueue() &#123;

    &#125;
    
    public void appendTail(int value) &#123;
            firstStack.push(value);
    &#125;
    
    public int deleteHead() &#123;
        if(firstStack.isEmpty())&#123;
            return -1;
        &#125;
        while(!firstStack.isEmpty())&#123;
            int value&#x3D; firstStack.pop();
            secondStack.push(value);
        &#125;
        int temp&#x3D;secondStack.pop();
        while(!secondStack.isEmpty())&#123;
            int value&#x3D;secondStack.pop();
            firstStack.push(value);
        &#125;
        return temp;
    &#125;
&#125;

&#x2F;**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj &#x3D; new CQueue();
 * obj.appendTail(value);
 * int param_2 &#x3D; obj.deleteHead();
 *&#x2F;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>斐波那契数列</p>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：1<br>示例 2：</p>
<p>输入：n = 5<br>输出：5</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int fib(int n) &#123;
        &#x2F;&#x2F;用一个数组来进行递归添加
        if(n&#x3D;&#x3D;0)&#123;
            return 0;
        &#125;
        if(n&#x3D;&#x3D;1)&#123;
            return 1;
        &#125;
        int[] arr&#x3D;new int[n+1];
        arr[0]&#x3D;0;
        arr[1]&#x3D;1;
        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;
            arr[i]&#x3D;(arr[i-1]+arr[i-2])%1000000007;
        &#125;
        return arr[n];
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>青蛙跳台阶问题</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：2<br>示例 2：</p>
<p>输入：n = 7<br>输出：21<br>示例 3：</p>
<p>输入：n = 0<br>输出：1</p>
<pre class="line-numbers language-none"><code class="language-none">
class Solution &#123;
    public int numWays(int n) &#123;
        &#x2F;&#x2F;如果n小于等于1那么返回1
     if(n&lt;&#x3D;1)&#123;
            return 1;
        &#125;
        &#x2F;&#x2F;搞个数组加1
         int[] arr&#x3D;new int[n+1];
         &#x2F;&#x2F;数组  最终长度为 arr[i]&#x3D;arr[i-1]+arr[i-2]
        arr[0]&#x3D;1;
        arr[1]&#x3D;2; 
         for(int i&#x3D;2;i&lt;n;i++)&#123;
             arr[i]&#x3D;(arr[i-1]+arr[i-2])%1000000007;
         &#125;

         return arr[n-1];
    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p> 二进制中1的个数<br>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>
<p>示例 1：</p>
<p>输入：n = 11 (控制台输入 00000000000000000000000000001011)<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>示例 2：</p>
<p>输入：n = 128 (控制台输入 00000000000000000000000010000000)<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>示例 3：</p>
<p>输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p>
<pre class="line-numbers language-none"><code class="language-none">
public class Solution &#123;
    &#x2F;&#x2F; you need to treat n as an unsigned value
    public int hammingWeight(int n) &#123;
        &#x2F;&#x2F;这个就是拿1 进行不断的左移 然后匹配到了就加1
        int count&#x3D;0;
       int flag&#x3D;1;
       while(flag!&#x3D;0)&#123;
           if((n&amp;flag)!&#x3D;0)&#123;
               count++;
           &#125;
           flag&lt;&lt;&#x3D;1;
       &#125;
       return count;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>求平方根</p>
<p>给定一个非负整数 x ，计算并返回 x 的平方根，即实现 int sqrt(int x) 函数。</p>
<p>正数的平方根有两个，只输出其中的正数平方根。</p>
<p>如果平方根不是整数，输出只保留整数的部分，小数部分将被舍去。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: x = 4<br>输出: 2<br>示例 2:</p>
<p>输入: x = 8<br>输出: 2<br>解释: 8 的平方根是 2.82842…，由于小数部分将被舍去，所以返回 2</p>
<pre class="line-numbers language-none"><code class="language-none">class Solution &#123;
    public int mySqrt(int x) &#123;
        &#x2F;&#x2F;这个题用二分法然后接近结果
        int  left&#x3D;0;
        int  right&#x3D;x;
        int result&#x3D;0;

        while(left&lt;&#x3D;right)&#123;
            int mid&#x3D;(left+(right-left)&#x2F;2);
                if((long)mid*mid&lt;&#x3D;x)&#123;
                    result&#x3D;mid;
                    left&#x3D;mid+1;
                &#125;else&#123;
                    right&#x3D;mid-1;
                &#125;
            
            &#125;
        return result;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>栈的最小值</p>
<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<p>示例：</p>
<p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p>
<pre class="line-numbers language-none"><code class="language-none">class MinStack &#123;

    &#x2F;** initialize your data structure here. *&#x2F;
    &#x2F;&#x2F;搞两个栈 一个放最小值 一个放正常值  每次放正常值的时候会先把最小值拿出来 然后比较一下 一起同步塞一个最小值进去
    Stack&lt;Integer&gt; stack&#x3D; new Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; minStack&#x3D; new Stack&lt;Integer&gt;();

    public MinStack() &#123;

    &#125;
    
    public void push(int x) &#123;
        stack.push(x);
        if(minStack.size()&gt;0)&#123;
         int min&#x3D;minStack.peek();
         min&#x3D;Math.min(min,x);
         minStack.push(min);
        &#125;else&#123;
            minStack.push(x);
        &#125;

    &#125;
    
    public void pop() &#123;
        stack.pop();
        minStack.pop();
    &#125;
    
    public int top() &#123;
        return stack.peek();   
    &#125;
    
    public int getMin() &#123;
       return minStack.peek(); 
    &#125;
&#125;

&#x2F;**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj &#x3D; new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 &#x3D; obj.top();
 * int param_4 &#x3D; obj.getMin();
 *&#x2F;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">算法</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/10/04/%E7%AE%97%E6%B3%95/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="常用算法规整">
                        
                        <span class="card-title">常用算法规整</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-10-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-category">
                                    算法总结
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/08/01/MVVM%20%E4%B8%8EJetpack%E7%BB%93%E5%90%88/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="MVVM与JetPacket结合">
                        
                        <span class="card-title">MVVM与JetPacket结合</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9E%B6%E6%9E%84/" class="post-category">
                                    架构
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/">
                        <span class="chip bg-color">日常积累</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="6686195202"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2018-2022</span>
            
            <span id="year">2018</span>
            <a href="/about" target="_blank">Vinda</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/mvinda" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:820703048@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=820703048" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 820703048" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
