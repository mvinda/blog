<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="源码阅读-EventBus, Vinda">
    <meta name="description" content="慢就是快,快就是慢">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>源码阅读-EventBus | Vinda</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Vinda" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Vinda</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Vinda</div>
        <div class="logo-desc">
            
            慢就是快,快就是慢
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/mvinda" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/mvinda" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">源码阅读-EventBus</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">
                                <span class="chip bg-color">源码阅读</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" class="post-category">
                                源码阅读
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-03-08
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>EventBus作为一款事件发布的第三方开源框架，几乎是每个项目都会使用到，使用它可以对Fragment和Fragment之间 Activity和Activity之间，不同组件之间信息交互变得便捷，减少耦合性上有非常显著的效果，为了搞清楚EventBus 这个Android开发中国民级的开源组件源码，我们来看一下源码是怎么写的</p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><pre class="line-numbers language-none"><code class="language-none">implementation &#39;org.greenrobot:eventbus:3.0.0&#39;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在回调方法中加入注册和反注册功能，然后在方法中加入注解</p>
<pre class="line-numbers language-none"><code class="language-none">@Override
  protected void onStart() &#123;
      super.onStart();
      EventBus.getDefault().register(this);
  &#125;


  @Override
  protected void onStop() &#123;
      super.onStop();
      EventBus.getDefault().unregister(this);
  &#125;


  @Subscribe(threadMode &#x3D; ThreadMode.MAIN)
  public void onmessage(MyBusEvent event) &#123;
        Toast.makeText(this, event, Toast.LENGTH_SHORT).show();
  &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>最后一步就是在任意地方发送一个广播</p>
<pre class="line-numbers language-none"><code class="language-none">public void postEvent() &#123;
        EventBus.getDefault().post(new MyBusEvent(&quot;hhh&quot;));
    &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>我们先看第一句 EventBus.getDefault()到底做了什么</p>
<pre class="line-numbers language-none"><code class="language-none">public static EventBus getDefault() &#123;
        if (defaultInstance &#x3D;&#x3D; null) &#123;
            synchronized (EventBus.class) &#123;
                if (defaultInstance &#x3D;&#x3D; null) &#123;
                    defaultInstance &#x3D; new EventBus();
                &#125;
            &#125;
        &#125;
        return defaultInstance;
    &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>非常明显是做了一个双层锁的单例模式我们来看一下new EventBus构造方法</p>
<pre class="line-numbers language-none"><code class="language-none">public EventBus() &#123;
       this(DEFAULT_BUILDER);
   &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">
private static final EventBusBuilder DEFAULT_BUILDER &#x3D; new EventBusBuilder();

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>调用了一个参数的构造方法传入了一个变量这这个变量就是它EventBusBuilder 所以其实是一个建造者模式，我们看一下EventBusBuilder和传参数的构造方法</p>
<pre class="line-numbers language-none"><code class="language-none"> 
EventBus(EventBusBuilder builder) &#123;
      subscriptionsByEventType &#x3D; new HashMap&lt;&gt;();
      typesBySubscriber &#x3D; new HashMap&lt;&gt;();
      stickyEvents &#x3D; new ConcurrentHashMap&lt;&gt;();
      mainThreadPoster &#x3D; new HandlerPoster(this, Looper.getMainLooper(), 10);
      backgroundPoster &#x3D; new BackgroundPoster(this);
      asyncPoster &#x3D; new AsyncPoster(this);
      indexCount &#x3D; builder.subscriberInfoIndexes !&#x3D; null ? builder.subscriberInfoIndexes.size() : 0;
      subscriberMethodFinder &#x3D; new SubscriberMethodFinder(builder.subscriberInfoIndexes,
              builder.strictMethodVerification, builder.ignoreGeneratedIndex);
      logSubscriberExceptions &#x3D; builder.logSubscriberExceptions;
      logNoSubscriberMessages &#x3D; builder.logNoSubscriberMessages;
      sendSubscriberExceptionEvent &#x3D; builder.sendSubscriberExceptionEvent;
      sendNoSubscriberEvent &#x3D; builder.sendNoSubscriberEvent;
      throwSubscriberException &#x3D; builder.throwSubscriberException;
      eventInheritance &#x3D; builder.eventInheritance;
      executorService &#x3D; builder.executorService;
  &#125;

  
  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到做了很多的初始化操作subscriptionsByEventType 这个是以发送的对象为key subscrption为value的一个hashmap typesBySubscriber这个是一个以subscrption为key发送对象为value的一个hashmap<br>stickyEvents 是一个粘性事件 map<br>HandlerPoster是一个继承Handler的调度器 我们有必要看一下这个类的代码</p>
<pre class="line-numbers language-none"><code class="language-none">
final class HandlerPoster extends Handler &#123;

    private final PendingPostQueue queue;
    private final int maxMillisInsideHandleMessage;
    private final EventBus eventBus;
    private boolean handlerActive;

    HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123;
        super(looper);
        this.eventBus &#x3D; eventBus;
        this.maxMillisInsideHandleMessage &#x3D; maxMillisInsideHandleMessage;
        queue &#x3D; new PendingPostQueue();
    &#125;

    void enqueue(Subscription subscription, Object event) &#123;
        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);
        synchronized (this) &#123;
            queue.enqueue(pendingPost);
            if (!handlerActive) &#123;
                handlerActive &#x3D; true;
                if (!sendMessage(obtainMessage())) &#123;
                    throw new EventBusException(&quot;Could not send handler message&quot;);
                &#125;
            &#125;
        &#125;
    &#125;

    @Override
    public void handleMessage(Message msg) &#123;
        boolean rescheduled &#x3D; false;
        try &#123;
            long started &#x3D; SystemClock.uptimeMillis();
            while (true) &#123;
                PendingPost pendingPost &#x3D; queue.poll();
                if (pendingPost &#x3D;&#x3D; null) &#123;
                    synchronized (this) &#123;
                        &#x2F;&#x2F; Check again, this time in synchronized
                        pendingPost &#x3D; queue.poll();
                        if (pendingPost &#x3D;&#x3D; null) &#123;
                            handlerActive &#x3D; false;
                            return;
                        &#125;
                    &#125;
                &#125;
                eventBus.invokeSubscriber(pendingPost);
                long timeInMethod &#x3D; SystemClock.uptimeMillis() - started;
                if (timeInMethod &gt;&#x3D; maxMillisInsideHandleMessage) &#123;
                    if (!sendMessage(obtainMessage())) &#123;
                        throw new EventBusException(&quot;Could not send handler message&quot;);
                    &#125;
                    rescheduled &#x3D; true;
                    return;
                &#125;
            &#125;
        &#125; finally &#123;
            handlerActive &#x3D; rescheduled;
        &#125;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>我们可以看到PendingPostQueue是一个即将发送的消息队列，handlerActive是这个eventBus有没有运行起来，我们看一下他的handleMessage方法 ，其实就是从队列中拿到一个即将发送的消息，然后就是调用invokeSubscriber方法</p>
<pre class="line-numbers language-none"><code class="language-none">
void invokeSubscriber(PendingPost pendingPost) &#123;
       Object event &#x3D; pendingPost.event;
       Subscription subscription &#x3D; pendingPost.subscription;
       PendingPost.releasePendingPost(pendingPost);
       if (subscription.active) &#123;
           invokeSubscriber(subscription, event);
       &#125;
   &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们回到EventBus的一个参数的构造方法从HandlerPoster继续往下看下去，我们看到了BackgroundPoster这个分发器我们看一下源码</p>
<pre class="line-numbers language-none"><code class="language-none">

final class BackgroundPoster implements Runnable &#123;

    private final PendingPostQueue queue;
    private final EventBus eventBus;

    private volatile boolean executorRunning;

    BackgroundPoster(EventBus eventBus) &#123;
        this.eventBus &#x3D; eventBus;
        queue &#x3D; new PendingPostQueue();
    &#125;

    public void enqueue(Subscription subscription, Object event) &#123;
        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);
        synchronized (this) &#123;
            queue.enqueue(pendingPost);
            if (!executorRunning) &#123;
                executorRunning &#x3D; true;
                eventBus.getExecutorService().execute(this);
            &#125;
        &#125;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            try &#123;
                while (true) &#123;
                    PendingPost pendingPost &#x3D; queue.poll(1000);
                    if (pendingPost &#x3D;&#x3D; null) &#123;
                        synchronized (this) &#123;
                            &#x2F;&#x2F; Check again, this time in synchronized
                            pendingPost &#x3D; queue.poll();
                            if (pendingPost &#x3D;&#x3D; null) &#123;
                                executorRunning &#x3D; false;
                                return;
                            &#125;
                        &#125;
                    &#125;
                    eventBus.invokeSubscriber(pendingPost);
                &#125;
            &#125; catch (InterruptedException e) &#123;
                Log.w(&quot;Event&quot;, Thread.currentThread().getName() + &quot; was interruppted&quot;, e);
            &#125;
        &#125; finally &#123;
            executorRunning &#x3D; false;
        &#125;
    &#125;

&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>其实就是一个线程 我们看run方法，其实跟前面是的HandlerPoster类似就是将事件调用invokeSubscriber方法通过反射去执行，这里就不再多说了，我们继续看AsyncPoster 这个类,其实这个类跟上面的类似，只不过它是拿到一个进行反射调用</p>
<pre class="line-numbers language-none"><code class="language-none">class AsyncPoster implements Runnable &#123;

    private final PendingPostQueue queue;
    private final EventBus eventBus;

    AsyncPoster(EventBus eventBus) &#123;
        this.eventBus &#x3D; eventBus;
        queue &#x3D; new PendingPostQueue();
    &#125;

    public void enqueue(Subscription subscription, Object event) &#123;
        PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);
        queue.enqueue(pendingPost);
        eventBus.getExecutorService().execute(this);
    &#125;

    @Override
    public void run() &#123;
        PendingPost pendingPost &#x3D; queue.poll();
        if(pendingPost &#x3D;&#x3D; null) &#123;
            throw new IllegalStateException(&quot;No pending post available&quot;);
        &#125;
        eventBus.invokeSubscriber(pendingPost);
    &#125;

&#125;



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们继续看subscriberMethodFinder这个是一个方法找寻器，这个就是通过它来找寻有subscribe的方法，我们再后面再详细介绍这个类<br>后面像各种logSubscriberExceptions等异常 我们就不深入介绍了，我们主要介绍主流程，不考虑很多异常情况，我们走主流程<br>接下里我们先来看一下注解</p>
<pre class="line-numbers language-none"><code class="language-none">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(&#123;ElementType.METHOD&#125;)
public @interface Subscribe &#123;
    ThreadMode threadMode() default ThreadMode.POSTING; 
        boolean sticky() default false;
    int priority() default 0;
&#125;


public enum ThreadMode &#123;
   POSTING,
    MAIN,
    BACKGROUND,
    ASYNC
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>我们看到注解后面有线程类型 ，是否是粘性事件，优先级，我们来看一下ThreadMode的种类，有几种 POSTING是默认类型，MAIN是主线程类型BACKGROUND是起一个线程来发送事件 ASYNC是一个事件类型就是起一个线程来发送事件<br>我们接下来看完注解 我们看一下register这个方法传入当前对象，我们直接看源码</p>
<pre class="line-numbers language-none"><code class="language-none">
public void register(Object subscriber) &#123;
      Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();
      List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);
      synchronized (this) &#123;
          for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;
              subscribe(subscriber, subscriberMethod);
          &#125;
      &#125;
  &#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>我们看到它通过subscriberMethodFinder.findSubscriberMethods(subscriberClass);这个方法找到了一个方法集合我们看一下SubscriberMethod这个封装类先</p>
<pre class="line-numbers language-none"><code class="language-none">public class SubscriberMethod &#123;
    final Method method;
    final ThreadMode threadMode;
    final Class&lt;?&gt; eventType;
    final int priority;
    final boolean sticky;
    &#x2F;** Used for efficient comparison *&#x2F;
    String methodString;

    public SubscriberMethod(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, int priority, boolean sticky) &#123;
        this.method &#x3D; method;
        this.threadMode &#x3D; threadMode;
        this.eventType &#x3D; eventType;
        this.priority &#x3D; priority;
        this.sticky &#x3D; sticky;
    &#125;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其实就是把这个方法注解类型给封装起来包括优先级，是否粘性，线程模式，属于哪个类的<br>我们回到 subscriberMethodFinder.findSubscriberMethods(subscriberClass)这个方法是怎么找的</p>
<pre class="line-numbers language-none"><code class="language-none">List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123;
        List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; METHOD_CACHE.get(subscriberClass);
        if (subscriberMethods !&#x3D; null) &#123;
            return subscriberMethods;
        &#125;

        if (ignoreGeneratedIndex) &#123;
            subscriberMethods &#x3D; findUsingReflection(subscriberClass);
        &#125; else &#123;
            subscriberMethods &#x3D; findUsingInfo(subscriberClass);
        &#125;
        if (subscriberMethods.isEmpty()) &#123;
            throw new EventBusException(&quot;Subscriber &quot; + subscriberClass
                    + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);
        &#125; else &#123;
            METHOD_CACHE.put(subscriberClass, subscriberMethods);
            return subscriberMethods;
        &#125;
    &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>先进行缓存的判断如果缓存有的话那么直接返回回去，如果缓存没有的话调用findUsingInfo方法去找我们跟到findUsingInfo中去看</p>
<pre class="line-numbers language-none"><code class="language-none">
private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;
        FindState findState &#x3D; prepareFindState();
        findState.initForSubscriber(subscriberClass);
        while (findState.clazz !&#x3D; null) &#123;
            findState.subscriberInfo &#x3D; getSubscriberInfo(findState);
            if (findState.subscriberInfo !&#x3D; null) &#123;
                SubscriberMethod[] array &#x3D; findState.subscriberInfo.getSubscriberMethods();
                for (SubscriberMethod subscriberMethod : array) &#123;
                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;
                        findState.subscriberMethods.add(subscriberMethod);
                    &#125;
                &#125;
            &#125; else &#123;
                findUsingReflectionInSingleClass(findState);
            &#125;
            findState.moveToSuperclass();
        &#125;
        return getMethodsAndRelease(findState);
    &#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<p>我们先看一下FindState这个类 这个类里面有几个重要的列表和map有方法的集合，有方法为value 方法的参数对象为key的map 有方法为key订阅对象为value的map</p>
<pre class="line-numbers language-none"><code class="language-none">

final List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; new ArrayList&lt;&gt;();
       final Map&lt;Class, Object&gt; anyMethodByEventType &#x3D; new HashMap&lt;&gt;();
       final Map&lt;String, Class&gt; subscriberClassByMethodKey &#x3D; new HashMap&lt;&gt;();
       final StringBuilder methodKeyBuilder &#x3D; new StringBuilder(128);

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>我们回到前面prepareFindState这方法是从池子中看能不能找到一样的，可以就复用 不可以就创建一个然后调用initForSubscriber这个方法这个方法其实是一些简单赋值操作我们看源码</p>
<pre class="line-numbers language-none"><code class="language-none">private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123;
        FindState findState &#x3D; prepareFindState();
        findState.initForSubscriber(subscriberClass);
        while (findState.clazz !&#x3D; null) &#123;
            findState.subscriberInfo &#x3D; getSubscriberInfo(findState);
            if (findState.subscriberInfo !&#x3D; null) &#123;
                SubscriberMethod[] array &#x3D; findState.subscriberInfo.getSubscriberMethods();
                for (SubscriberMethod subscriberMethod : array) &#123;
                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;
                        findState.subscriberMethods.add(subscriberMethod);
                    &#125;
                &#125;
            &#125; else &#123;
                findUsingReflectionInSingleClass(findState);
            &#125;
            findState.moveToSuperclass();
        &#125;
        return getMethodsAndRelease(findState);
    &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>其实大部分的情况下都会走到findUsingReflectionInSingleClass这个方法，这个才是解析注解方法的核心,我们看一下源码</p>
<pre class="line-numbers language-none"><code class="language-none">
private void findUsingReflectionInSingleClass(FindState findState) &#123;
       Method[] methods;
       try &#123;
           &#x2F;&#x2F; This is faster than getMethods, especially when subscribers are fat classes like Activities
           methods &#x3D; findState.clazz.getDeclaredMethods();
       &#125; catch (Throwable th) &#123;
           &#x2F;&#x2F; Workaround for java.lang.NoClassDefFoundError, see https:&#x2F;&#x2F;github.com&#x2F;greenrobot&#x2F;EventBus&#x2F;issues&#x2F;149
           methods &#x3D; findState.clazz.getMethods();
           findState.skipSuperClasses &#x3D; true;
       &#125;
       for (Method method : methods) &#123;
           int modifiers &#x3D; method.getModifiers();
           if ((modifiers &amp; Modifier.PUBLIC) !&#x3D; 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) &#x3D;&#x3D; 0) &#123;
               Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();
               if (parameterTypes.length &#x3D;&#x3D; 1) &#123;
                   Subscribe subscribeAnnotation &#x3D; method.getAnnotation(Subscribe.class);
                   if (subscribeAnnotation !&#x3D; null) &#123;
                       Class&lt;?&gt; eventType &#x3D; parameterTypes[0];
                       if (findState.checkAdd(method, eventType)) &#123;
                           ThreadMode threadMode &#x3D; subscribeAnnotation.threadMode();
                           findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                   subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                       &#125;
                   &#125;
               &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;
                   String methodName &#x3D; method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
                   throw new EventBusException(&quot;@Subscribe method &quot; + methodName +
                           &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);
               &#125;
           &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;
               String methodName &#x3D; method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
               throw new EventBusException(methodName +
                       &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);
           &#125;
       &#125;
   &#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>






<p>首先通过findState的有一个订阅者的类反射拿到所有方法，对所有方法进行遍历，对每个方法进行遍历方法必须为PUBLIC，参数长度必须为1，然后必须有Subscribe这个注解获取方法的线程模式，是否是粘性事件，权重大小等 加入到findState的 subscriberMethods就是方法集合，最后返回方法集合，subscriberMethods这个类已经在上面详细讲解了，其实就是一个方法的封装,<br>我们回到EventBus 的register方法 其实我们上面就是做好找到所有的方法并且每个方法都封装好最后成为一个 List subscriberMethods这个方法列表我们回顾一下源码</p>
<pre class="line-numbers language-none"><code class="language-none">

public void register(Object subscriber) &#123;
       Class&lt;?&gt; subscriberClass &#x3D; subscriber.getClass();
       List&lt;SubscriberMethod&gt; subscriberMethods &#x3D; subscriberMethodFinder.findSubscriberMethods(subscriberClass);
       synchronized (this) &#123;
           for (SubscriberMethod subscriberMethod : subscriberMethods) &#123;
               subscribe(subscriber, subscriberMethod);
           &#125;
       &#125;
   &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>我们看一下 subscribe(subscriber, subscriberMethod);</p>
<pre class="line-numbers language-none"><code class="language-none">
private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123;
       Class&lt;?&gt; eventType &#x3D; subscriberMethod.eventType;
       Subscription newSubscription &#x3D; new Subscription(subscriber, subscriberMethod);
       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);
       if (subscriptions &#x3D;&#x3D; null) &#123;
           subscriptions &#x3D; new CopyOnWriteArrayList&lt;&gt;();
           subscriptionsByEventType.put(eventType, subscriptions);
       &#125; else &#123;
           if (subscriptions.contains(newSubscription)) &#123;
               throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                       + eventType);
           &#125;
       &#125;
       int size &#x3D; subscriptions.size();
       for (int i &#x3D; 0; i &lt;&#x3D; size; i++) &#123;
           if (i &#x3D;&#x3D; size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;
               subscriptions.add(i, newSubscription);
               break;
           &#125;
       &#125;

       List&lt;Class&lt;?&gt;&gt; subscribedEvents &#x3D; typesBySubscriber.get(subscriber);
       if (subscribedEvents &#x3D;&#x3D; null) &#123;
           subscribedEvents &#x3D; new ArrayList&lt;&gt;();
           typesBySubscriber.put(subscriber, subscribedEvents);
       &#125;
       subscribedEvents.add(eventType);
       if (subscriberMethod.sticky) &#123;
           if (eventInheritance) &#123;
         &lt;Class&gt;).
               Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries &#x3D; stickyEvents.entrySet();
               for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;
                   Class&lt;?&gt; candidateEventType &#x3D; entry.getKey();
                   if (eventType.isAssignableFrom(candidateEventType)) &#123;
                       Object stickyEvent &#x3D; entry.getValue();
                       checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                   &#125;
               &#125;
           &#125; else &#123;
               Object stickyEvent &#x3D; stickyEvents.get(eventType);
               checkPostStickyEventToSubscription(newSubscription, stickyEvent);
           &#125;
       &#125;
   &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<pre class="line-numbers language-none"><code class="language-none">
final class Subscription &#123;
    final Object subscriber;
    final SubscriberMethod subscriberMethod;
    &#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>我们先看一下Subscription 点击进去其实就是一个更大的封装类里面有每个一个订阅者 对应一个方法，我们接下里看下面代码</p>
<pre class="line-numbers language-none"><code class="language-none">
CopyOnWriteArrayList&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);
       if (subscriptions &#x3D;&#x3D; null) &#123;
           subscriptions &#x3D; new CopyOnWriteArrayList&lt;&gt;();
           subscriptionsByEventType.put(eventType, subscriptions);

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">
我们先总结一下subscribe这个方法做了什么
（1）首先判断是否有注册过改事件了如果注册了就抛出异常，如果没有就是正常的，创建一个Subscription 其实这个类就是一个注册类对应一个方法的封装，然后创建一个列表
（2）按优先级加入subscriptionsByEventType 这个是一个已发出的参数类型为key subscriptions为value的map集合，然后将subscription根据优先级加入value中
（3）然后在添加到typesBySubscriber的value的list中这个是以Subscriber为key 方法的参数为value的map中
（4）分发粘性事件checkPostStickyEventToSubscription
我们简单看一下checkPostStickyEventToSubscription,其实他最后是调用postToSubscription方法通过不同的线程模式调用不同的分发器，不同的分发器我们等一下讲，这里我们只要知道粘性事件也是走到了这里就可以了
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123;
      if (stickyEvent !&#x3D; null) &#123;
          &#x2F;&#x2F; If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)
          &#x2F;&#x2F; --&gt; Strange corner case, which we don&#39;t take care of here.
          postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() &#x3D;&#x3D; Looper.myLooper());
      &#125;
  &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">
private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;
    switch (subscription.subscriberMethod.threadMode) &#123;
        case POSTING:
            invokeSubscriber(subscription, event);
            break;
        case MAIN:
            if (isMainThread) &#123;
                invokeSubscriber(subscription, event);
            &#125; else &#123;
                mainThreadPoster.enqueue(subscription, event);
            &#125;
            break;
        case BACKGROUND:
            if (isMainThread) &#123;
                backgroundPoster.enqueue(subscription, event);
            &#125; else &#123;
                invokeSubscriber(subscription, event);
            &#125;
            break;
        case ASYNC:
            asyncPoster.enqueue(subscription, event);
            break;
        default:
            throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);
    &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>最后我们注册好了之后，我们就要来最后一步发送事件了</p>
<pre class="line-numbers language-none"><code class="language-none">
public void postEvent() &#123;
    EventBus.getDefault().post(new MyBusEvent(&quot;hhh&quot;));
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<pre class="line-numbers language-none"><code class="language-none">

public void post(Object event) &#123;
        PostingThreadState postingState &#x3D; currentPostingThreadState.get();
        List&lt;Object&gt; eventQueue &#x3D; postingState.eventQueue;
        eventQueue.add(event);

        if (!postingState.isPosting) &#123;
            postingState.isMainThread &#x3D; Looper.getMainLooper() &#x3D;&#x3D; Looper.myLooper();
            postingState.isPosting &#x3D; true;
            if (postingState.canceled) &#123;
                throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);
            &#125;
            try &#123;
                while (!eventQueue.isEmpty()) &#123;
                    postSingleEvent(eventQueue.remove(0), postingState);
                &#125;
            &#125; finally &#123;
                postingState.isPosting &#x3D; false;
                postingState.isMainThread &#x3D; false;
            &#125;
        &#125;
    &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>我们先看一下PostingThreadState</p>
<pre class="line-numbers language-none"><code class="language-none">final static class PostingThreadState &#123;
       final List&lt;Object&gt; eventQueue &#x3D; new ArrayList&lt;Object&gt;();
       boolean isPosting;
       boolean isMainThread;
       Subscription subscription;
       Object event;
       boolean canceled;
   &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>其实就是事件发送的一个封装类，包括是否正在发送，是否主线程是否取消等，然后调用postSingleEvent方法，我们看如何实现的</p>
<pre class="line-numbers language-none"><code class="language-none">

private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123;
        Class&lt;?&gt; eventClass &#x3D; event.getClass();
        boolean subscriptionFound &#x3D; false;
        if (eventInheritance) &#123;
            List&lt;Class&lt;?&gt;&gt; eventTypes &#x3D; lookupAllEventTypes(eventClass);
            int countTypes &#x3D; eventTypes.size();
            for (int h &#x3D; 0; h &lt; countTypes; h++) &#123;
                Class&lt;?&gt; clazz &#x3D; eventTypes.get(h);
                subscriptionFound |&#x3D; postSingleEventForEventType(event, postingState, clazz);
            &#125;
        &#125; else &#123;
            subscriptionFound &#x3D; postSingleEventForEventType(event, postingState, eventClass);
        &#125;
        if (!subscriptionFound) &#123;
            if (logNoSubscriberMessages) &#123;
                Log.d(TAG, &quot;No subscribers registered for event &quot; + eventClass);
            &#125;
            if (sendNoSubscriberEvent &amp;&amp; eventClass !&#x3D; NoSubscriberEvent.class &amp;&amp;
                    eventClass !&#x3D; SubscriberExceptionEvent.class) &#123;
                post(new NoSubscriberEvent(this, event));
            &#125;
        &#125;
    &#125;



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>做了很多处理 我们直接看postSingleEventForEventType方法，它返回了subscriptionFound 如果这个发送信息失败的话，就会打印出来，没有这个监听者，我们看一下postSingleEventForEventType是如何发送的。</p>
<pre class="line-numbers language-none"><code class="language-none">

private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123;
      CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;
      synchronized (this) &#123;
          subscriptions &#x3D; subscriptionsByEventType.get(eventClass);
      &#125;
      if (subscriptions !&#x3D; null &amp;&amp; !subscriptions.isEmpty()) &#123;
          for (Subscription subscription : subscriptions) &#123;
              postingState.event &#x3D; event;
              postingState.subscription &#x3D; subscription;
              boolean aborted &#x3D; false;
              try &#123;
                  postToSubscription(subscription, event, postingState.isMainThread);
                  aborted &#x3D; postingState.canceled;
              &#125; finally &#123;
                  postingState.event &#x3D; null;
                  postingState.subscription &#x3D; null;
                  postingState.canceled &#x3D; false;
              &#125;
              if (aborted) &#123;
                  break;
              &#125;
          &#125;
          return true;
      &#125;
      return false;
  &#125;



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>我们可以看到它通过post的事件类型去从subscriptionsByEventType这个map中找到subscriptions这个对象然后调动postToSubscription这个方法最后释放之类的就不讲了，我们直接看postToSubscription这个方法</p>
<pre class="line-numbers language-none"><code class="language-none">

private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123;
        switch (subscription.subscriberMethod.threadMode) &#123;
            case POSTING:
                invokeSubscriber(subscription, event);
                break;
            case MAIN:
                if (isMainThread) &#123;
                    invokeSubscriber(subscription, event);
                &#125; else &#123;
                    mainThreadPoster.enqueue(subscription, event);
                &#125;
                break;
            case BACKGROUND:
                if (isMainThread) &#123;
                    backgroundPoster.enqueue(subscription, event);
                &#125; else &#123;
                    invokeSubscriber(subscription, event);
                &#125;
                break;
            case ASYNC:
                asyncPoster.enqueue(subscription, event);
                break;
            default:
                throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);
        &#125;
    &#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>这个方法上面也有提到 我们详细展开讲解，根据方法的一个线程模式采用四种不同的方式如果方法注册使用主线程方式那么如果发送也在主线程那么直接使用invokeSubscriber，这个其实是使用反射机制调用</p>
<pre class="line-numbers language-none"><code class="language-none">

void invokeSubscriber(Subscription subscription, Object event) &#123;
        try &#123;
            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
        &#125; catch (InvocationTargetException e) &#123;
            handleSubscriberException(subscription, event, e.getCause());
        &#125; catch (IllegalAccessException e) &#123;
            throw new IllegalStateException(&quot;Unexpected exception&quot;, e);
        &#125;
    &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>如果注册主线程但是发送广播是在子线程的话，那么使用 mainThreadPoster.enqueue(subscription, event);<br>mainThreadPoster这个类之前也有讲过 其实就是继承Runnable开启了一个线程我们回顾一下源码</p>
<pre class="line-numbers language-none"><code class="language-none">
final class HandlerPoster extends Handler &#123;

   private final PendingPostQueue queue;
   private final int maxMillisInsideHandleMessage;
   private final EventBus eventBus;
   private boolean handlerActive;

   HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123;
       super(looper);
       this.eventBus &#x3D; eventBus;
       this.maxMillisInsideHandleMessage &#x3D; maxMillisInsideHandleMessage;
       queue &#x3D; new PendingPostQueue();
   &#125;

   void enqueue(Subscription subscription, Object event) &#123;
       PendingPost pendingPost &#x3D; PendingPost.obtainPendingPost(subscription, event);
       synchronized (this) &#123;
           queue.enqueue(pendingPost);
           if (!handlerActive) &#123;
               handlerActive &#x3D; true;
               if (!sendMessage(obtainMessage())) &#123;
                   throw new EventBusException(&quot;Could not send handler message&quot;);
               &#125;
           &#125;
       &#125;
   &#125;

   @Override
   public void handleMessage(Message msg) &#123;
       boolean rescheduled &#x3D; false;
       try &#123;
           long started &#x3D; SystemClock.uptimeMillis();
           while (true) &#123;
               PendingPost pendingPost &#x3D; queue.poll();
               if (pendingPost &#x3D;&#x3D; null) &#123;
                   synchronized (this) &#123;
                       &#x2F;&#x2F; Check again, this time in synchronized
                       pendingPost &#x3D; queue.poll();
                       if (pendingPost &#x3D;&#x3D; null) &#123;
                           handlerActive &#x3D; false;
                           return;
                       &#125;
                   &#125;
               &#125;
               eventBus.invokeSubscriber(pendingPost);
               long timeInMethod &#x3D; SystemClock.uptimeMillis() - started;
               if (timeInMethod &gt;&#x3D; maxMillisInsideHandleMessage) &#123;
                   if (!sendMessage(obtainMessage())) &#123;
                       throw new EventBusException(&quot;Could not send handler message&quot;);
                   &#125;
                   rescheduled &#x3D; true;
                   return;
               &#125;
           &#125;
       &#125; finally &#123;
           handlerActive &#x3D; rescheduled;
       &#125;
   &#125;
&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>这里其实就是通过handler来调用 eventBus.invokeSubscriber(pendingPost);来执行反射操作，换汤不换药<br>如果你方法注册用BACKGROUND且发送在主线程那么就使用BackgroundPoster，它其实就是一个线程，run方法的意思就是死循环然后将消息队列里面的所有信息全部调用反射去执行<br>如果你方法注册使用ASYNC 那么就会使用 asyncPoster.enqueue(subscription, event);这个asyncPoster其实也是一个线程，只是它每次取队列的一个进行反射调用<br>我们最后看一下反注册方法unregister方法</p>
<pre class="line-numbers language-none"><code class="language-none">

 public synchronized void unregister(Object subscriber) &#123;
        List&lt;Class&lt;?&gt;&gt; subscribedTypes &#x3D; typesBySubscriber.get(subscriber);
        if (subscribedTypes !&#x3D; null) &#123;
            for (Class&lt;?&gt; eventType : subscribedTypes) &#123;
                unsubscribeByEventType(subscriber, eventType);
            &#125;
            typesBySubscriber.remove(subscriber);
        &#125; else &#123;
            Log.w(TAG, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());
        &#125;
    &#125;




private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123;
        List&lt;Subscription&gt; subscriptions &#x3D; subscriptionsByEventType.get(eventType);
        if (subscriptions !&#x3D; null) &#123;
            int size &#x3D; subscriptions.size();
            for (int i &#x3D; 0; i &lt; size; i++) &#123;
                Subscription subscription &#x3D; subscriptions.get(i);
                if (subscription.subscriber &#x3D;&#x3D; subscriber) &#123;
                    subscription.active &#x3D; false;
                    subscriptions.remove(i);
                    i--;
                    size--;
                &#125;
            &#125;
        &#125;
    &#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>其实它很简单 就是将typesBySubscriber这个map中的对应key和value给删除掉 这样post方法就找不到这个 subscriptionsByEventType这个map也要删除掉对应的信息。</p>
<p>4.总结<br>看完了源码我们至少要懂得几个东西，一个是EventBus是靠两个关键的map来维护的，通过发送的事件类型来找到对应的方法来通过反射机制调用这个方法，这中间还穿插着很多知识点，像不同的线程采用不同的分发器，对方法的解析（反射拿到类所有方法进行遍历 ）和封装等。</p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">
                                    <span class="chip bg-color">源码阅读</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/04/01/UML%E5%85%A5%E9%97%A8%E5%88%9D%E8%AF%86/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="UML入门">
                        
                        <span class="card-title">UML入门</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-04-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/" class="post-category">
                                    日常积累
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/">
                        <span class="chip bg-color">日常积累</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/03/08/%E5%86%85%E5%AD%98%E6%8A%96%E5%8A%A8%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2MAT%E6%A3%80%E6%B5%8B/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="MAT内存泄露与内存抖动">
                        
                        <span class="card-title">MAT内存泄露与内存抖动</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-03-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96/" class="post-category">
                                    软件优化
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96/">
                        <span class="chip bg-color">软件优化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="6686195202"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2018-2022</span>
            
            <span id="year">2018</span>
            <a href="/about" target="_blank">Vinda</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/mvinda" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:820703048@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=820703048" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 820703048" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
